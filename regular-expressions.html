<!DOCTYPE html>
<meta charset=utf-8>
<title>Reguláris kifejezések - Ugorj fejest a Python 3-ba</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 5}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=root value=Keresés></div></form>
<p>Itt vagy: <a href=index.html>Kezdőlap</a> <span
class=u>&#8227;</span> <a href=table-of-contents.html#regular-expressions>Ugorj fejest a Python 3-ba</a> <span class=u>&#8227;</span>
<p id=level>Nehézségi szint: <span class=u title=közepes>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Reguláris kifejezések</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Egyesek amikor találkoznak egy problémával, azt gondolják: &#8222;Tudom, reguláris kifejezéseket fogok használni.&#8221; Innentől két problémájuk van. <span class=u>&#x275E;</span><br>&ndash; <a href=http://www.jwz.org/hacks/marginal.html>Jamie Zawinski</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Ugorj fejest</h2>
<p class=f>Egy kisebb szövegdarab kinyerése egy nagy szövegblokkból mindig kihívást jelent. Pythonban a karakterláncok rendelkeznek a keresésre és cserére szolgáló metódusokkal: <code>index()</code>, <code>find()</code>, <code>split()</code>, <code>count()</code>, <code>replace()</code> stb. De ezek a metódusok a legegyszerűbb esetekre vannak korlátozva. Az <code>index()</code> metódus például egyetlen bedrótozott részkarakterláncot keres, és a keresés mindig megkülönbözteti a kis- és nagybetűket. A kis- és nagybetűket meg nem különböztető kereséshez az <var>s</var> karaktersorozatban, meg kell hívnod az <code>s.lower()</code> vagy <code>s.upper()</code> metódust, és meg kell győződnöd, hogy a keresőkifejezések ennek megfelelően kis- vagy nagybetűsek. A <code>replace()</code> és <code>split()</code> metódusok ugyanilyen korlátozásokkal rendelkeznek.
<p>Ha a célod elérhető karakterlánc-metódusokkal, akkor használd azokat. Ezek gyorsak, egyszerűek és könnyen olvashatók, a gyors, egyszerű és könnyen olvasható kódról pedig rengeteget lehetne beszélni. De ha azt veszed észre, hogy rengeteg különböző karakterláncfüggvényt használsz <code>if</code> utasításokkal a speciális esetek kezelésére, vagy a <code>split()</code> és <code>join()</code> hívások láncolataival aprítod a karakterláncaid, akkor szükséges lehet a reguláris kifejezésekre váltás.
<p>A reguláris kifejezések hatékony és (nagyrészt) szabványosított lehetőséget adnak bonyolult karaktermintákat tartalmazó szövegek keresésére, cseréjére és feldolgozására. Ugyanakkor a reguláris kifejezések szintaxisa szoros, és a normál kóddal ellentétben az eredmény <em>olvashatóbb</em> lehet, mint a karakterláncfüggvények hosszú láncolatát használó barkácsmegoldás. A reguláris kifejezéseken belül még megjegyzések is elhelyezhetők, így részletes dokumentációt mellékelhetsz.

<blockquote class='note compare perl5'>
<p><span class=u>&#x261E;</span>Ha használtál reguláris kifejezéseket más nyelveken (mint a Perl, JavaScript vagy PHP), akkor a Python szintaxisa nagyon ismerős lesz. Olvasd el a <a href=http://docs.python.org/dev/library/re.html#module-contents><code>re</code> modul</a> összefoglalását az elérhető függvények és azok paramétereinek áttekintéséhez.
</blockquote>
<p class=a>&#x2042;

<h2 id=streetaddresses>Esettanulmány: lakcímek</h2>
<p>Ezen példák sorozatát egy valós életbeli probléma inspirálta, amellyel napi munkám során találkoztam évekkel ezelőtt, amikor egy örökölt rendszerből származó lakcímeket kellett kitisztítanom és szabványosítanom, mielőtt egy újabb rendszerbe importálhattam volna azokat. (Látod, ezeket a dolgokat nem csak úgy kitalálom, ez tényleg hasznos.) Ez a példa bemutatja, hogyan közelítettem meg a problémát.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>s = '100 NORTH MAIN ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.replace('ROAD', 'RD.')</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>'100 NORTH MAIN RD.'</samp>
<samp class=p>>>> </samp><kbd class=pp>s = '100 NORTH BROAD ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.replace('ROAD', 'RD.')</kbd>                <span class=u>&#x2461;</span></a>
<samp class=pp>'100 NORTH BRD. RD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s[:-4] + s[-4:].replace('ROAD', 'RD.')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>'100 NORTH BROAD RD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>import re</kbd>                               <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('ROAD$', 'RD.', s)</kbd>               <span class=u>&#x2464;</span></a>
<samp class=pp>'100 NORTH BROAD RD.'</samp></pre>
<ol>
<li>A célom a lakcím egységesítése, hogy a <code>'ROAD'</code> mindig <code>'RD.'</code>-ként legyen rövidítve. Első ránézésre ez elég egyszerűnek tűnt ahhoz, hogy a <code>replace()</code> karakterlánc-metódust használjam. Végül is minden adat már nagybetűs volt, így a kis- és nagybetűk eltérése nem okozhatott gondot. És a keresett kifejezés, a <code>'ROAD'</code> konstans volt. És ebben a megtévesztően egyszerű példában az <code>s.replace()</code> tényleg működik.
<li>Az élet ellenben tele van ellenpéldákkal, és gyorsan fel is fedeztem egyet. Itt az a probléma, hogy a <code>'ROAD'</code> kétszer jelenik meg a címben, egyszer a <code>'BROAD'</code> utcanév részeként, egyszer pedig önálló szóként. A <code>replace()</code> metódus mindkét előfordulást látja, és vakon kicseréli mindkettőt, emiatt a címek szépen megsemmisülnek.
<li>A több <code>'ROAD'</code> rész-karakterláncot tartalmazó címek problémájának megoldásához próbálkozhatsz valami ilyesmivel: a <code>'ROAD'</code> szót csak a cím utolsó négy karakterében (<code>s[-4:]</code>) keresed és cseréled, a karakterlánc többi részét (<code>s[:-4]</code>) pedig békén hagyod. De az már most látszik,  hogy ez így nyögvenyelős lesz. A minta például függ a lecserélt karakterlánc hosszától. (Ha a <code>'STREET'</code> szót cserélnéd az <code>'ST.'</code>-re, akkor a <code>s[:-6]</code> és <code>s[-6:].replace(...)</code> hívásokat kellene használnod.) Szeretnél hat hónap múlva visszatérni ehhez, és hibákat keresni benne? Azt tudom, hogy én biztosan nem.
<li>Ideje feljebb lépni a reguláris kifejezésekhez. A Pythonban a reguláris kifejezésekhez kapcsolódó minden funkcionalitás a <code>re</code> modulban van.
<li>Vess egy pillantást az első paraméterre: <code>'ROAD$'</code>. Ez egy egyszerű reguláris kifejezés, amely csak akkor illeszkedik a<code>'ROAD'</code> szóra, ha az a karakterlánc végén van. A <code>$</code> a &#8222;karakterlánc végét&#8221; jelenti. (Ennek párja a <code>^</code>, amely a &#8222;karakterlánc elejét&#8221; jelzi.) A <code>re.sub()</code> függvény használatakor az <var>s</var> karakterláncban a <code>'ROAD$'</code> reguláris kifejezést keresed, és helyettesíted az<code>'RD.'</code>-vel. Ez illeszkedik az <var>s</var> karakterlánc végén lévő <code>ROAD</code> előfordulásra, de <em>nem</em> illeszkedik a <code>BROAD</code> szóban lévő <code>ROAD</code> előfordulásra, mert ez az <var>s</var> közepén van.
</ol>
<aside>A ^ a karakterlánc elejére illeszkedik. A $ a karakterlánc végére illeszkedik. </aside>
<p>A címtisztítós történetet folytatva, hamarosan észrevettem, hogy az előző példa, a cím végére illeszkedő <code>'ROAD'</code> nem elég jó, mert nem minden címben van az utca megjelölve. Néhány cím egyszerűen csak az utca nevével végződik. Legtöbbször nem okozott gondot, de ha az utcanév a <code>'BROAD'</code> volt, akkor a reguláris kifejezés illeszkedett volna a karakterlánc végén lévő, a <code>'BROAD'</code> részét képező <code>'ROAD'</code> szövegre, de én nem ezt akartam.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>s = '100 BROAD'</kbd>
<samp class=p>>>> </samp><kbd class=pp>re.sub('ROAD$', 'RD.', s)</kbd>
<samp class=pp>'100 BRD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('\\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>'100 BROAD'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>'100 BROAD'</samp>
<samp class=p>>>> </samp><kbd class=pp>s = '100 BROAD ROAD APT. 3'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>'100 BROAD ROAD APT. 3'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD\b', 'RD.', s)</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'100 BROAD RD. APT 3'</samp></pre>
<ol>
<li>Amit <em>igazán</em> akartam, az olyan <code>'ROAD'</code> előfordulások megtalálása, amelyek a karakterlánc végén <em>és</em> önálló szóként voltak jelen (nem pedig egy hosszabb szó részeiként). Ezt reguláris kifejezésként a <code>\b</code> használatával lehet kifejezni, amely azt jelenti, hogy &#8222;pontosan itt szóhatárnak kell lennie&#8221;. Pythonban ezt az a tény bonyolítja, hogy a karakterláncban lévő <code>'\'</code> karaktert escape-elni kell. Ezt néha backslash járványnak hívják, és az egyik oka annak, hogy a reguláris kifejezések egyszerűbbek Perlben, mint Pythonban. A hátulütő ott van, hogy a Perl a reguláris kifejezéseket más szintaktikai elemekkel keveri, így hiba esetén nehéz megállapítani, hogy az a szintaktikai elemek vagy a reguláris kifejezés hibája-e.
<li>A backslash járvány megkerülése érdekében használhatsz úgynevezett <i>nyers karakterláncot</i>, a karakterlánc elé egy <code>r</code> beszúrásával. Ezzel megmondod a Pythonnak, hogy a karakterláncban semmit nem kell escape-elni: a <code>'\t'</code> egy tab karakter, de az <code>r'\t'</code> valójában egy fordított törtvonal karakter (<code>\</code>), amelyet a <code>t</code> betű követ. Reguláris kifejezések használatakor mindig a nyers karakterláncok használatát javaslom; ellenkező esetben a dolgok túl gyorsan válnak túl zavarossá (és a reguláris kifejezések egyébként is elég zavarosak).
<li><em>*sóhaj*</em>  Sajnos hamarosan további eseteket találtam, amelyek legyűrték a kódot. Ebben az esetben a lakcím a <code>'ROAD'</code> szót önállóan tartalmazta, de nem a végén, mert a cím az utca megadása után az ajtószámot is tartalmazta. Mivel a <code>'ROAD'</code> nem a karakterlánc legvégén van, nem illeszkedik, így az egész <code>re.sub()</code> hívás nem cserél le semmit, és visszakapod az eredeti karakterláncot, de nem ezt akartad.
<li>Ennek a problémának a megoldásához eltávolítottam a <code>$</code> karaktert, és egy újabb <code>\b</code>-t adtam hozzá. A reguláris kifejezés most ezt jelenti: &#8222;illeszkedj a <code>'ROAD'</code> szóra, ha az önállóan fordul elő a karakterláncban bárhol&#8221;, legyen az a végén, az elején vagy valahol középen.
</ol>
<p class=a>&#x2042;

<h2 id=romannumerals>Esettanulmány: római számok</h2>
<p>A római számokkal gyakran találkozhatsz, még ha nem is veszed mindig a fáradságot a visszafejtésükhöz. Előfordulnak régi filmek és TV-műsorok szerzői jog sorában (&#8222;Copyright <code>MCMXLVI</code>&#8221; a &#8222;Copyright <code>1946</code>&#8221; helyett), vagy a könyvtárak és egyetemek dedikációs falán (&#8222;alapítva <code>MDCCCLXXXVIII</code>&#8221; az &#8222;alapítva <code>1888</code>&#8221; helyett). Láthatsz ilyeneket vázlatokban és bibliográfiai hivatkozásokban. Ez a számábrázolási rendszer tényleg az ókori római birodalomban született (ezért ez a neve).
<p>A római számok alatt hét karaktert értünk, amelyek különböző módokon ismétlődve és kombinálódva ábrázolják a számokat.
<ul>
<li><code>I = 1</code>
<li><code>V = 5</code>
<li><code>X = 10</code>
<li><code>L = 50</code>
<li><code>C = 100</code>
<li><code>D = 500</code>
<li><code>M = 1000</code>
</ul>
<p>A következő néhány általános szabály vonatkozik a római számok előállítására:
<ul>
<li>Néha a karakterek összeadódnak. Az <code>I</code> = <code>1</code>, az <code>II</code> = <code>2</code> és az <code>III</code> = <code>3</code>. A <code>VI</code> = <code>6</code> (szó szerint &#8222;<code>5</code> és <code>1</code>&#8221;), a <code>VII</code> = <code>7</code> és a <code>VIII</code> = <code>8</code>.
<li>A tizes karakterek (<code>I</code>, <code>X</code>, <code>C</code> és <code>M</code>) legfeljebb háromszor ismételhetők. A <code>4</code> esetén azt a következő ötös karakterből kell kivonnod. A <code>4</code> nem ábrázolható <code>IIII</code>-ként; ehelyett a <code>IV</code> használatos (&#8222;<code>1</code>-gyel kisebb, mint <code>5</code>&#8221;). A <code>40</code> = <code>XL</code> (&#8222;<code>10</code>-zel kevesebb, mint <code>50</code>&#8221;), <code>41</code> = <code>XLI</code>, <code>42</code> = <code>XLII</code>, <code>43</code> = <code>XLIII</code> és a <code>44</code> = <code>XLIV</code> (&#8222;<code>10</code>-zel kevesebb, mint <code>50</code>, és <code>1</code>-gyel kevesebb, mint <code>5</code>&#8221;).
<li>Néha a karakterek&hellip; az összeadással ellentétesen viselkednek. Bizonyos karaktereket mások elé helyezve azokat kivonod a végső értékből. A <code>9</code> esetén például a tőle nagyobb legelső tizes karakterből kell kivonnod: a <code>8</code> = <code>VIII</code>, de a <code>9</code> = <code>IX</code> (&#8222;<code>1</code>-gyel kevesebb, mint <code>10</code>&#8221;), nem <code>VIIII</code> (mivel az <code>I</code> karakter nem ismételhető négyszer). A <code>90</code> = <code>XC</code>, a <code>900</code> = <code>CM</code>.
<li>Az ötös karakterek nem ismételhetők. A <code>10</code> mindig <code>X</code>-ként van ábrázolva, soha nem <code>VV</code>-ként. A <code>100</code> mindig <code>C</code>, soha nem <code>LL</code>.
<li>A római számok balról jobbra olvasandók, így a rendezések sorrendje nagyon sokat számít. A <code>DC</code> = <code>600</code>; a <code>CD</code> egy teljesen különböző szám (<code>400</code>, &#8222;<code>100</code>-zal kevesebb, mint <code>500</code>&#8221;). A <code>CI</code> = <code>101</code>; az <code>IC</code> nem is érvényes római szám (mert nem vonhatsz ki <code>1</code>-et közvetlenül a <code>100</code>-ból; 99 =<code>XCIX</code>, &#8222;<code>10</code>-zel kisebb, mint <code>100</code>, majd <code>1</code>-gyel kisebb, mint <code>10</code>&#8221;).
</ul>
<h3 id=thousands>Ezresek keresése</h3>
<p>Mi kellene egy tetszőleges karakterlánc érvényes római szám mivoltának ellenőrzéséhez?Nézzük meg számjegyenként. Mivel a római számok mindig a legnagyobbtól a legkisebb felé íródnak, kezdjük a legmagasabbal: az ezres hellyel. Az 1000 és nagyobb számok esetén az ezreseket <code>M</code> karakterek sorozata képviseli.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>minta = '^M?M?M?$'</kbd>        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'M')</kbd>     <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106FB58></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MM')</kbd>    <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106C290></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MMM')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106AA38></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MMMM')</kbd>  <span class=u>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, '')</kbd>      <span class=u>&#x2465;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106F4A8></samp></pre>
<ol>
<li>Ez a minta három részből áll. A <code>^</code> hatására az azt követő elemeket csak a karakterlánc elejére illeszti. Ha ez nem lenne megadva, akkor a minta mindenképp illeszkedne, bárhol is legyenek az <code>M</code> karakterek, de most nem ezt akarjuk. Arról kell meggyőződni, hogy ha vannak <code>M</code> karakterek, akkor azok a karakterlánc elején vannak. Az <code>M?</code> egyetlen elhagyható <code>M</code> karakterre illeszkedik. Mivel ez háromszor ismétlődik, ez a minta 0 - 3 egymást követő <code>M</code> karakterre illeszkedik. És a <code>$</code> a karakterlánc végére illeszkedik. Az elején lévő <code>^</code> karakterrel együtt ez azt jelenti, hogy a mintának a teljes karakterláncra kell illeszkednie, az <code>M</code> karakterek előtt vagy után semmi sem állhat.
<li>A <code>re</code> modul lényege a <code>search()</code> függvény, amely egy reguláris kifejezést (<var>pattern</var>) és egy karakterláncot (<code>'M'</code>) vár, amelyre megpróbálja a reguláris kifejezést illeszteni. Ha egyezést talál, akkor a <code>search()</code> egy objektumot ad vissza, amely különböző metódusokkal rendelkezik a találat leírására; ha nincs találat, akkor a <code>search()</code> a Python null értékét, a <code>None</code> objektumot adja vissza. Jelenleg csak azzal foglalkozunk, hogy a minta illeszkedik-e, amit a <code>search()</code> kimenetéből ránézésre meg lehet állapítani. Az <code>'M'</code> illeszkedik a reguláris kifejezésre, mert az első elhagyható <code>M</code> illeszkedik, a második és harmadik elhagyható <code>M</code> karakter pedig figyelmen kívül marad.
<li>Az <code>'MM'</code> illeszkedik, mert az első és második elhagyható <code>M</code> karakter illeszkedik, a harmadik <code>M</code> pedig figyelmen kívül marad.
<li>Az <code>'MMM'</code> illeszkedik, mert mind a három <code>M</code> karakter illeszkedik.
<li>Az <code>'MMMM'</code> nem illeszkedik. Mind a három <code>M</code> karakter illeszkedik, de a reguláris kifejezés ragaszkodik a karakterlánc végéhez, (a  <code>$</code> karakter miatt), ám a karakterláncnak még nincs vége (a negyedik <code>M</code> miatt). Így a <code>search()</code> a <code>None</code> objektumot adja vissza.
<li>Érdekes, hogy az üres karakterlánc is illeszkedik erre a reguláris kifejezésre, mert az összes <code>M</code> karakter elhagyható.
</ol>
<h3 id=hundreds>Százasok keresése</h3>
<aside>A ? elhagyhatóvá teszi a mintát.</aside>
<p>A százasok helye bonyolultabb az ezresekénél, mert több egymást kizáró módon fejezhető ki az értékétől függően.
<ul>
<li><code>100 = C</code>
<li><code>200 = CC</code>
<li><code>300 = CCC</code>
<li><code>400 = CD</code>
<li><code>500 = D</code>
<li><code>600 = DC</code>
<li><code>700 = DCC</code>
<li><code>800 = DCCC</code>
<li><code>900 = CM</code>
</ul>
<p>Így négy lehetséges minta van:
<ul>
<li><code>CM</code>
<li><code>CD</code>
<li>0 - 3 <code>C</code> karakter (nulla, ha a százasok helyiértéke 0)
<li><code>D</code>, amelyet 0 - 3 <code>C</code> karakter követ
</ul>
<p>Az utolsó két minta kombinálható:
<ul>
<li>egy elhagyható <code>D</code>, amelyet 0 - 3 <code>C</code> karakter követ
</ul>
<p>Ez a példa bemutatja, hogyan ellenőrizhető a százas helyiérték római szám mivolta.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>minta = '^M?M?M?(CM|CD|D?C?C?C?)$'</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MCM')</kbd>             <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 01070390></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MD')</kbd>              <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 01073A50></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MMMCCC')</kbd>          <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 010748A8></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MCMC')</kbd>            <span class=u>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, '')</kbd>                <span class=u>&#x2465;</span></a>
<samp>&lt;_sre.SRE_Match object at 01071D98></samp></pre>
<ol>
<li>Ez a minta ugyanúgy kezdődik, mint az előző: a karakterlánc elejét keresi (<code>^</code>), majd az ezres helyiértéket (<code>M?M?M?</code>). Ezután következik a zárójelben lévő új rész, amely három, egymást kölcsönösen kizáró minta függőleges vonalakkal elválasztott halmazát adja meg: <code>CM</code>, <code>CD</code> és <code>D?C?C?C?</code> (ez egy elhagyható <code>D</code>, amelyet 0 - 3 elhagyható <code>C</code> karakter követ). A reguláris kifejezések feldolgozása sorban (balról jobbra) ellenőrzi ezeket a mintákat, veszi az első illeszkedőt, és figyelmen kívül hagyja a többit.
<li>Az <code>'MCM'</code> illeszkedik, mert az első <code>M</code> illeszkedik, a második és harmadik <code>M</code> karakterek figyelmen kívül maradnak, és a <code>CM</code> illeszkedik (így a <code>CD</code> és <code>D?C?C?C?</code> minták nem is lesznek figyelembe véve). Az <code>MCM</code> az <code>1900</code> római számokkal leírt változata.
<li>Az <code>'MD'</code> illeszkedik, mert az első <code>M</code> illeszkedik, a második és harmadik <code>M</code> karakterek figyelmen kívül maradnak, és a <code>D?C?C?C?</code> minta illeszkedik a <code>D</code>-re (a három <code>C</code> karakter mindegyike elhagyható, és figyelmen kívül marad). Az <code>MD</code> az <code>1500</code> római számokkal leírt változata.
<li>Az <code>'MMMCCC'</code> illeszkedik, mert mind a három <code>M</code> karakter illeszkedik, és a <code>D?C?C?C?</code> minta illeszkedik a <code>CCC</code>-re (a <code>D</code> elhagyható és figyelmen kívül marad). Az <code>MMMCCC</code> a <code>3300</code> római számokkal leírt változata.
<li>Az <code>'MCMC'</code> nem illeszkedik. Az első <code>M</code> illeszkedik, a második és harmadik <code>M</code> karakterek figyelmen kívül maradnak, a <code>CM</code> illeszkedik, de ezután a <code>$</code> nem illeszkedik, mert még nincs vége a karakterláncnak (még van egy illeszkedés nélküli <code>C</code> karakter). A <code>C</code> <em>nem</em> illeszkedik a <code>D?C?C?C?</code> minta részeként, mert a kölcsönösen kizáró <code>CM</code> minta már illeszkedett.
<li>Érdekes módon az üres karakterlánc továbbra is illeszkedik erre a mintára, mert az összes <code>M</code> karakter elhagyható és figyelmen kívül marad, és az üres karakterlánc illeszkedik a <code>D?C?C?C?</code> mintára, amelynek minden karaktere elhagyható és figyelmen kívül marad.
</ol>
<p>Huh! Látod, a reguláris kifejezések milyen gyorsan válnak nagyon bonyolulttá? És még csak a római számok ezres és százas helyiértékeit fedtük le. De ha ezt az egészet sikerült követned, akkor a tizesek és az egyesek könnyűek lesznek, mert pontosan ugyanezt a mintát követik. De nézzünk egy másik módszert a minta kifejezésére.
<p class=a>&#x2042;

<h2 id=nmsyntax>A <code>{n,m}</code> szintaxis használata</h2>
<aside>A {1,4} egy minta 1 - 4 előfordulására illeszkedik.</aside>
<p>Az előző szakaszban egy olyan mintával foglalkoztunk, amelyben ugyanaz a karakter legfeljebb háromszor ismétlődhetett. Ezt reguláris kifejezésekkel máshogy is ki lehet fejezni, amelyet egyesek olvashatóbbnak ítélnek. Először nézzük meg az előző példában már használt metódust.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<samp class=p>>>> </samp><kbd class=pp>minta = '^M?M?M?$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'M')</kbd>     <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MM')</kbd>    <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp>>>> </samp><kbd class=pp>re.search(minta, 'MMM')</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp>>>> </samp><kbd class=pp>re.search(minta, 'MMMM')</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Ez a karakterlánc elejére illeszkedik, majd az első elhagyható <code>M</code> karakterre, de a második és harmadik <code>M</code>-re nem (de ez nem gond, ezek elhagyhatók), majd a karakterlánc végére.
<li>Ez a karakterlánc elejére illeszkedik, majd az első és második elhagyható <code>M</code> karakterre, de a harmadik <code>M</code>-re nem (de ez nem gond, ez elhagyható), majd a karakterlánc végére.
<li>Ez a karakterlánc elejére illeszkedik, majd mind a három elhagyható <code>M</code> karakterre, majd a karakterlánc végére.
<li>Ez a karakterlánc elejére illeszkedik, majd mind a három elhagyható <code>M</code> karakterre, de ezután nem illeszkedik a karakterlánc végére (mert még van egy nem illeszkedő <code>M</code>), így a minta nem illeszkedik és a <code>None</code> objektumot adja vissza.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>minta = '^M{0,3}$'</kbd>        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'M')</kbd>     <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MM')</kbd>    <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MMM')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEDA8></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MMMM')</kbd>  <span class=u>&#x2464;</span></a>
<samp>>>> </samp></pre>
<ol>
<li>Ez a minta azt mondja: &#8222;Illeszkedj a karakterlánc elejére, majd 0 és 3 közt (ezeket is beleértve) tetszőleges számú <code>M</code> karakterre, majd a karakterlánc végére.&#8221; A 0 és 3 tetszőleges szám lehet, ha legalább egy és legfeljebb 3 <code>M</code> karaktert szeretnél illeszteni, akkor ezt mondhatnád:<code>M{1,3}</code>.
<li>Ez a karakterlánc elejére illeszkedik, majd a három lehetséges <code>M</code> karakterből egyre, majd a karakterlánc végére.
<li>Ez a karakterlánc elejére illeszkedik, majd a három lehetséges <code>M</code> karakterből kettőre, majd a karakterlánc végére.
<li>Ez a karakterlánc elejére illeszkedik, majd a három lehetséges <code>M</code> karakterből háromra, majd a karakterlánc végére.
<li>Ez a karakterlánc elejére illeszkedik, majd a három lehetséges <code>M</code> karakterből háromra, de ezután <em>nem illeszkedik</em> a karakterlánc végére. A reguláris kifejezés legfeljebb csak három <code>M</code> karaktert engedélyez a karakterlánc vége előtt, de itt négy van, így a minta nem illeszkedik, és a <code>None</code> objektumot adja vissza.
</ol>
<h3 id=tensandones>Tizesek és egyesek keresése</h3>
<p>Bővítsük ki a római számos reguláris kifejezést a tizes és egyes helyiértékekkel. Ez a példa bemutatja a tizes helyiértékek ellenőrzését.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>minta = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MCMXL')</kbd>     <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MCML')</kbd>      <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MCMLX')</kbd>     <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MCMLXXX')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MCMLXXXX')</kbd>  <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Ez a karakterlánc elejére illeszkedik, majd az első elhagyható <code>M</code> karakterre, majd a <code>CM</code>-re, majd az <code>XL</code>-re, végül a karakterlánc végére. Ne feledd, a <code>(A|B|C)</code> szintaxis azt jelenti: &#8222;illeszkedjen az A, B vagy C közül pontosan egyre&#8221;. Az <code>XL</code> illeszkedik, így az <code>XC</code> és <code>L?X?X?X?</code> lehetőségek figyelmen kívül maradnak, és az illesztés a karakterlánc végével folytatódik. Az <code>MCMXL</code> az <code>1940</code> római számokkal leírt változata.
<li>Ez a karakterlánc elejére illeszkedik, majd az első elhagyható <code>M</code> karakterre, majd a <code>CM</code>-re, majd az <code>L?X?X?X?</code>-re. Az <code>L?X?X?X?</code>-ből az <code>L</code>-re illeszkedik, és kihagyja mind a három elhagyható <code>X</code> karaktert. Ezután a karakterlánc végére lép. Az <code>MCML</code> az <code>1950</code> római számokkal leírt változata.
<li>Ez a karakterlánc elejére illeszkedik, majd az első elhagyható <code>M</code> karakterre, majd a <code>CM</code>-re, majd az elhagyható <code>L</code>-re és az első elhagyható <code>X</code>-re, kihagyja a második és harmadik elhagyható <code>X</code>-et, végül a karakterlánc végére is illeszkedik. Az <code>MCMLX</code> az <code>1960</code> római számokkal leírt változata.
<li>Ez a karakterlánc elejére illeszkedik, majd az első elhagyható <code>M</code> karakterre, majd a <code>CM</code>-re, majd az elhagyható <code>L</code>-re és mind a három elhagyható <code>X</code>-re, végül a karakterlánc végére is illeszkedik. Az <code>MCMLXXX</code> az <code>1980</code> római számokkal leírt változata.
<li>Ez a karakterlánc elejére illeszkedik, majd az első elhagyható <code>M</code> karakterre, majd a <code>CM</code>-re, majd az elhagyható <code>L</code>-re és mind a három elhagyható <code>X</code>-re, végül a karakterlánc végére <em>nem illeszkedik</em>, mert még hátra van egy nem illeszkedő <code>X</code>. Így végül a teljes minta nem fog illeszkedni, és a <code>None</code> objektumot adja vissza. Az <code>MCMLXXXX</code> nem érvényes római szám.
</ol>
<aside>Az (A|B) csak az A vagy a B minta egyikére illeszkedik, mindkettőre soha.</aside>
<p>Az egyes helyiértékek kifejezése ugyanazt a mintát követi. Megkíméllek a részletektől, és csak a végeredményt mutatom.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>minta = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$'</kbd>
</pre><p>Hogy fog ez kinézni az alternatív <code>{n,m}</code> szintaxis használatával? Ez a példa bemutatja az új szintaxist.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>minta = '^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MDLV')</kbd>              <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MMDCLXVI')</kbd>          <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MMMDCCCLXXXVIII')</kbd>   <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'I')</kbd>                 <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp></pre>
<ol>
<li>Ez a karakterlánc elejére illeszkedik, majd a három lehetséges <code>M</code> karakterből egyre, majd a <code>D?C{0,3}</code> kifejezésre. Ebből az elhagyható <code>D</code> karakterre illeszkedik, és a három lehetséges <code>C</code> karakterből nullára. Továbbhaladva illeszkedik a <code>L?X{0,3}</code> kifejezésre is, ebből az elhagyható <code>L</code> karakterre, és a három lehetséges <code>X</code> karakterből nullára. Ezután illeszkedik a <code>V?I{0,3}</code> kifejezésre, ebből az elhagyható <code>V</code> karakterre és a három lehetséges <code>I</code> karakterből nullára, végül a karakterlánc végére. Az <code>MDLV</code> az <code>1555</code> római számokkal leírt változata.
<li>Ez a karakterlánc elejére illeszkedik, majd a három lehetséges <code>M</code> karakterből kettőre, majd a <code>D?C{0,3}</code> kifejezésből a <code>D</code>-re és a lehetséges három <code>C</code> karakterből egyre, majd az <code>L?X{0,3}</code> kifejezésből az <code>L</code>-re és a lehetséges három <code>X</code> karakterből egyre, majd a <code>V?I{0,3}</code> kifejezésből a <code>V</code>-re és a három lehetséges <code>I</code> karakterből egyre, végül a karakterlánc végére is illeszkedik. Az <code>MMDCLXVI</code> a <code>2666</code> római számokkal leírt változata.
<li>Ez a karakterlánc elejére illeszkedik, majd a három <code>M</code> karakterből háromra, majd a <code>D?C{0,3}</code> kifejezésből a <code>D</code>-re és a három <code>C</code> karakterből háromra, majd az <code>L?X{0,3}</code> kifejezésből az <code>L</code>-re és a három <code>X</code> karakterből háromra, majd a <code>V?I{0,3}</code> kifejezésből a <code>V</code>-re és a három lehetséges <code>I</code> karakterből háromra, végül a karakterlánc végére is illeszkedik. Az <code>MMMDCCCLXXXVIII</code> a <code>3888</code> római számokkal leírt változata, és a kiterjesztett szintaxis nélkül leírható leghosszabb római szám.
<li>Nagyon figyelj. (Mintha egy bűvész lennék. &#8222;Nagyon figyeljetek gyerekek, mindjárt előhúzok egy nyuszit a kalapomból.&#8221;) Ez a karakterlánc elejére illeszkedik, majd a három <code>M</code>-ből nullára illeszkedik, majd a <code>D?C{0,3}</code> kifejezésből kihagyja az elhagyható <code>D</code>-t és a három <code>C</code>-ből nullára illeszkedik, majd az <code>L?X{0,3}</code> kifejezésből kihagyja az elhagyható <code>L</code>-et és a három <code>X</code>-ből nullára illeszkedik, majd a <code>V?I{0,3}</code> kifejezésből kihagyja az elhagyható <code>V</code>-t és a három <code>I</code>-ből egyre illeszkedik. Ezután a karakterlánc végére illeszkedik. Bámulatos, hol tart már a tudomány.
</ol>
<p>Ha ezt mind követted és elsőre megértetted, akkor jobb vagy mint én voltam. Most képzeld el, hogy valaki más reguláris kifejezéseit próbálod megérteni, egy nagy program kritikus függvényének a közepén. Vagy akár csak a saját reguláris kifejezéseid továbbfejlesztését képzeld el pár hónap múlva. Csináltam ilyet, és nem szép látvány.
<p>Most pedig fedezzünk fel egy alternatív szintaxist, amely segíthet a kifejezések karbantarthatóan megírni.
<p class=a>&#x2042;

<h2 id=verbosere>Részletes reguláris kifejezések</h2>
<p>Amikkel eddig foglalkoztunk, azokat &#8222;tömör&#8221; reguláris kifejezéseknek hívom. Amint láthattad, nehezen olvashatók és még ha rá is jössz, hogy mit csinálnak, nincs rá garancia, hogy hat hónap múlva is meg fogod érteni őket. Amire igazán szükség van, az a beágyazott dokumentáció.
<p>A Python ezt lehetővé teszi az úgynevezett <i>részletes reguláris kifejezésekkel</i>. A részletes reguláris kifejezés két tekintetben tér el a tömör reguláris kifejezéstől:
<ul>
<li>Az üres helyek figyelmen kívül maradnak. A szóközök, tabok és kocsivissza karakterek nem kerülnek illesztésre szóközökként, tabokként és kocsivissza karakterekként. Egyáltalán nem kerülnek illesztésre. (Ha szóközt akarsz illeszteni egy részletes reguláris kifejezésben, akkor escape-elned kell egy elé tett fordított törtvonallal).
<li>A megjegyzések figyelmen kívül maradnak. A részletes reguláris kifejezésben található megjegyzés ugyanolyan, mint a Python kódban lévő: egy <code>#</code> karakterrel kezdődik, és a sor végéig tart. Ebben az esetben ez egy többsoros karakterláncon belüli megjegyzés, de ugyanúgy használható.
</ul>
<p>Egy példán keresztül mindjárt világosabb lesz. Dolgozzuk át a korábban használt tömör reguláris kifejezést, és alakítsuk részletes reguláris kifejezéssé. Ez a példa bemutatja ennek módját.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>minta = '''
    ^                   # karakterlánc eleje
    M{0,3}              # ezresek - 0 és 3 közti M
    (CM|CD|D?C{0,3})    # százasok - 900 (CM), 400 (CD), 0-300 (0 és 3 közti C),
                        #            vagy 500-800 (D, amelyet 0 és 3 közti C követ)
    (XC|XL|L?X{0,3})    # tizesek - 90 (XC), 40 (XL), 0-30 (0 és 3 közti X),
                        #        vagy 50-80 (L, amelyet 0 és 3 közti X követ)
    (IX|IV|V?I{0,3})    # egyesek - 9 (IX), 4 (IV), 0-3 (0 és 3 közti I),
                        #        vagy 5-8 (V, amelyet 0 és 3 közti I követ)
    $                   # karakterlánc vége
    '''</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'M', re.VERBOSE)</kbd>                 <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MCMLXXXIX', re.VERBOSE)</kbd>         <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'MMMDCCCLXXXVIII', re.VERBOSE)</kbd>   <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(minta, 'M')</kbd>                             <span class=u>&#x2463;</span></a></pre>
<ol>
<li>A részletes reguláris kifejezések használatával kapcsolatban a legfontosabb megjegyeznivaló, hogy át kell adnod egy extra argumentumot: ez a <code>re.VERBOSE</code> konstans. Ezt a <code>re</code> modul definiálja, és ez jelzi, hogy a mintát részletes reguláris kifejezésként kell kezelni. Amint láthatod, a minta meglehetősen sok üres helyet tartalmaz (mind figyelmen kívül marad), és jónéhány megjegyzés is van benne (mind figyelmen kívül marad). Az üres helyek és a megjegyzések figyelmen kívül hagyása után ez pontosan ugyanaz a reguláris kifejezés, mint amit az előző szakaszban láttál, de sokkal olvashatóbb.
<li>Ez a karakterlánc elejére illeszkedik, majd a lehetséges három <code>M</code> karakter egyikére, majd a <code>CM</code>-re, majd az <code>L</code>-re és a három lehetséges <code>X</code>-re, majd az <code>IX</code>-re, végül a karakterlánc végére is illeszkedik.
<li>Ez a karakterlánc elejére illeszkedik, majd a három lehetséges <code>M</code> mindegyikére, majd a <code>D</code>-re és a három lehetséges <code>C</code> mindegyikére, majd az <code>L</code>-re és a három lehetséges <code>X</code> mindegyikére, majd a <code>V</code>-re és a három lehetséges <code>I</code> mindegyikére, végül a karakterlánc végére is illeszkedik.
<li>Ez nem illeszkedik. Miért? Mert nem rendelkezik a <code>re.VERBOSE</code> jelzővel, így a <code>re.search</code> függvény a mintát tömör reguláris kifejezésként kezeli, amelyben sok üres hely és kettőskereszt jelek vannak. A Python nem tudja automatikusan felismerni, hogy egy reguláris kifejezés részletes-e vagy sem. A Python feltételezi, hogy minden reguláris kifejezés tömör, hacsak nem mondod azt kifejezetten, hogy részletes.
</ol>
<p class=a>&#x2042;

<h2 id=phonenumbers>Esettanulmány: telefonszámok értelmezése</h2>
<aside>A \d bármely numerikus számjegyre (0&ndash;9) illeszkedik. A \D mindenre illeszkedik a számjegyek kivételével.</aside>
<p>Eddig teljes minták illesztésére koncentráltál. A minta vagy illeszkedik, vagy nem. De a reguláris kifejezések ennél sokkal hatékonyabbak.
Amikor egy reguláris kifejezés <em>illeszkedik</em>, akkor az egyes részeit kiemelheted. Meghatározhatod, hogy mi hol illeszkedett.
<p>Ez a példa egy másik valós életbeli problémából jön, amellyel egy korábbi munkahelyemen találkoztam. A probléma: egy amerikai telefonszám értelmezése. Az ügyfél a szám szabad formátumú megadására kért lehetőséget (egyetlen mezőben), de ezután a körzetszámot, törzset, számot és egy elhagyható melléket külön-külön szerette volna tárolni a cég adatbázisában. Átkutattam a webet, és sok példát találtam olyan reguláris kifejezésekre, amelyek erre szolgáltak, de egyik sem volt elég megengedő.
<p>Az alábbi telefonszámok elfogadására kellett képesnek lennie a kódnak:
<ul>
<li><code>800-555-1212</code>
<li><code>800 555 1212</code>
<li><code>800.555.1212</code>
<li><code>(800) 555-1212</code>
<li><code>1-800-555-1212</code>
<li><code>800-555-1212-1234</code>
<li><code>800-555-1212x1234</code>
<li><code>800-555-1212 ext. 1234</code>
<li><code>work 1-(800) 555.1212 #1234</code>
</ul>
<p>Micsoda változatosság! Ezen esetek mindegyikében tudnom kellett, hogy a körzetszám a <code>800</code>, a törzs az <code>555</code> a telefonszám többi része pedig az <code>1212</code> volt. A mellékkel rendelkezők esetén tudnom kellett, hogy a mellék az <code>1234</code> volt.
<p>Haladjunk végig a telefonszám-értelmezés megoldásának kifejlesztésén. Ez a példa bemutatja az első lépést.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta = re.compile(r'^(\d{3})-(\d{3})-(\d{4})$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212').groups()</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212-1234')</kbd>                 <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212-1234').groups()</kbd>        <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AttributeError: 'NoneType' object has no attribute 'groups'</samp></pre>
<ol>
<li>A reguláris kifejezéseket mindig balról jobbra olvassuk. Ez illeszkedik a karakterlánc elejére, majd a <code>(\d{3})</code>-ra. Mi az a <code>\d{3}</code>?  Nos, a <code>\d</code> azt jelenti: &#8222;tetszőleges numerikus számjegy&#8221; (0-tól <code>9</code>-ig). A <code>{3}</code> azt jelenti: &#8222;illessz pontosan három numerikus számjegyet&#8221;; ez a korábban látott <a href=#nmsyntax><code>{n,m} szintaxis</code></a> egy változata. Az egész zárójelek közé tétele azt jelenti: &#8222;illessz pontosan három numerikus számjegyet<em>, és jegyezd meg azokat később lekérdezhető csoportként</em>&#8221;. Ezután egy literális kötőjelre illeszkedik. Ezután egy újabb, három számjegyből álló csoportra illeszkedik. Ezután egy újabb literális kötőjelre illeszkedik. Ezután egy újabb, pontosan négy számjegyből álló csoportra. Ezután a karakterlánc végére illeszkedik.
<li>A reguláris kifejezések értelmezője által megjegyzett csoportok eléréséhez használd a <code>groups()</code> metódust a <code>search()</code> metódus által visszaadott objektumon. Ez a reguláris kifejezésben megadott számú csoportot tartalmazó ennest ad vissza. Ebben az esetben három csoportot adtál meg, egy háromjegyűt, egy másik háromjegyűt és egy négyjegyűt.
<li>Ez a reguláris kifejezés nem a végső válasz, mert nem kezeli a végén mellékkel rendelkező telefonszámokat. Ehhez ki kell terjeszteni a reguláris kifejezést.
<li>Ez pedig az, amiért soha nem szabad &#8222;összeláncolnod&#8221; a <code>search()</code> és <code>groups()</code> metódusokat az éles kódban. Ha a <code>search()</code> metódus nem ad vissza találatot, akkor a <a href=native-datatypes.html#none><code>None</code></a> objektumot adja vissza, nem pedig egy reguláris kifejezés találati objektumot. A <code>None.groups()</code> hívása egy teljesen nyilvánvaló kivételt dob: a <code>None</code> nem rendelkezik <code>groups()</code> metódussal. (Természetesen ennél egy picivel kevésbé nyilvánvaló, amikor a kódod mélyéről kapod ezt a kivételt. Igen, ezt tapasztalatból mondom.)
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta = re.compile(r'^(\d{3})-(\d{3})-(\d{4})-(\d+)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212-1234').groups()</kbd>              <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800 555 1212 1234')</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212')</kbd>                            <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Ez a reguláris kifejezés majdnem azonos az előzővel. Ahogy az előbb, a karakterlánc elejét illeszti, majd egy három számjegyből álló megjegyzett csoportot, majd egy kötőjelet, majd egy három számjegyből álló megjegyzett csoportot, majd egy kötőjelet, majd egy négy számjegyből álló megjegyzett csoportot. Ami új, az egy újabb kötőjel és egy legalább egy számjegyből álló megjegyzett csoport illesztése, végül pedig a karakterlánc végének illesztése.
<li>A <code>groups()</code> metódus most egy négy elemű ennest ad vissza, mivel a reguláris kifejezés most négy megjegyzendő csoportot definiál.
<li>Sajnos még ez a reguláris kifejezés sem a végső válasz, mert feltételezi, hogy a telefonszám különböző részeit kötőjelek választják el. Mi van, ha ezeket szóközök, vesszők vagy pontok választják el? Általánosabb megoldásra lesz szükség, hogy több különböző elválasztótípusra is illeszkedhessen a kifejezés.
<li>Hoppá! Ez a reguláris kifejezés nem csak hogy nem old meg mindent, de valójában még visszalépés is, mert most már nem tudja értelmezni a mellék <em>nélküli</em> telefonszámokat. Ez egyáltalán nem az, ami nekünk kell. Ha van mellék, akkor azt ismerni akarjuk, de ha nincs, a szám különböző részeit ugyanúgy ismerni akarjuk.
</ol>
<p>A következő példa bemutatja azt a reguláris kifejezést, amely képes a telefonszám különböző részei közti elválasztók kezelésére.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta = re.compile(r'^(\d{3})\D+(\d{3})\D+(\d{4})\D+(\d+)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800 555 1212 1234').groups()</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212-1234').groups()</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('80055512121234')</kbd>              <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212')</kbd>                <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Kapaszkodj. Ez a karakterlánc elejére illeszkedik, majd három számjegyből álló csoportra, majd a <code>\D+</code>-re. Ez meg mi? Nos a <code>\D</code> bármely karakterre illeszkedik, <em>kivéve</em> a numerikus számjegyeket, a <code>+</code> jelentése pedig &#8222;legalább 1&#8221;. Így a <code>\D+</code> legalább egy nem számjegy karakterre illeszkedik. Ezt kell használnod a kötőjel helyett a különböző elválasztók illesztésére.
<li>A <code>\D+</code> használata a <code>-</code> helyett azt jelenti, hogy mostantól azok a telefonszámok is illeszkednek, amelyek részeit kötőjelek helyett szóközök választják el.
<li>Természetesen a kötőjelekkel elválasztott telefonszámok továbbra is illeszkednek.
<li>Sajnos ez még mindig nem a végső válasz, mert feltételezi, hogy van elválasztó. Mi van, ha a telefonszámot szóközök vagy kötőjelek nélkül adják meg?
<li>Hoppá! Ez még mindig nem javította a mellék megkövetelésének problémáját. Most két problémád van, de mindkettő megoldható ugyanazzal az eljárással.
</ol>
<p>A következő példa bemutatja azt a reguláris kifejezést, amely képes az elválasztók <em>nélküli</em> telefonszámok kezelésére.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta = re.compile(r'^(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('80055512121234').groups()</kbd>      <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800.555.1212 x1234').groups()</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212').groups()</kbd>        <span class=u>&#x2463;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('(800)5551212 x1234')</kbd>           <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>A legutóbbi lépés óta egyetlen változás történt: az összes <code>+</code> lecserélése <code>*</code> karakterekre. A telefonszám részei közti <code>\D+</code> helyett mostantól a <code>\D*</code> áll. Emlékszel, hogy a <code>+</code> jelentése &#8222;legalább 1&#8221;?  Nos, a <code>*</code> jelentése &#8222;nulla vagy több&#8221;. Mostantól a reguláris kifejezés képes olyan telefonszámok értelmezésére is, amelyek egyáltalán nem tartalmaznak elválasztó karaktereket.
<li>Idesüss, ez tényleg működik. Miért? A karakterlánc elejét illesztetted, majd egy három számjegyből álló megjegyzett csoportot (<code>800</code>), majd nulla nem számjegy karaktert, majd egy három számjegyből álló megjegyzett csoportot (<code>555</code>), majd nulla nem számjegy karaktert, majd egy négy számjegyből álló megjegyzett csoportot (<code>1212</code>), majd nulla nem számjegy karaktert, majd egy tetszőleges számú számjegyből álló megjegyzett csoportot (<code>1234</code>), majd a karakterlánc végét.
<li>Most más változatok is működnek: pontok a kötőjelek helyett, szóköz és <code>x</code> a mellék előtt.
<li>Végre megoldottuk a másik régi problémát: a mellékek újra elhagyhatók. Ha nem található mellék, akkor a <code>groups()</code> metódus továbbra is egy négy elemű ennest ad vissza, de a negyedik elem egy üres karakterlánc.
<li>Utálok a rossz hírek hordozója lenni, de még nem vagy kész. Mi most a probléma? A körzetszám előtt egy extra karakter van, de a reguláris kifejezés feltételezi, hogy a körzetszám az első dolog a karakterlánc elején. Semmi gond, használhatod ugyanazt a &#8222;nulla vagy több nem numerikus karakter&#8221; eljárást a körzetszám előtti bevezető karakterek kihagyására.
</ol>
<p>A következő példa bemutatja a telefonszámok bevezető karaktereinek kezelésének módját.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta = re.compile(r'^\D*(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('(800)5551212 ext. 1234').groups()</kbd>                  <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212').groups()</kbd>                            <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('work 1-(800) 555.1212 #1234')</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Ez ugyanaz, mint az előző példában, kivéve hogy most a <code>\D*</code> kifejezést, a nulla vagy több nem numerikus karaktert illeszted az első megjegyzett csoport (a körzetszám) előtt. Vedd észre, hogy ezeket a nem numerikus karaktereket nem jegyezteted meg (nincsenek zárójelek közt). Ha a kifejezés talál ilyeneket, akkor kihagyja őket, és a körzetszámot csak akkor kezdi el megjegyezni, amikor megtalálja.
<li>A telefonszám sikeresen értelmezhető, még a körzetszám előtti nyitó zárójellel is. (A körzetszám utáni záró zárójel nem numerikus elválasztónak számít, és mint ilyet, az első megjegyzett csoport utáni <code>\D*</code> már kezeli.)
<li>Csak egy épségellenőrzés, győződjünk meg róla, hogy a korábban működő dolgok még mindig működnek. Mivel a kezdő karakterek teljesen elhagyhatók, ez illeszkedik a karakterlánc elejére, majd nulla nem numerikus karakterre, majd egy három számjegyből álló megjegyzett csoportra (<code>800</code>), majd egy nem számjegy karakterre (a kötőjelre), majd egy három számjegyből álló megjegyzett csoportra (<code>555</code>), majd egy nem számjegy karakterre (a kötőjelre), majd egy négy számjegyből álló megjegyzett csoportra (<code>1212</code>), majd nulla nem számjegy karakterre, majd egy nulla számjegyből álló megjegyzett csoportra, majd a karakterlánc végére.
<li>Itt jön az, amikor a reguláris kifejezések hatására ki akarom kaparni a szemem egy tompa tárggyal. Miért nem illeszkedik ez a telefonszám? Mert a körzetszám előtt van egy <code>1</code>-es, de feltételeztük, hogy a körzetszám előtti összes kezdő karakter nem számjegy (<code>\D*</code>). Aargh.
</ol>
<p>Tegyünk egy lépést hátra. Eddig a reguláris kifejezések mind a karakterlánc elejétől illeszkedtek. De most már látod, hogy a karakterlánc elején meghatározhatatlan mennyiségű, figyelmen kívül hagyandó szöveg állhat. Ahelyett, hogy ezt mindet megpróbálnád illeszteni, hogy aztán átléphesd, próbálkozzunk egy másik megközelítéssel: egyáltalán ne illesszük a karakterlánc elejét. A következő példa ezt a megközelítést mutatja be.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta = re.compile(r'(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('work 1-(800) 555.1212 #1234').groups()</kbd>         <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212').groups()</kbd>                        <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('80055512121234').groups()</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp></pre>
<ol>
<li>Figyeld meg a <code>^</code> hiányát ebben a reguláris kifejezésben. Már nem illeszted a karakterlánc elejét. Semmi sem mondja, hogy a reguláris kifejezésednek a teljes bemenetre illeszkednie kell. A reguláris kifejezéseket kezelő alrendszer elvégzi a munka nehezét, meghatározza, hogy a beviteli karakterlánc hol kezd el illeszkedni, és onnan halad tovább.
<li>Most már sikeresen értelmezhetsz egy bevezető karaktereket és bevezető számjegyet, valamint a telefonszám egyes részei körül tetszőleges számú tetszőleges elválasztót tartalmazó telefonszámot.
<li>Épségellenőrzés. Ez továbbra is működik.
<li>Még ez is működik.
</ol>
<p>Látod, hogy a reguláris kifejezések milyen gyorsan tudnak kikerülni az ellenőrzés alól? Vess egy gyors pillantást az előző iterációk bármelyikére. Meg tudod mondani a különbséget az egyik és a következő között?
<p>Amíg még érted a végső választ (és ez a végső válasz, ha találtál egy olyan esetet, amit nem kezel, nem akarok róla tudni), írjuk ki részletes reguláris kifejezésként, mielőtt elfelejted a meghozott döntések okait.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>telefonMinta = re.compile(r'''
                # ne illessze a karakterlánc elejére, a szám bárhol elkezdődhet
    (\d{3})     # a körzetszám 3 számjegy (például: '800')
    \D*         # elhagyható elválasztó, ez tetszőleges számú nem számjegy lehet
    (\d{3})     # a törzs 3 számjegy (például: '555')
    \D*         # elhagyható elválasztó
    (\d{4})     # a szám többi része 4 számjegy (például: '1212')
    \D*         # elhagyható elválasztó
    (\d*)       # a mellék elhagyható és tetszőleges számú számjegy lehet
    $           # a karakterlánc vége
    ''', re.VERBOSE)</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('work 1-(800) 555.1212 #1234').groups()</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>telefonMinta.search('800-555-1212')</kbd>                          <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp></pre>
<ol>
<li>Attól eltekintve, hogy több sort foglal, ez pontosan ugyanaz a reguláris kifejezés, mint ami az utolsó lépésben volt, így nem meglepetés, hogy képes értelmezni ugyanazokat a bemeneteket.
<li>Végső épségellenőrzés. Igen, ez még mindig működik. Kész vagyunk.
</ol>
<p class=a>&#x2042;

<h2 id=summary>Összegzés</h2>
<p>Ez csak a reguláris kifejezések képességeit illusztráló jéghegy legapróbb csúcsa. Más szavakkal, noha mostanra már teljesen elborítottak a reguláris kifejezések, higgy nekem, még semmit sem láttál.
<p>Mostanra ismerned kell a következő kifejezéseket:
<ul>
<li>A <code>^</code> a karakterlánc elejére illeszkedik.
<li>A <code>$</code> a karakterlánc végére illeszkedik.
<li>A <code>\b</code> a szóhatárra illeszkedik.
<li>A <code>\d</code> bármely numerikus számjegyre illeszkedik.
<li>A <code>\D</code> bármely nem numerikus karakterre illeszkedik.
<li>Az <code>x?</code> egy elhagyható <code>x</code> karakterre illeszkedik (másszóval egy <code>x</code>-re nulla vagy egy alkalommal illeszkedik).
<li>Az <code>x*</code> az <code>x</code>-re nulla vagy több alkalommal illeszkedik.
<li>Az <code>x+</code> az <code>x</code>-re egy vagy több alkalommal illeszkedik.
<li>Az <code>x{n,m}</code> egy <code>x</code> karakterre legalább <code>n</code>, de nem több, mint <code>m</code> alkalommal illeszkedik.
<li>A <code>(a|b|c)</code> az <code>a</code>, <code>b</code> vagy <code>c</code> pontosan egyikére illeszkedik.
<li>Az <code>(x)</code> általánosságban egy <em>megjegyzett csoport</em>. Az illeszkedő értéket lekérheted a <code>re.search</code> által visszaadott objektum <code>groups()</code> metódusának segítségével.
</ul>
<p>A reguláris kifejezések nagyon hatékonyak, de nem jelentenek helyes megoldást minden problémára. Eleget kell tanulnod róluk, hogy tudd, mikor megfelelők, mikor oldják meg a problémáid és mikor okoznak több problémát, mint ahányat megoldanak.
<p class=v><a href=strings.html rel=prev title='vissza a &#8222;Karakterláncok&#8221; fejezetre'><span class=u>&#x261C;</span></a> <a href=generators.html rel=next title='előre a &#8222;Lezárások és generátorok&#8221; fejezetre'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
