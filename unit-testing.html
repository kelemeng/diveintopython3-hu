<!DOCTYPE html>
<meta charset=utf-8>
<title>Egységtesztelés - Ugorj fejest a Python 3-ba</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 9}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=root value=Search></div></form>
<p>Itt vagy: <a href=index.html>Kezdőlap</a> <span
class=u>&#8227;</span> <a href=table-of-contents.html#unit-testing>Ugorj fejest a Python 3-ba</a> <span class=u>&#8227;</span>
<p id=level>Nehézségi szint: <span class=u title=kezdő>&#x2666;&#x2666;&#x2662;&#x2662;&#x2662;</span>
<h1>Egységtesztelés</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> A bizonyosság nem egyenlő a bizonysággal. Rengeteg dologban voltunk halálosan biztosak, amelyek másképp voltak. <span class=u>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Oliver_Wendell_Holmes,_Jr.>Oliver Wendell Holmes, Jr.</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>(Ne) ugorj fejest</h2>
<p class=f>Ezek a mai fiatalok. Úgy elkényeztetik őket ezek a gyors számítógépek és az elegáns &#8222;dinamikus&#8221; nyelvek. Írd meg, add ki, keress hibákat (már ha egyáltalán). Az én időmben fegyelem volt. Mondom fegyelem! A programokat <em>kézzel</em> írtuk <em>papírra</em>, és a számítógépbe <em>lyukkártyákon</em> vittük be. És <em>szerettük!</em>

<p>Ebben a fejezetben római számokat oda-vissza átalakító segédfüggvényeket fogsz írni, és megkeresed a hibáikat. Az <a href=regular-expressions.html#romannumerals>&#8222;Esettanulmány: római számok&#8221;</a> fejezetben láttad a római számok összeállításának és ellenőrzésének működését. Most tegyél egy lépést hátra, és gondold át, mi kellene ennek kétirányú segédprogrammá fejlesztéséhez.
<p><a href=regular-expressions.html#romannumerals>A római számok szabályai</a> számos érdekes megfigyelésre vezetnek:
<ol>
<li>Egy adott számot pontosan egy módon lehet leírni római számként.
<li>Ennek fordítottja is igaz: ha egy karakterlánc érvényes római szám, akkor pontosan egy számot képvisel (azaz csak egyféleképpen értelmezhető).
<li>Római számként csak egy korlátozott tartomány írható le, azaz az <code>1</code> és <code>3999</code> közti számok. A rómaiak több módon is le tudtak írni nagyobb számokat, például a szám fölé húzott vonallal jelölték, hogy annak normális értékét meg kell szorozni <code>1000</code>-rel. Ezen fejezet szempontjából elég csak az <code>1</code> és <code>3999</code> közötti római számokkal foglalkozni.
<li>Római számokkal nem lehet kifejezni a 0-t.
<li>Római számokkal nem lehet kifejezni a negatív számokat.
<li>Római számokkal nem lehet kifejezni a tört vagy nem egész számokat.
</ol>
<p>Kezdjük el feltérképezni, mit kell egy <code>roman.py</code> modulnak csinálnia. Két fő függvénye lesz, a <code>to_roman()</code> és a <code>from_roman()</code>. A <code>to_roman()</code> függvény egy <code>1</code> és <code>3999</code> közti egészet vár, és visszaadja a római számokkal írt változatát karakterláncként&hellip;
<p>Itt álljunk meg. Csináljunk valami enyhén váratlant: írjunk egy tesztesetet, amely ellenőrzi, hogy a <code>to_roman()</code> függvény azt csinálja-e, amit vársz tőle. Jól olvastad: olyan kódot fogsz írni, amely a még meg sem írt kódodat teszteli.
<p>Ezt <i>tesztvezérelt fejlesztésnek</i> vagy <abbr>TDD</abbr>-nek hívják. A két átalakítási függvény&nbsp;&mdash;&nbsp;<code>to_roman()</code> és később a <code>from_roman()</code>&nbsp;&mdash;&nbsp;megírható és tesztelhető egy egységként, függetlenül bármely nagyobb programtól, amely importálja. A Python rendelkezik egy keretrendszerrel az egységteszteléshez, ezt a <code>unittest</code> modul tartalmazza.
<p>Az egységtesztelés a tesztközpontú fejlesztési stratégia fontos része. Ha egységteszteket írsz, akkor fontos azokat időben megírni, és a követelmények változásával együtt frissíteni. Sokan népszerűsítik a tesztek megírását a tesztelendő kód megírása előtt, és ezt a stílus mutatom be ebben a fejezetben. De az egységtesztek hasznosak, akármikor is írod meg azokat.
<ul>
<li>Az egységteszteknek a kód megírása előtti megírása a követelmények hasznos formában való részletezésére kényszerít.
<li>A kód írása közben az egységtesztek megakadályozzák, hogy túlkódolj. Amikor az összes teszteset lefut, a funkció kész van.
<li>A kód átdolgozásakor segíthetnek bebizonyítani, hogy az új verzió ugyanúgy viselkedik, mint a régi.
<li>Kód karbantartásakor a tesztek segítenek védeni magad, amikor valaki azzal jön ordítozva, hogy az utolsó változtatásod elrontotta az ő régi kódját. (&#8222;De <em>főnök</em>, minden egységteszt sikeres volt, amikor kommitoltam...&#8221;)
<li>Amikor csapatban írsz kódot, egy átfogó tesztcsomag drámaian csökkenti annak esélyét, hogy a kódod elrontja valaki más kódját, mert előtte lefuttathatod az ő egységtesztjeiket is. (Ezt kódolási sprinteken láttam. Egy csapat felosztja a kitűzött célt, mindenki fogja a feladatának specifikációját, egységteszteket ír hozzá, majd megosztja az egységtesztjeit a csapat többi tagjával. Így senki sem jut messzire az olyan kód fejlesztésével, amely nem működik együtt jól a többiek kódjával.)
</ul>
<p class=a>&#x2042;

<h2 id=romantest1>Egyetlen kérdés</h2>
<aside>Minden teszt egy sziget.</aside>
<p>Egy teszteset egyetlen kérdést válaszol meg az általa tesztelt kóddal kapcsolatban. Egy tesztesetnek képesnek kell lennie...
<ul>
<li>...teljesen önállóan futni, emberi adatbevitel nélkül. Az egységtesztelés az automatizálásról szól.
<li>...önállóan, az eredményeket értelmező ember nélkül meghatározni, hogy a tesztelt függvény működött-e vagy sem.
<li>...elkülönítve, bármely más tesztesettől függetlenül futni (még ha ugyanazokat a függvényeket is tesztelik). Minden teszteset egy sziget.
</ul>
<p>Ezeket figyelembe véve készítsünk egy tesztesetet az első követelményhez:
<ol>
<li>A <code>to_roman()</code> függvénynek vissza kell adnia az <code>1</code> és <code>3999</code> közti egészek római számokkal való ábrázolását.
</ol>
<p>Nem azonnal nyilvánvaló, hogy az alábbi kód hogyan is csinál&hellip; nos, <em>bármit</em>. Definiál egy osztályt, amelynek nincs <code>__init__()</code> metódusa. Az osztály <em>rendelkezik</em> egy másik metódussal, de az soha nem kerül meghívásra. A teljes parancsfájlnak van egy <code>__main__</code> blokkja, de az nem hivatkozik az osztályra vagy annak a metódusára. De valamit azért csinál, ígérem.
<p class=d>[<a href=examples/romantest1.py>a <code>romantest1.py</code> letöltése</a>]
<pre class=pp><code>import roman1
import unittest

<a>class KnownValues(unittest.TestCase):               <span class=u>&#x2460;</span></a>
    known_values = ( (1, 'I'),
                     (2, 'II'),
                     (3, 'III'),
                     (4, 'IV'),
                     (5, 'V'),
                     (6, 'VI'),
                     (7, 'VII'),
                     (8, 'VIII'),
                     (9, 'IX'),
                     (10, 'X'),
                     (50, 'L'),
                     (100, 'C'),
                     (500, 'D'),
                     (1000, 'M'),
                     (31, 'XXXI'),
                     (148, 'CXLVIII'),
                     (294, 'CCXCIV'),
                     (312, 'CCCXII'),
                     (421, 'CDXXI'),
                     (528, 'DXXVIII'),
                     (621, 'DCXXI'),
                     (782, 'DCCLXXXII'),
                     (870, 'DCCCLXX'),
                     (941, 'CMXLI'),
                     (1043, 'MXLIII'),
                     (1110, 'MCX'),
                     (1226, 'MCCXXVI'),
                     (1301, 'MCCCI'),
                     (1485, 'MCDLXXXV'),
                     (1509, 'MDIX'),
                     (1607, 'MDCVII'),
                     (1754, 'MDCCLIV'),
                     (1832, 'MDCCCXXXII'),
                     (1993, 'MCMXCIII'),
                     (2074, 'MMLXXIV'),
                     (2152, 'MMCLII'),
                     (2212, 'MMCCXII'),
                     (2343, 'MMCCCXLIII'),
                     (2499, 'MMCDXCIX'),
                     (2574, 'MMDLXXIV'),
                     (2646, 'MMDCXLVI'),
                     (2723, 'MMDCCXXIII'),
                     (2892, 'MMDCCCXCII'),
                     (2975, 'MMCMLXXV'),
                     (3051, 'MMMLI'),
                     (3185, 'MMMCLXXXV'),
                     (3250, 'MMMCCL'),
                     (3313, 'MMMCCCXIII'),
                     (3408, 'MMMCDVIII'),
                     (3501, 'MMMDI'),
                     (3610, 'MMMDCX'),
                     (3743, 'MMMDCCXLIII'),
                     (3844, 'MMMDCCCXLIV'),
                     (3888, 'MMMDCCCLXXXVIII'),
                     (3940, 'MMMCMXL'),
<a>                     (3999, 'MMMCMXCIX'))           <span class=u>&#x2461;</span></a>

<a>    def test_to_roman_known_values(self):           <span class=u>&#x2462;</span></a>
        '''a to_roman ismert eredményt kell adjon ismert bemenetre'''
        for integer, numeral in self.known_values:
<a>            result = roman1.to_roman(integer)       <span class=u>&#x2463;</span></a>
<a>            self.assertEqual(numeral, result)       <span class=u>&#x2464;</span></a>

if __name__ == '__main__':
    unittest.main()</code></pre>
<ol>
<li>Teszteset írásához először is származtass egy osztályt a <code>unittest</code> modul <code>TestCase</code> osztályából. Ez az osztály sok hasznos metódust biztosít, amelyeket a tesztesetedben adott helyzetek tesztelésére használhatsz.
<li>Ez olyan egész/római szám párok tuple-ja, amelyeket saját kezűleg ellenőriztem. Tartalmazza a tíz legkisebb számot, a legnagyobb számot, minden egy karakterből álló római számmal leírható számot, és néhány véletlenszerűen választott érvényes számot. Nem kell minden lehetséges bemenetet letesztelned, de meg kell próbálnod letesztelni az összes nyilvánvaló szélsőséges esetet.
<li>Minden egyes teszt a saját metódusa. A tesztmetódusnak nincsenek paraméterei, nem ad vissza értéket, és nevének a <code>test</code> szóval kell kezdődnie. Ha egy tesztmetódus normálisan lép ki, kivétel dobása nélkül, akkor sikeresnek tekintjük, ha kivételt dob, akkor sikertelennek.
<li>Itt hívod meg a tényleges <code>to_roman()</code> függvényt. (Illetve a függvény még nincs megírva, de ha meg lesz, akkor majd ez a sor fogja meghívni. Figyeld meg, hogy most definiáltad a <code>to_roman()</code> függvény <abbr>API</abbr>-ját: egy egész számot (az átalakítandó számot) vár, és egy karakterláncot ad vissza (a római számokkal való ábrázolást). Ha az <abbr>API</abbr> ettől eltér, akkor a teszt sikertelennek lesz tekintve. Figyeld meg azt is, hogy nem fogsz el kivételeket a <code>to_roman()</code> hívásakor. Ez szándékos. A <code>to_roman()</code> függvénynek nem kell kivételt dobnia, amikor érvényes bemenettel hívod, és ezek a bemeneti értékek mind érvényesek. Ha a <code>to_roman()</code> kivételt dob, akkor a teszt sikertelennek lesz tekintve.
<li>Feltételezve, hogy a <code>to_roman()</code> függvény helyesen lett definiálva, helyesen lett meghívva, sikeresen befejeződött, és visszaadott egy értéket, az utolsó lépés annak ellenőrzése, hogy a <em>helyes</em> értéket adta-e vissza. Ez egy gyakori kérdés, és a <code>TestCase</code> osztály biztosítja az <code>assertEqual</code> metódust, amely ellenőrzi, hogy a két érték egyenlő-e. Ha a <code>to_roman()</code> által visszaadott eredmény (<var>result</var>) nem egyezik a várt értékkel (<var>numeral</var>), akkor az <code>assertEqual</code> kivételt dob, és a teszt sikertelen lesz. Ha a két érték egyenlő, akkor az <code>assertEqual</code> nem csinál semmit. Ha a <code>to_roman()</code> által visszaadott összes érték egyezik a vár ismert értékkel, akkor az <code>assertEqual</code> soha nem dob kivételt, így a <code>test_to_roman_known_values</code> végül normálisan lép ki, azaz a <code>to_roman()</code> átment ezen a teszten.
</ol>
<aside>Írj egy sikertelen tesztet, majd kódolj, amíg át nem megy.</aside>
<p>Ha már van egy teszteseted, akkor elkezdheted a <code>to_roman()</code> függvény megírását. Először is egy üres csonkot kell létrehoznod, és meg kell győződnöd róla, hogy a tesztek nem sikerülnek. Ha a tesztek az előtt sikerülnek, hogy bármilyen kódot is írtál volna, akkor a tesztjeid egyáltalán nem tesztelik a kódod! Az egységtesztelés egy tánc: a tesztek vezetnek, a kód követi. Írj egy sikertelen tesztet, majd kódolj amíg nem sikerül.
<pre class=pp><code># roman1.py

def to_roman(n):
    '''egész szám római számmá alakítása'''
<a>    pass                                   <span class=u>&#x2460;</span></a></code></pre>
<ol>
<li>Ebben a lépésben definiálni kell a <code>to_roman()</code> függvény <abbr>API</abbr>-ját, de még nem kell megírni. (Először a tesztnek sikertelennek kell lennie. A csonk elkészítéséhez használd a Python <code>pass</code> foglalt szavát, amely semmit nem csinál.
</ol>
<p>Futtasd a <code>romantest1.py</code> fájlt a parancssorból a teszt futtatásához. Ha a <code>-v</code> parancssori kapcsolóval hívod, akkor részletesebb kimenetet ad, így pontosan láthatod, mi történik az egyes tesztesetek futtatásakor. Kis szerencsével a kimenet valahogy így fog kinézni:
<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest1.py -v</kbd>
<a><samp>test_to_roman_known_values (__main__.KnownValues)</samp>                      <span class=u>&#x2460;</span></a>
<a><samp>a to_roman ismert eredményt kell adjon ismert bemenetre ... FAIL</samp>            <span class=u>&#x2461;</span></a>
<samp>
======================================================================
FAIL: a to_roman ismert eredményt kell adjon ismert bemenetre
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest1.py", line 73, in test_to_roman_known_values
    self.assertEqual(numeral, result)
<a>AssertionError: 'I' != None                                            <span class=u>&#x2462;</span></a>

----------------------------------------------------------------------
<a>Ran 1 test in 0.016s                                                   <span class=u>&#x2463;</span></a>

<a>FAILED (failures=1)                                                    <span class=u>&#x2464;</span></a></samp></pre>
<ol>
<li>A parancsfájl futtatása a <code>unittest.main()</code> metódust futtatja, amely lefuttatja az egyes teszteseteket. Minden teszteset egy metódus a <code>romantest.py</code> egy osztályán belül. A tesztosztályokat nem kell rögzített módon szervezni: mindegyik tartalmazhat egy tesztmetódust vagy többet is. Az egyetlen követelmény, hogy minden egyes tesztosztálynak a <code>unittest.TestCase</code> osztályból kell származnia.
<li>Minden tesztesethez a <code>unittest</code> modul ki fogja írni a metódus <code>docstring-jét</code>, és hogy a teszt sikerült-e. Ahogy vártuk, ez a teszteset nem sikerült.
<li>Minden sikertelen tesztesethez a <code>unittest</code> megjeleníti a nyomkövetési információkat, amelyekből kiderül, hogy mi történt. Ebben az esetben az <code>assertEqual()</code> hívás <code>AssertionError</code> kivételt dobott, mert a <code>to_roman(1)</code> hívásnak az <code>'I'</code> értéket kellett volna visszaadnia, de nem ez történt. (Mivel nem volt megadva a return utasítás, a függvény a <code>None</code>-t, a Python null értékét adta vissza.)
<li>Az egyes tesztek részletei után a <code>unittest</code> összegzi, hogy hány tesztet hajtott végre, és ez mennyi ideig tartott.
<li>Összességében a teszt futtatása nem sikerült, mert legalább egy teszteset nem volt sikeres. Amikor egy teszteset nem sikeres, akkor a pass, <code>unittest</code> megkülönbözteti a sikertelenséget és a hibát. A sikertelenség egy <code>assertXYZ</code> metódus hívását jelenti, mint az <code>assertEqual</code> vagy <code>assertRaises</code>, amely azért sikertelen, mert a kijelentésben szereplő feltétel nem igaz, vagy a metódus nem dobott egy várt kivételt. A hiba egy tetszőleges típusú egyéb kivétel, amely a tesztelt kódban vagy magában az egységtesztesetben keletkezett.
</ol>
<p><em>Most</em>, végre megírhatod a <code>to_roman()</code> függvényt.
<p class=d>[<a href=examples/roman1.py>a <code>roman1.py</code> letöltése</a>]
<pre class=pp><code>roman_numeral_map = (('M',  1000),
                     ('CM', 900),
                     ('D',  500),
                     ('CD', 400),
                     ('C',  100),
                     ('XC', 90),
                     ('L',  50),
                     ('XL', 40),
                     ('X',  10),
                     ('IX', 9),
                     ('V',  5),
                     ('IV', 4),
<a>                     ('I',  1))                 <span class=u>&#x2460;</span></a>

def to_roman(n):
    '''egész szám római számmá alakítása'''
    result = ''
    for numeral, integer in roman_numeral_map:
<a>        while n >= integer:                     <span class=u>&#x2461;</span></a>
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>A <var>roman_numeral_map</var> egy tuple-ket tartalmazó tuple, amely három dolgot definiál: a legalapvetőbb római számok karakteres ábrázolását, a római számok sorrendjét (érték szerint csökkenő sorrendben <code>M</code>-től <code>I</code>-ig) és az egyes római számok értékét. Minden belső tuple egy <code>(<var>római szám</var>, <var>érték</var>)</code> pár. Nem csak az egy karakterből álló római számok, hanem két karakterből álló párokat is definiál, mint a  <code>CM</code> (&#8222;százzal kevesebb ezernél&#8221;). Ez egyszerűbbé teszi a <code>to_roman()</code> függvény kódját.
<li>Itt fizetődik ki a <var>roman_numeral_map</var> gazdag adatszerkezete, mert nem kell speciális szabály a kivonási szabály kezeléséhez. A római számokká alakításhoz csak lépkedj végig a <var>roman_numeral_map</var> tuple-n a bemenetnél kisebb vagy egyenlő legnagyobb értéket keresve. Ha megvan, add hozzá a római számos ábrázolását a kimenethez, és vond ki a megfelelő egész értéket a bemenetből, és ezt ismételgesd.
</ol>
<p>Ha még nem teljesen világos, hogyan működik a <code>to_roman()</code> függvény, akkor adj egy <code>print()</code> hívást a <code>while</code> ciklus végéhez:
<pre class='nd pp'><code>
while n >= integer:
    result += numeral
    n -= integer
    print('{0} kivonása a bemenetből, {1} hozzáadása a kimenethez'.format(integer, numeral))</code></pre>
<p>A hibakeresési <code>print()</code> utasításokkal a kimenet így néz ki:
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import roman1</kbd>
<samp class=p>>>> </samp><kbd class=pp>roman1.to_roman(1424)</kbd>
<samp>1000 kivonása a bemenetből, M hozzáadása a kimenethez
400 kivonása a bemenetből, CD hozzáadása a kimenethez
10 kivonása a bemenetből, X hozzáadása a kimenethez
10 kivonása a bemenetből, X hozzáadása a kimenethez
4 kivonása a bemenetből, IV hozzáadása a kimenethez
'MCDXXIV'</samp></pre>
<p>Így a <code>to_roman()</code> függvény működni látszik, legalábbis ezen a kézi ellenőrzésen átmegy. De átmegy az általad írt teszteseten is?
<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest1.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
<a>a to_roman ismert eredményt kell adjon ismert bemenetre ... ok               <span class=u>&#x2460;</span></a>

----------------------------------------------------------------------
Ran 1 test in 0.016s

OK</samp></pre>
<ol>
<li>Hurrá! A <code>to_roman()</code> függvény átmegy az &#8222;ismert értékek&#8221; teszteseten. Ez nem átfogó, de ráküldi a függvényt különböző bemenetekre, beleértve az összes egy karakteres római számot, a legnagyobb lehetséges értéket (<code>3999</code>), és a leghosszabb lehetséges római számot (<code>3888</code>) előállító bemeneteket. Ezen a ponton meglehetősen biztos lehetsz abban, hogy a függvény bármely jó bemenetre működik, amit csak meg tudsz neki adni.
</ol>
<p>&#8222;Jó&#8221; bemenet? Hmm. Mi van a rossz bemenettel?
<p class=a>&#x2042;

<h2 id=romantest2>&#8222;Állj meg, és dobj el mindent&#8221;</h2>
<aside>A megállás és mindent eldobás pythonos módja a kivételdobás.</aside>
<p>Nem elengendő azt tesztelni, hogy a függvények működnek-e jó bemenet megadása esetén; arról is meg kell győződnöd, hogy rossz bemenet esetén megszakítják a működésüket. Ráadásul nem &#8222;csak úgy&#8221; szakítják meg a működésüket, hanem úgy, ahogyan azt várod.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import roman1</kbd>
<samp class=p>>>> </samp><kbd class=pp>roman1.to_roman(4000)</kbd>
<samp class=pp>'MMMM'</samp>
<samp class=p>>>> </samp><kbd class=pp>roman1.to_roman(5000)</kbd>
<samp class=pp>'MMMMM'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>roman1.to_roman(9000)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>'MMMMMMMMM'</samp></pre>
<ol>
<li>Ez határozottan nem az, amit akartál&nbsp;&mdash;&nbsp;ez még csak nem is érvényes római szám! Valójában ezen számok mind kívül esnek az elfogadható bemenet tartományán, de a függvény így is visszaad egy hibás értéket. A hibás értékek szó nélküli visszaadása <em>rooooossz</em>; ha egy program futása sikertelen lesz, akkor jobb, ha ez gyorsan és zajosan következik be. &#8222;Állj meg, és dobj el mindent&#8221;, ahogy mondani szoktuk. A megállás és mindent eldobás pythonos módja a kivételdobás.</ol>
<p>A kérdés, amit fel kell tenned magadnak: &#8222;Hogyan fejezhetem ki ezt tesztelhető követelményként?&#8221; Kezdésnek mit szólnál ehhez:
<blockquote>
<p>A <code>to_roman()</code> függvénynek <code>OutOfRangeError</code> kivételt kell dobnia, ha a kapott egész szám nagyobb, mint <code>3999</code>.
</blockquote>
<p>Hogy nézne ki ez a teszt?
<p class=d>[<a href=examples/romantest2.py>a <code>romantest2.py</code> letöltése</a>]
<pre class=pp><code>import unittest, roman2
<a>class ToRomanBadInput(unittest.TestCase):                                 <span class=u>&#x2460;</span></a>
<a>    def test_too_large(self):                                             <span class=u>&#x2461;</span></a>
        '''a to_roman nem engedélyezhet túl nagy bemenetet'''
<a>        self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)  <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>Az előző tesztesethez hasonlóan a <code>unittest.TestCase</code>-ből származó osztályt kell létrehoznod. Osztályonként több tesztünk is lehet (ahogyan a fejezetben később látni fogod), de itt új osztály létrehozását választottam, mert ez a teszt jelentősen különbözik az előzőtől. A jó bemenet tesztjeit egy osztályban tartjuk, a rossz bemenet tesztjeit pedig egy másikban.
<li>Az előző tesztesethez hasonlóan a teszt maga az osztály egy metódusa, a neve pedig a <code>test</code> szóval kezdődik.
<li>A <code>unittest.TestCase</code> osztály biztosítja az <code>assertRaises</code> metódust, amely a következő argumentumokat várja: a várt kivétel, a tesztelt függvény, a függvénynek átadott argumentumok. (Ha a tesztelt függvény több argumentumot vár, akkor add át sorrendben az összeset az  <code>assertRaises</code> metódusnak, és az át fogja azokat adni a tesztelt függvénnyel együtt.)
</ol>
<p>Figyeld meg jól ezt az utolsó kódsort. A <code>to_roman()</code> közvetlen hívása és a bizonyos kivétel dobásának kézi ellenőrzése (egy <a href=your-first-python-program.html#exceptions><code>try...except</code> blokkba ágyazással</a>) helyett az <code>assertRaises</code> metódus ezt mind elvégezte nekünk. Mindössze a várt kivételt (<code>roman2.OutOfRangeError</code>), a függvényt (<code>to_roman()</code>) és a függvény argumentumait (<code>4000</code>) kell megnevezni. Az <code>assertRaises</code> metódus elvégzi a <code>to_roman()</code> hívását, és annak ellenőrzését, hogy az dobott-e<code>roman2.OutOfRangeError</code> kivételt.
<p>Vedd észre azt is, hogy a <code>to_roman()</code> függvényt magát argumentumként adod át, nem pedig meghívod, vagy karakterláncként adod át a nevét. Említettem korábban, hogy mennyire kézreálló, hogy <a href=your-first-python-program.html#everythingisanobject>Pythonban minden objektum</a>?
<p>Mi történik tehát, ha a tesztcsomagot ezzel az új teszttel együtt futtatod?
<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
a to_roman ismert eredményt kell adjon ismert bemenetre ... ok
test_too_large (__main__.ToRomanBadInput)
<a>a to_roman nem engedélyezhet túl nagy bemenetet ... ERROR                         <span class=u>&#x2460;</span></a>

======================================================================
ERROR: a to_roman nem engedélyezhet túl nagy bemenetet                          
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest2.py", line 78, in test_too_large
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
<a>AttributeError: 'module' object has no attribute 'OutOfRangeError'      <span class=u>&#x2461;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.000s

FAILED (errors=1)</samp></pre>
<ol>
<li>Számítanod kellett rá, hogy ez nem fog sikerülni, (mivel még nem írtál kódot, amely átmenne a teszten), de... ez nem &#8222;sikertelen&#8221; volt, hanem &#8222;hibát&#8221; adott. Ez egy apró, ám fontos különbség. Egy egységtesztnek valójában <em>három</em> visszatérési értéke van: sikeres, sikertelen és hiba. A sikeres természetesen azt jelenti, hogy átment a teszten&nbsp;&mdash;&nbsp;a kód azt csinálta, amit vártál. A &#8222;sikertelen&#8221; az, amilyen az előző teszteset volt (amíg nem írtad meg azt a kódot, ami átment)&nbsp;&mdash;&nbsp;a kód végre lett hajtva, de az eredmény nem az lett, amit vártál. A &#8222;hiba&#8221; azt jelenti, hogy a kód nem is hajtódott végre megfelelően.
<li>Miért nem hajtódott végre megfelelően a kód? A visszakövetés mindent elmond. A tesztelt modul nem rendelkezik <code>OutOfRangeError</code> nevű kivétellel. Emlékezz, ezt a kivételt átadtad az <code>assertRaises()</code> metódusnak, mert ez az a kivétel, amelyet a függvénnyel dobatni szeretnél, ha tartományon kívüli bemenetet kap. Azonban a kivétel nem létezik, így az <code>assertRaises()</code> metódus hívása nem sikerült. Soha nem volt lehetősége a <code>to_roman()</code> függvény tesztelésére, nem jutott el addig.
</ol>
<p>A probléma megoldásához definiálnod kell az <code>OutOfRangeError</code> kivételt a <code>roman2.py</code> fájlban.
<pre class=pp><code><a>class OutOfRangeError(ValueError):  <span class=u>&#x2460;</span></a>
<a>    pass                            <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>A kivételek osztályok. A &#8222;tartományon kívüli érték&#8221; hiba egy fajta értékhiba&nbsp;&mdash;&nbsp;az argumentum értéke kívül esik az elfogadható tartományon. Így ez a kivétel a beépített <code>ValueError</code> (értékhiba) kivételből származik. Ez nem kötelező (származhatna épp az alap <code>Exception</code> osztályból is), de helyesnek érződik.
<li>A kivételek valójában nem csinálnak semmit, de legalább egy sor kell ahhoz, hogy osztályként lehessen kezelni. A <code>pass</code> hívása egész pontosan semmit sem csinál, de ez egy sor Python kód, így megvan az osztály.
</ol>
<p>Most futtassuk újra a tesztcsomagot.
<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
a to_roman ismert eredményt kell adjon ismert bemenetre ... ok
test_too_large (__main__.ToRomanBadInput)
<a>a to_roman nem engedélyezhet túl nagy bemenetet ... FAIL                          <span class=u>&#x2460;</span></a>

======================================================================
FAIL: a to_roman nem engedélyezhet túl nagy bemenetet
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest2.py", line 78, in test_too_large
    self.assertRaises(roman2.OutOfRangeError, roman2.to_roman, 4000)
<a>AssertionError: OutOfRangeError not raised by to_roman                 <span class=u>&#x2461;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.016s

FAILED (failures=1)</samp></pre>
<ol>
<li>A teszt még mindig nem sikeres, de már nem is ad vissza hibát. Csak sikertelen, ez már haladás! Ez azt jelenti, hogy az <code>assertRaises()</code> metódus ez alkalommal sikeres volt, és az egységtesztelő keretrendszer ténylegesen tesztelte a <code>to_roman()</code> függvényt.
<li>Természetesen a <code>to_roman()</code> függvény még mindig nem dobja az imént definiált <code>OutOfRangeError</code> kivételt, mert még nem írtad meg az ehhez szükséges kódot. Kitűnő hír! Ez azt jelenti, hogy ez egy érvényes teszteset&nbsp;&mdash;&nbsp;sikertelen, mielőtt megírnád a kódot, amely átmegy rajta.
</ol>
<p>Itt az ideje megírni a kódot, amely átmegy a teszten.
<p class=d>[<a href=examples/roman2.py>a <code>roman2.py</code> letöltése</a>]
<pre class=pp><code>def to_roman(n):
    '''egész szám római számmá alakítása'''
    if n > 3999:
<a>        raise OutOfRangeError('a szám kívül esik a tartományon (4000-nél kisebb kell legyen)')  <span class=u>&#x2460;</span></a>

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>Ez magától értetődő: ha a megadott bemenet (<var>n</var>) nagyobb, mint <code>3999</code>, akkor dobjon <code>OutOfRangeError</code> kivételt. Az egységteszt nem ellenőrzi a kivételt kísérő, emberek által olvasható karakterláncot, noha írhatnál egy másik tesztet, amely ezt ellenőrzi (de figyelj oda a felhasználó nyelvétől vagy környezetétől függő karakterláncokkal kapcsolatos nemzetköziesítési problémákra).
</ol>
<p>Ettől vajon átmegy a teszt? Nézzük meg.
<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest2.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
a to_roman ismert eredményt kell adjon ismert bemenetre ... ok
test_too_large (__main__.ToRomanBadInput)
<a>a to_roman nem engedélyezhet túl nagy bemenetet ... ok                            <span class=u>&#x2460;</span></a>

----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK</samp></pre>
<ol>
<li>Hurrá! Mindkét teszt sikeres volt. Mivel iteratívan dolgoztál, a tesztelés és kódolás között váltogatva, biztos lehetsz abban, hogy az imént írt két sor kód miatt változott a teszt állapota &#8222;sikertelenről&#8221; &#8222;sikeresre&#8221;. Ez a fajta magabiztosság nem jön olcsón, de a kód élettartama során megtérül.
</ol>

<p class=a>&#x2042;

<h2 id=romantest3>Újabb megállás, újabb dobálás</h2>

<p>A túl nagy számok tesztelésével együtt tesztelned kell a túl kicsi számokat is. Amint a <a href=#divingin>funkcionális követelmények között megjegyeztük</a>, a római számokkal nem lehet a 0-t vagy negatív számokat kifejezni.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import roman2</kbd>
<samp class=p>>>> </samp><kbd class=pp>roman2.to_roman(0)</kbd>
<samp class=pp>''</samp>
<samp class=p>>>> </samp><kbd class=pp>roman2.to_roman(-1)</kbd>
<samp class=pp>''</samp></pre>

<p>Hát <em>ez</em> nem jó. Készítsünk teszteket ezen helyzetek mindegyikére.

<p class=d>[<a href=examples/romantest3.py>a <code>romantest3.py</code> letöltése</a>]
<pre class=pp><code>class ToRomanBadInput(unittest.TestCase):
    def test_too_large(self):
        '''a to_roman nem engedélyezhet túl nagy bemenetet'''
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 4000)  <span class=u>&#x2460;</span></a>

    def test_zero(self):
        '''a to_roman nem engedélyezheti a 0 bemenetet'''
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0)     <span class=u>&#x2461;</span></a>

    def test_negative(self):
        '''a to_roman nem engedélyezhet negatív bemenetet'''
<a>        self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1)    <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>A <code>test_too_large()</code> metódus nem változott az előző lépés óta. Csak azért van itt, hogy lásd, hova kerül az új kód.
<li>Itt egy új teszt: a <code>test_zero()</code> metódus. A <code>test_too_large()</code> metódushoz hasonlóan megadja az <code>unittest.TestCase</code> osztály <code>assertRaises()</code> metódusának, hogy hívja meg a <code>to_roman()</code> függvényt a 0 argumentummal, és ellenőrizze, hogy a megfelelő <code>OutOfRangeError</code> kivételt dobja-e.
<li>A <code>test_negative()</code> metódus majdnem azonos, kivéve hogy a <code>-1</code> értéket adja át a <code>to_roman()</code> függvénynek. Ha ezen új tesztek valamelyike <em>nem</em> dob <code>OutOfRangeError</code> kivételt (vagy mert a függvény egy tényleges értéket ad vissza, vagy mert valami más kivételt dob), akkor a teszt sikertelennek tekintendő.
</ol>

<p>Most ellenőrizzük, hogy a tesztek nem sikerülnek:

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest3.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
a to_roman ismert eredményt kell adjon ismert bemenetre ... ok
test_negative (__main__.ToRomanBadInput)
a to_roman nem engedélyezhet negatív bemenetet ... FAIL
test_too_large (__main__.ToRomanBadInput)
a to_roman nem engedélyezhet túl nagy bemenetet ... ok
test_zero (__main__.ToRomanBadInput)
a to_roman nem engedélyezheti a 0 bemenetet ... FAIL

======================================================================
FAIL: a to_roman nem engedélyezhet negatív bemenetet
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest3.py", line 86, in test_negative
    self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, -1)
AssertionError: OutOfRangeError not raised by to_roman

======================================================================
FAIL: a to_roman nem engedélyezheti a 0 bemenetet
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest3.py", line 82, in test_zero
    self.assertRaises(roman3.OutOfRangeError, roman3.to_roman, 0)
AssertionError: OutOfRangeError not raised by to_roman

----------------------------------------------------------------------
Ran 4 tests in 0.000s

FAILED (failures=2)</samp></pre>

<p>Kitűnő. Mindkét teszt sikertelen, ahogy vártuk. Most váltsunk át a kódra, és nézzük meg, hogy mit tehetünk azért, hogy sikerüljenek.

<p class=d>[<a href=examples/roman3.py>a <code>roman3.py</code> letöltése</a>]
<pre class=pp><code>def to_roman(n):
    '''egész szám római számmá alakítása'''
<a>    if not (0 &lt; n &lt; 4000):                                              <span class=u>&#x2460;</span></a>
<a>        raise OutOfRangeError('a szám kívül esik a tartományon (1 és 3999 közti kell legyen)')  <span class=u>&#x2461;</span></a>

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>Ez egy szép pythonos rövidítés: egyszerre több összehasonlítás. Ez egyenértékű a következővel: <code>if not ((0 &lt; n) and (n &lt; 4000))</code>, de sokkal olvashatóbb. Ennek a kódsornak meg kell fognia a túl nagy, negatív vagy nulla bemeneteket.
<li>Ha módosítod a feltételeket, akkor az emberek által olvasható hibaüzeneteket is ezeknek megfelelően módosítsd. A <code>unittest</code> keretrendszert nem érdekli, de megnehezíti a kézi hibakeresést, ha a kódod helytelenül leírt kivételeket dob.
</ol>

<p>Egész sor független példát hozhatnék arra, hogy a &#8222;több összehasonlítás egyszerre&#8221; rövidítés működik, de inkább csak lefuttatom az egységteszteket, és bebizonyítom.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest3.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
a to_roman ismert eredményt kell adjon ismert bemenetre ... ok
test_negative (__main__.ToRomanBadInput)
a to_roman nem engedélyezhet negatív bemenetet ... ok
test_too_large (__main__.ToRomanBadInput)
a to_roman nem engedélyezhet túl nagy bemenetet ... ok
test_zero (__main__.ToRomanBadInput)
a to_roman nem engedélyezheti a 0 bemenetet ... ok

----------------------------------------------------------------------
Ran 4 tests in 0.016s

OK</samp></pre>

<p class=a>&#x2042;

<h2 id=romantest4>És még egy dolog&hellip;</h2>

<p>Volt még egy <a href=#divingin>működési követelmény</a> a számok római számokká alakításához: a nem egész számok kezelése.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import roman3</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>roman3.to_roman(0.5)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>''</samp>
<a><samp class=p>>>> </samp><kbd class=pp>roman3.to_roman(1.0)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'I'</samp></pre>
<ol>
<li>Jaj, ez rossz.
<li>Jaj, ez még rosszabb. Mindkét esetnek kivételt kellene dobnia. Ehelyett hibás eredményeket adnak.
</ol>

<p>A nem egész számok tesztelése nem nehéz. Először egy <code>NotIntegerError</code> kivételt kell definiálni.

<pre class='nd pp'><code># roman4.py
class OutOfRangeError(ValueError): pass
<mark>class NotIntegerError(ValueError): pass</mark></code></pre>

<p>Ezután írjunk egy tesztesetet, amely a <code>NotIntegerError</code> kivételt ellenőrzi.

<pre class='nd pp'><code>class ToRomanBadInput(unittest.TestCase):
    .
    .
    .
    def test_non_integer(self):
        '''a to_roman nem engedélyezhet nem egész bemenetet'''
<mark>        self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)</mark></code></pre>

<p>Most lássuk, hogy a teszt nem sikerül-e, ahogy azt várnánk.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest4.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
a to_roman ismert eredményt kell adjon ismert bemenetre ... ok
test_negative (__main__.ToRomanBadInput)
a to_roman nem engedélyezhet negatív bemenetet ... ok
test_non_integer (__main__.ToRomanBadInput)
a to_roman nem engedélyezhet nem egész bemenetet ... FAIL
test_too_large (__main__.ToRomanBadInput)
a to_roman nem engedélyezhet túl nagy bemenetet ... ok
test_zero (__main__.ToRomanBadInput)
a to_roman nem engedélyezheti a 0 bemenetet ... ok

======================================================================
FAIL: a to_roman nem engedélyezhet nem egész bemenetet
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest4.py", line 90, in test_non_integer
    self.assertRaises(roman4.NotIntegerError, roman4.to_roman, 0.5)
<mark>AssertionError: NotIntegerError not raised by to_roman</mark>

----------------------------------------------------------------------
Ran 5 tests in 0.000s

FAILED (failures=1)</samp></pre>

<p>Írjuk meg a kódot, amelynek hatására a teszt sikerülni fog.

<pre class=pp><code>def to_roman(n):
    '''egész szám római számmá alakítása'''
    if not (0 &lt; n &lt; 4000):
        raise OutOfRangeError('a szám kívül esik a tartományon (1 és 3999 közti kell legyen)')
<a>    if not isinstance(n, int):                                          <span class=u>&#x2460;</span></a>
<a>        raise NotIntegerError('a nem egész számok nem alakíthatók át')      <span class=u>&#x2461;</span></a>

    result = ''
    for numeral, integer in roman_numeral_map:
        while n >= integer:
            result += numeral
            n -= integer
    return result</code></pre>
<ol>
<li>A beépített <code>isinstance()</code> függvény teszteli, hogy egy változó adott típusú-e (technikailag: bármely leszármazott típusú-e).
<li>Ha az <var>n</var> argumentum nem <code>int</code>, akkor az újonnan készített <code>NotIntegerError</code> kivételt dobja.
</ol>

<p>Végül ellenőrizzük, hogy a kód tényleg átmegy-e a teszten.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest4.py -v</kbd>
<samp>test_to_roman_known_values (__main__.KnownValues)
a to_roman ismert eredményt kell adjon ismert bemenetre ... ok
test_negative (__main__.ToRomanBadInput)
a to_roman nem engedélyezhet negatív bemenetet ... ok
test_non_integer (__main__.ToRomanBadInput)
a to_roman nem engedélyezhet nem egész bemenetet ... ok
test_too_large (__main__.ToRomanBadInput)
a to_roman nem engedélyezhet túl nagy bemenetet ... ok
test_zero (__main__.ToRomanBadInput)
a to_roman nem engedélyezheti a 0 bemenetet ... ok

----------------------------------------------------------------------
Ran 5 tests in 0.000s

OK</samp></pre>

<p>A <code>to_roman()</code> függvény átmegy az összes tesztjén, és nem tudok kitalálni több tesztet, úgyhogy ideje a <code>from_roman()</code> függvénnyel folytatni.

<p class=a>&#x2042;

<h2 id=romantest5>Egy kellemes szimmetria</h2>

<p>Egy karakterlánc római számból egészszé alakítása nehezebbnek hangzik, mint egy egész átalakítása római számmá. Minden bizonnyal itt van az ellenőrzés problémája. Egyszerű azt ellenőrizni, hogy egy egész nagyobb-e, mint 0, de egy kicsit nehezebb azt ellenőrizni, hogy egy karakterlánc érvényes római szám-e. Azonban már összeállítottunk egy <a href=regular-expressions.html#romannumerals>reguláris kifejezést, amely a római számokat ellenőrzi</a>, így ez a rész kész van.
<p>Emiatt már csak a karakterlánc átalakításának problémáját kell megoldani. Ahogy egy perc múlva látni fogjuk, az egyes római számok egész értékekre való leképezéséhez definiált gazdag adatszerkezetnek köszönhetően, a <code>from_roman()</code> függvény igazán kemény része ugyanolyan magától értetődő, mint a <code>to_roman()</code> függvényé.
<p>De előbb a tesztek. Szükségünk lesz egy &#8222;ismert értékek&#8221; tesztre a pontosság azonnali ellenőrzéséhez. A tesztcsomagunk már tartalmazza <a href=#romantest1>ismert értékek leképezését</a>; használjuk újra azt.

<pre class='nd pp'><code>    def test_from_roman_known_values(self):
        '''a from_roman ismert eredményt kell adjon ismert bemenetre'''
        for integer, numeral in self.known_values:
            result = roman5.from_roman(numeral)
            self.assertEqual(integer, result)</code></pre>

<p>Van itt egy kellemes szimmetria. A <code>to_roman()</code> és a <code>from_roman()</code> függvények egymás inverzei. Az első egészeket alakít át speciálisan formázott karakterláncokká, a második speciálisan formázott karakterláncokat alakít egészekké. Elméletben képesnek kellene lennünk egy szám &#8222;körbejárására&#8221;: a <code>to_roman()</code> függvénynek átadva kapott karakterláncot átadva a <code>from_roman()</code> függvénynek ugyanazt az egész számot kellene visszakapnunk.

<pre class='nd pp'><code>n = from_roman(to_roman(n)) az n minden értékére</code></pre>

<p>Ebben az esetben a &#8222;minden érték&#8221; az <code>1 és 3999</code> közti tetszőleges számot jelent, mert ez a <code>to_roman()</code> függvény érvényes bemeneti tartománya. Ezt a szimmetriát kifejezhetjük egy olyan tesztesettel, amely végigfut az összes értéken <code>1..3999</code> között, meghívja a <code>to_roman()</code>, majd a <code>from_roman()</code> függvényt, és ellenőrzi, hogy a kimenet ugyanaz-e, mint az eredeti bemenet.
<pre class='nd pp'><code>class RoundtripCheck(unittest.TestCase):
    def test_roundtrip(self):
        '''from_roman(to_roman(n))==n minden n-re'''
        for integer in range(1, 4000):
            numeral = roman5.to_roman(integer)
            result = roman5.from_roman(numeral)
            self.assertEqual(integer, result)</code></pre>

<p>Ezek az új tesztek sikertelenek sem lesznek. Még egyáltalán nem definiáltunk <code>from_roman()</code> nevű függvényt, így eredményül csupán hibákat kapunk.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest5.py</kbd>
<samp>E.E....
======================================================================
ERROR: test_from_roman_known_values (__main__.KnownValues)
a from_roman ismert eredményt kell adjon ismert bemenetre
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest5.py", line 78, in test_from_roman_known_values
    result = roman5.from_roman(numeral)
AttributeError: 'module' object has no attribute 'from_roman'

======================================================================
ERROR: test_roundtrip (__main__.RoundtripCheck)
from_roman(to_roman(n))==n minden n-re
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest5.py", line 103, in test_roundtrip
    result = roman5.from_roman(numeral)
AttributeError: 'module' object has no attribute 'from_roman'

----------------------------------------------------------------------
Ran 7 tests in 0.019s

FAILED (errors=2)</samp></pre>

<p>Egy gyors függvénycsonk megoldja ezt a problémát.

<pre class='nd pp'><code># roman5.py
def from_roman(s):
    '''római számok egésszé alakítása'''</code></pre>

<p>(Hé, figyeled ezt? Egy olyan függvényt definiáltam, amely nem tartalmaz semmit, csak egy <a href=your-first-python-program.html#docstrings>docstringet</a>. Ez érvényes Python. Tulajdonképpen néhány programozó esküszik rá. &#8222;Ne csonkolj, dokumentálj!&#8221;)
<p>Most a tesztesetek ténylegesen sikertelenek lesznek.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest5.py</kbd>
<samp>F.F....
======================================================================
FAIL: test_from_roman_known_values (__main__.KnownValues)
a from_roman ismert eredményt kell adjon ismert bemenetre
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest5.py", line 79, in test_from_roman_known_values
    self.assertEqual(integer, result)
AssertionError: 1 != None

======================================================================
FAIL: test_roundtrip (__main__.RoundtripCheck)
from_roman(to_roman(n))==n minden n-re
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest5.py", line 104, in test_roundtrip
    self.assertEqual(integer, result)
AssertionError: 1 != None

----------------------------------------------------------------------
Ran 7 tests in 0.002s

FAILED (failures=2)</samp></pre>

<p>Most ideje megírni a <code>from_roman()</code> függvényt.

<pre class=pp><code>def from_roman(s):
    """római számok egésszé alakítása"""
    result = 0
    index = 0
    for numeral, integer in roman_numeral_map:
<a>        while s[index:index+len(numeral)] == numeral:  <span class=u>&#x2460;</span></a>
            result += integer
            index += len(numeral)
    return result</code></pre>
<ol>
<li>Itt a minta ugyanaz, mint a <a href=#romantest1><code>to_roman()</code></a> függvénynél. Végiglépkedsz a római számok adatszerkezetén (tuple-k tuple-je), de a legmagasabb értékek lehető leggyakoribb illesztése helyett a &#8222;legmagasabb&#8221; értékű római számot képviselő karakterláncot illeszted olyan gyakran, amennyire csak lehetséges.
</ol>

<p>Ha nem teljesen világos, hogyan működik a <code>from_roman()</code>, akkor adj egy <code>print</code> utasítást a <code>while</code> ciklus végéhez:
<pre><code>def from_roman(s):
    """római számok egésszé alakítása"""
    result = 0
    index = 0
    for numeral, integer in roman_numeral_map:
        while s[index:index+len(numeral)] == numeral:
            result += integer
            index += len(numeral)
<mark>            print('Megtalálva:', numeral, 'hossza:', len(numeral), ', hozzáadva:', integer)</mark></code></pre>

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import roman5</kbd>
<samp class=p>>>> </samp><kbd class=pp>roman5.from_roman('MCMLXXII')</kbd>
<samp class=pp>Megtalálva: M hossza: 1, hozzáadva: 1000
Megtalálva: CM hossza: 2, hozzáadva: 900
Megtalálva: L hossza: 1, hozzáadva: 50
Megtalálva: X hossza: 1, hozzáadva: 10
Megtalálva: X hossza: 1, hozzáadva: 10
Megtalálva: I hossza: 1, hozzáadva: 1
Megtalálva: I hossza: 1, hozzáadva: 1
1972</samp></pre>

<p>Ideje újrafuttatni a teszteket.

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest5.py</kbd>
<samp>.......
----------------------------------------------------------------------
Ran 7 tests in 0.060s

OK</samp></pre>

<p>Két izgalmas hír van itt. Az első, hogy a <code>from_roman()</code> függvény jó bemenet esetén működik, legalábbis az összes <a href=#romantest1>ismert érték</a> esetén. A második, hogy a &#8222;körbejárás&#8221; teszt is sikeres volt. Az ismert értékek teszttel kombinálva meglehetősen biztos lehetsz abban, hogy mind a <code>to_roman()</code>, mind a <code>from_roman()</code> függvény megfelelően működik az összes lehetséges jó értékre. (Erre nincs garancia, elméletileg előfordulhat, hogy a <code>to_roman()</code> olyan programhibát tartalmaz, amely hibás római számokat állít elő bemenetek bizonyos halmazához, <em>és</em> hogy a <code>from_roman()</code> olyan inverz programhibát tartalmaz, amely ugyanezeket a hibás egész értékeket állítja elő pontosan ugyanazon római számok halmazához, mint amelyeket a <code>to_roman()</code> helytelenül állított elő. Az alkalmazástól és a követelményektől függően ez a lehetőség gondot okozhat, ebben az esetben írj átfogóbb teszteseteket, amíg a probléma meg nem szűnik. 

<p class=a>&#x2042;

<h2 id=romantest6>Még több rossz bemenet</h2>

<p>Most hogy a <code>from_roman()</code> függvény megfelelően működik jó bemenet esetén, ideje helyére illeszteni a kirakós utolsó darabját: tegyük megfelelően működővé rossz bemenettel is. Ehhez olyan módszert kell találnunk, amellyel egy karakterláncról ránézésre megállapítható, hogy érvényes római számok-e. Ez eredendően nehezebb, mint a <a href=#romantest3>numerikus bemenet ellenőrzése</a> a <code>to_roman()</code> függvényben, de rendelkezésedre áll egy hatékony eszköz: a reguláris kifejezések. (Ha nem ismered a reguláris kifejezéseket, akkor itt az ideje elolvasni a <a href=regular-expressions.html>reguláris kifejezések fejezetet</a>.)

<p>Amint az <a href=regular-expressions.html#romannumerals>Esettanulmány: római számok</a> fejezetben láthattad, néhány egyszerű szabály vonatkozik a római számok előállítására az <code>M</code>, <code>D</code>, <code>C</code>, <code>L</code>, <code>X</code>, <code>V</code> és <code>I</code> betűk használatával. Tekintsük át a szabályokat:
<ul>
<li>Néha a karakterek összeadódnak. Az <code>I</code> = <code>1</code>, az <code>II</code> = <code>2</code> és az <code>III</code> = <code>3</code>. A <code>VI</code> = <code>6</code> (szó szerint &#8222;<code>5</code> és <code>1</code>&#8221;), a <code>VII</code> = <code>7</code> és a <code>VIII</code> = <code>8</code>.
<li>A tizes karakterek (<code>I</code>, <code>X</code>, <code>C</code> és <code>M</code>) legfeljebb háromszor ismételhetők. A <code>4</code> esetén azt a következő ötös karakterből kell kivonnod. A <code>4</code> nem ábrázolható <code>IIII</code>-ként; ehelyett a <code>IV</code> használatos(&#8222;<code>1</code>-gyel kisebb, mint <code>5</code>&#8221;). A <code>40</code> = <code>XL</code> (&#8222;<code>10</code>-zel kevesebb, mint <code>50</code>&#8221;), <code>41</code> = <code>XLI</code>, <code>42</code> = <code>XLII</code>, <code>43</code> = <code>XLIII</code> és a <code>44</code> = <code>XLIV</code> (&#8222;<code>10</code>-zel kevesebb, mint <code>50</code>, és <code>1</code>-gyel kevesebb, mint <code>5</code>&#8221;).
<li>Néha a karakterek&hellip; az összeadással ellentétesen viselkednek. Bizonyos karaktereket mások elé helyezve azokat kivonod a végső értékből. A <code>9</code> esetén például a tőle nagyobb legelső tizes karakterből kell kivonnod: a <code>8</code> = <code>VIII</code>, de a <code>9</code> = <code>IX</code> (&#8222;<code>1</code>-gyel kevesebb, mint <code>10</code>&#8221;), nem <code>VIIII</code> (mivel az <code>I</code> karakter nem ismételhető négyszer). A <code>90</code> = <code>XC</code>, a <code>900</code> = <code>CM</code>.
<li>Az ötös karakterek nem ismételhetők. A <code>10</code> mindig <code>X</code>-ként van ábrázolva, soha nem <code>VV</code>-ként. A <code>100</code> mindig <code>C</code>, soha nem <code>LL</code>.
<li>A római számok balról jobbra olvasandók, így a rendezések sorrendje nagyon sokat számít. A <code>DC</code> = <code>600</code>; a <code>CD</code> egy teljesen különböző szám (<code>400</code>, &#8222;<code>100</code>-zal kevesebb, mint <code>500</code>&#8221;). A <code>CI</code> = <code>101</code>; az <code>IC</code> nem is érvényes római szám (mert nem vonhatsz ki <code>1</code>-et közvetlenül a <code>100</code>-ból; 99 =<code>XCIX</code>, &#8222;<code>10</code>-zel kisebb, mint <code>100</code>, majd <code>1</code>-gyel kisebb, mint <code>10</code>&#8221;).
</ul>

<p>Emiatt egy hasznos tesztnek biztosítania kell, hogy a <code>from_roman()</code> függvény nem fut le, ha egy túl sok ismétlődő karaktert tartalmazó karakterláncot kap. Hogy mennyi a &#8222;túl sok&#8221;, az a római számtól függ.

<pre class='nd pp'><code>class FromRomanBadInput(unittest.TestCase):
    def test_too_many_repeated_numerals(self):
        '''a from_roman nem engedélyezhet túl sok ismétlődő karaktert'''
        for s in ('MMMM', 'DD', 'CCCC', 'LL', 'XXXX', 'VV', 'IIII'):
            self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)</code></pre>

<p>Egy másik hasznos teszt lehet annak ellenőrzése, hogy bizonyos minták nem ismétlődnek. Az <code>IX</code> például <code>9</code>, de az <code>IXIX</code> soha nem érvényes.

<pre class='nd pp'><code>    def test_repeated_pairs(self):
        '''a from_roman nem engedélyezhet ismétlődő számpárokat'''
        for s in ('CMCM', 'CDCD', 'XCXC', 'XLXL', 'IXIX', 'IVIV'):
            self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)</code></pre>

<p>Egy harmadik teszt ellenőrizhetné, hogy a római számjegyek a helyes sorrendben jelennek-e meg, a legmagasabbtól a legalacsonyabb értékig. A <code>CL</code> például <code>150</code>, de az <code>LC</code> soha nem érvényes, mert az <code>50</code>-nek megfelelő karakter soha nem állhat a <code>100</code>-nak megfelelő előtt. Ez a teszt tartalmazza érvénytelen előtagok véletlenül kiválasztott halmazát: <code>I</code> az <code>M</code> előtt, <code>V</code> az <code>X</code> előtt, stb.

<pre class='nd pp'><code>    def test_malformed_antecedents(self):
        '''a from_roman nem engedélyezhet rosszul formázott előtagokat'''
        for s in ('IIMXCC', 'VX', 'DCM', 'CMM', 'IXIV',
                  'MCMC', 'XCX', 'IVI', 'LM', 'LD', 'LC'):
            self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)</code></pre>

<p>Ezen tesztek mindegyike arra épül, hogy a <code>from_roman()</code> függvény egy új, <code>InvalidRomanNumeralError</code> kivételt dob, ezt azonban még nem definiáltuk.

<pre class='nd pp'><code># roman6.py
class InvalidRomanNumeralError(ValueError): pass</code></pre>

<p>A három teszt egyike sem lehet sikeres, mert a <code>from_roman()</code> függvény még egyáltalán nem tartalmaz érvényesség-ellenőrzést. (Ha sikeresek lennének, akkor mi a fenét tesztelnének?) 

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest6.py</kbd>
<samp>FFF.......
======================================================================
FAIL: test_malformed_antecedents (__main__.FromRomanBadInput)
a from_roman nem engedélyezhet rosszul formázott előtagokat
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest6.py", line 113, in test_malformed_antecedents
    self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman

======================================================================
FAIL: test_repeated_pairs (__main__.FromRomanBadInput)
a from_roman nem engedélyezhet ismétlődő számpárokat
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest6.py", line 107, in test_repeated_pairs
    self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman

======================================================================
FAIL: test_too_many_repeated_numerals (__main__.FromRomanBadInput)
a from_roman nem engedélyezhet túl sok ismétlődő karaktert
----------------------------------------------------------------------
Traceback (most recent call last):
  File "romantest6.py", line 102, in test_too_many_repeated_numerals
    self.assertRaises(roman6.InvalidRomanNumeralError, roman6.from_roman, s)
AssertionError: InvalidRomanNumeralError not raised by from_roman

----------------------------------------------------------------------
Ran 10 tests in 0.058s

FAILED (failures=3)</samp></pre>

<p>Jókora adag. Most csak annyit kell tennünk, hogy a <a href=regular-expressions.html#romannumerals>római számok érvényességét tesztelő reguláris kifejezést</a> hozzáadjuk a <code>from_roman()</code> függvényhez.
<pre class='nd pp'>roman_numeral_pattern = re.compile('''
    ^                   # karakterlánc eleje
    M{0,3}              # ezresek - 0 és 3 közti M
    (CM|CD|D?C{0,3})    # százasok - 900 (CM), 400 (CD), 0-300 (0 és 3 közti C),
                        #            vagy 500-800 (D, amelyet 0 és 3 közti C követ)
    (XC|XL|L?X{0,3})    # tizesek - 90 (XC), 40 (XL), 0-30 (0 és 3 közti X),
                        #        vagy 50-80 (L, amelyet 0 és 3 közti X követ)
    (IX|IV|V?I{0,3})    # egyesek - 9 (IX), 4 (IV), 0-3 (0 és 3 közti I),
                        #        vagy 5-8 (V, amelyet 0 és 3 közti I követ)
    $                   # karakterlánc vége
    '''def from_roman(s):
    '''római számok egésszé alakítása'''
<mark>    if not roman_numeral_pattern.search(s):
        raise InvalidRomanNumeralError('Érvénytelen római szám: {0}'.format(s))</mark>

    result = 0
    index = 0
    for numeral, integer in roman_numeral_map:
        while s[index : index + len(numeral)] == numeral:
            result += integer
            index += len(numeral)
    return result</code></pre>

<p>És futtasd újra a teszteket&hellip;

<pre class='nd screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3/examples$ </samp><kbd>python3 romantest7.py</kbd>
<samp>..........
----------------------------------------------------------------------
Ran 10 tests in 0.066s

OK</samp></pre>

<p>Az év ellencsúcspontja díjat pedig&hellip; az &#8222;<code>OK</code>&#8221; szó kapja, amelyet a <code>unittest</code> modul ír ki, ha az összes teszt sikerül.

<p class=v><a href=advanced-iterators.html rel=prev title='vissza a &#8222;Speciális iterátorokra&#8221;'><span class=u>&#x261C;</span></a> <a href=refactoring.html rel=next title='előre az &#8222;Átdolgozásra&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
