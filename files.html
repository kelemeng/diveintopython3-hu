<!DOCTYPE html>
<meta charset=utf-8>
<title>Fájlok - Ugorj fejest a Python 3-ba</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 11}
mark{display:inline}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Itt vagy: <a href=index.html>Kezdőlap</a> <span
class=u>&#8227;</span> <a href=table-of-contents.html#files>Ugorj fejest a Python 3-ba</a> <span class=u>&#8227;</span>
<p id=level>Nehézségi szint: <span class=u title=közepes>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Fájlok</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Egy kilenc mérföldes séta nem vicc, különösen nem az esőben. <span class=u>&#x275E;</span><br>&ndash; Harry Kemelman, <cite>The Nine Mile Walk</cite>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Ugorj fejest</h2>
<p class=f>A windowsos laptopomon 38 493 fájl volt, mielőtt egyetlen alkalmazást is telepítettem volna. A Python 3 telepítése majdnem 3 000 fájlt adott ehhez a számhoz. A fájlok minden jelentős operációs rendszer elsődleges tárolási paradigmáját jelentik, a fogalom annyira be van égve, hogy egyeseknek gondot okoz elképzelni <a href=http://en.wikipedia.org/wiki/Computer_file#History>az alternatívákat</a>. A számítógéped képletesen szólva fuldoklik a fájlokban.

<h2 id=reading>Olvasás szövegfájlokból</h2>

<p>Mielőtt olvashatnál egy fájlból, meg kell azt nyitnod. A fájlok Pythonból való megnyitása nem is lehetne egyszerűbb:

<pre class='nd pp'><code>egy_fájl = open('examples/chinese.txt', encoding='utf-8')</code></pre>

<p>A Python rendelkezik egy beépített <code>open()</code> függvénnyel, amely egy fájlnevet vár argumentumként. A fájlnév itt az <code class=pp>'examples/chinese.txt'</code>. A fájlnévvel kapcsolatban öt édekességet figyelhetünk meg:

<ol>
<li>Nem egyszerűen egy fájl neve, hanem egy könyvtárútvonal és egy fájlnév kombinációja. Egy elméletben elképzelhető fájlmegnyitó függvény várhatna két argumentumot&nbsp;&ndash;&nbsp;egy könyvtárútvonalat és egy fájlnevet&nbsp;&ndash;&nbsp;de az <code>open()</code> függvény csak egyet vár. A Pythonban amikor egy &#8222;fájlnévre&#8221; van szükség, megadhatod egy könyvtárútvonal egy részét vagy egészét is.
<li>A könyvtárútvonal normál osztásjelet használ, de nem mondtam meg, melyik operációs rendszert használom. A Windows fordított osztásjelet használ az alkönyvtárak jelzésére, míg a Mac OS X és a Linux normál osztásjelet. De Pythonban a normál osztásjelek Csak Működnek(TM), még Windows alatt is.
<li>A könyvtárútvonal nem osztásjellel vagy meghajtó betűjellel kezdődik, így a <i>relatív útvonalnak</i> nevezzük. Relatív? Mihez képest? Türelem, prücsök.
<li>Ez egy karakterlánc. Minden korszerű operációs rendszer (még a Windows is!) Unicode-ot használ a fájlok és könyvtárak neveinek tárolására. A Python 3 teljesen támogatja a nem <abbr>ASCII</abbr> útvonalneveket.
<li>Nem kell a helyi lemezeden lennie. Lehet egy csatolt hálózati meghajtón is. A &#8222;fájl&#8221; lehet, hogy csak egy <a href=http://en.wikipedia.org/wiki/Filesystem_in_Userspace>teljesen virtuális fájlrendszer</a> képzeletében létezik. Ha a számítógéped fájlnak tekinti, és el tudja érni fájlként, akkor a Python meg tudja nyitni.
</ol>

<p>Azonban az <code>open()</code> függvény hívása nem állt meg a fájlnévnél. Van még egy argumentum, amelynek neve <code>encoding</code> (kódolás). Jaj ne, <a href=strings.html#boring-stuff>ez félelmetesen ismerősen hangzik</a>.

<h3 id=encoding>A karakterkódolás kidugja ronda fejét</h3>

<p>A bájtok bájtok, a <a href=strings.html#byte-arrays>karakterek absztrakciók</a>. A karakterlánc Unicode karakterek sorozata. De egy lemezen lévő fájl nem Unicode karakterek sorozata, a lemezen lévő fájl bájtok sorozata. De hogyan konvertálja a Python a bájtsorozatot karakterek sorozatává, amikor beolvasol egy &#8222;szövegfájlt&#8221; a lemezről? A bájtokat egy adott karakterkódolási algoritmus szerint dekódolja, és visszaadja Unicode karakterek egy sorozatát (más néven egy karakterláncot).

<pre>
# Ez a példa Windowson készült. Más operációs rendszerek
# másképp viselkedhetnek, a lentebb vázolt okokból.
<samp class=p>>>> </samp><kbd class=pp>fájl = open('examples/chinese.txt')</kbd>
<samp class=p>>>> </samp><kbd class=pp>egy_karakterlánc = fájl.read()</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "C:\Python31\lib\encodings\cp1252.py", line 23, in decode
    return codecs.charmap_decode(input,self.errors,decoding_table)[0]
UnicodeDecodeError: 'charmap' codec can't decode byte 0x8f in position 28: character maps to &lt;undefined></samp>
<samp class=p>>>> </samp></pre>

<aside>Az alapértelmezett kódolás platformfüggő.</aside>

<p>Mi történt? Nem adtál meg karakterkódolást, így a Pythonnak az alapértelmezett kódolást kell használnia. Mi az alapértelmezett kódolás? Ha alaposan megnézed a nyomkövetést, láthatod, hogy a <code>cp1252.py</code> fájlban keletkezik a kivétel, vagyis a Python alapértelmezett kódolása itt a CP-1252. (A CP-1252 egy gyakori kódolás a Microsoft Windowst futtató számítógépeken.) A CP-1252 karakterkészlet nem támogatja a fájlban lévő karaktereket, így az olvasás egy ronda <code>UnicodeDecodeError</code> kivétellel meghiúsul.

<p>De várj, a helyzet ennél is rosszabb! Az alapértelmezett kódolás <em>platformfüggő</em>, így ez a kód akár <em>működhet</em> is a számítógépeden (ha az alapértelmezett kódolásod <abbr>UTF-8</abbr>), de hibát okoz, ha odaadod valaki másnak (akinek az alapértelmezett kódolása eltérő, mint például a CP-1252).

<blockquote class=note>
<p><span class=u>&#x261E;</span>Ha meg szeretnéd kapni az alapértelmezett karakterkódolást, akkor importáld a <code>locale</code> modult, és hívd meg a <code>locale.getpreferredencoding()</code> metódust. A windowsos laptopomon ez a <code>'cp1252'</code> értéket adja vissza, de az emeleten lévő linuxos gépemen az <code>'UTF8'</code> értéket. Még a saját házamban sem tudok rendet tartani! A te eredményeid eltérhetnek (még Windowson is) az operációs rendszer telepített verziójától és a területi/nyelvi beállításaidtól függően. Ezért annyira fontos megadni a kódolást minden alkalommal, amikor megnyitsz egy fájlt.
</blockquote>

<h3 id=file-objects>Adatfolyam-objektumok</h3>

<p>Egyelőre azt tudjuk, hogy a Python rendelkezik egy beépített, <code>open()</code> nevű függvénnyel. Az <code>open()</code> függvény egy <i>adatfolyam objektumot</i> ad vissza, amely rendelkezik a karakterek folyamának kezelésére és az azzal kapcsolatos információk lekérésére szolgáló metódusokkal és  attribútumokkal.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>egy_fájl = open('examples/chinese.txt', encoding='utf-8')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.name</kbd>                                              <span class=u>&#x2460;</span></a>
<samp class=pp>'examples/chinese.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.encoding</kbd>                                          <span class=u>&#x2461;</span></a>
<samp class=pp>'utf-8'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.mode</kbd>                                              <span class=u>&#x2462;</span></a>
<samp class=pp>'r'</samp></pre>
<ol>
<li>A <code>name</code> attribútum az <code>open()</code> függvénynek a fájl megnyitásakor átadott nevet tükrözi. Ez nincs abszolút útvonalnévvé normalizálva.
<li>Hasonlóképpen az <code>encoding</code> attribútum az <code>open()</code> függvénynek a fájl megnyitásakor átadott kódolást tükrözi. Ha nem adtad meg a kódolást a fájl megnyitásakor (rossz fejlesztő!), akkor az <code>encoding</code> attribútum a <code>locale.getpreferredencoding()</code> értékét fogja tükrözni.
<li>A <code>mode</code> attribútum megadja, hogy milyen módban lett megnyitva a fájl. Az <code>open()</code> függvénynek átadhatsz egy elhagyható <var>mode</var> paramétert is. Nem adtál meg módot a fájl megnyitásakor, így a Python alapértelmezésben az <code>'r'</code>, azaz &#8222;megnyitás csak olvasásra, szöveges módban &#8221; módot használja. Ahogyan majd később ebben a fejezetben látni fogod, a fájl módja több célt szolgál, a különböző módok lehetővé teszik a fájlba írást, fájlhoz fűzést, vagy fájl megnyitását bináris módban (amikor szövegek helyett bájtokat kezelsz). </ol>

<blockquote class=note>
<p><span class=u>&#x261E;</span>Az <a href=http://docs.python.org/3.1/library/io.html#module-interface><code>open()</code> függvény dokumentációja</a> felsorolja az összes lehetséges fájlmódot.
</blockquote>

<h3 id=read>Adatok olvasása szövegfájlból</h3>

<p>Miután megnyitottál egy fájlt olvasásra, előbb-utóbb olvasni akarsz majd belőle.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>egy_fájl = open('examples/chinese.txt', encoding='utf-8')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read()</kbd>                                            <span class=u>&#x2460;</span></a>
<samp class=pp>'Dive Into Python 是为有经验的程序员编写的一本 Python 书。\n'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read()</kbd>                                            <span class=u>&#x2461;</span></a>
<samp class=pp>''</samp></pre>
<ol>
<li>Miután megnyitottál egy fájlt (a megfelelő kódolással), az olvasás csupán az adatfolyam objektum <code>read()</code> metódusának hívásából áll. Az eredmény egy karakterlánc.
<li>Talán némiképp meglepő, de a fájl ismételt olvasása nem dob kivételt. A Python nem tekinti a fájl vége utáni olvasást hibának, ilyenkor egyszerűen egy üres karakterláncot ad vissza.
</ol>

<aside>Mindig add meg az <code>encoding</code> paramétert fájlok megnyitásakor.</aside>

<p>Mi van, ha újra akarod olvasni a fájlt?

<pre class=screen>
# az előző példa folytatása
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read()</kbd>                      <span class=u>&#x2460;</span></a>
<samp class=pp>''</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.seek(0)</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read(16)</kbd>                    <span class=u>&#x2462;</span></a>
<samp class=pp>'Dive Into Python'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read(1)</kbd>                     <span class=u>&#x2463;</span></a>
<samp class=pp>' '</samp>
<samp class=p>>>> </samp><kbd class=pp>egy_fájl.read(1)</kbd>
<samp class=pp>'是'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.tell()</kbd>                      <span class=u>&#x2464;</span></a>
<samp class=pp>20</samp></pre>
<ol>
<li>Mivel még mindig a fájl végén vagy, az adatfolyam objektum <code>read()</code> metódusának további hívásai egyszerűen egy üres karakterláncot adnak vissza.
<li>A <code>seek()</code> metódus egy adott bájtpozícióra lép a fájlban.
<li>A <code>read()</code> metódus egy elhagyható paramétert vár, a beolvasandó karakterek számát.
<li>Ha szeretnéd, egyszerre akár egy bájtot is beolvashatsz.
<li>16 + 1 + 1 = &hellip; 20?
</ol>

<p>Fussunk neki ennek még egyszer

<pre class=screen>
# az előző példa folytatása
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.seek(17)</kbd>                    <span class=u>&#x2460;</span></a>
<samp class=pp>17</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read(1)</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>'是'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.tell()</kbd>                      <span class=u>&#x2462;</span></a>
<samp class=pp>20</samp></pre>
<ol>
<li>Mozgás a 17. bájtra.
<li>Egy karakter beolvasása.
<li>Most a 20. bájton vagy.
</ol>

<p>Látod már? A <code>seek()</code> és <code>tell()</code> metódusok mindig <em>bájtokat</em> számolnak, de mivel a fájlt szövegként nyitottad meg, a <code>read()</code> metódus <em>karaktereket</em> számol. A kínai karakterek <a href=strings.html#boring-stuff>több bájtot igényelnek az <abbr>UTF-8</abbr> kódoláshoz</a>. A fájlban lévő angol karakterek egyenként csak egy bájtot igényelnek, így azt hiheted, hogy a <code>seek()</code> és a <code>read()</code> metódusok ugyanazt számolják. De ez csak néhány karakterre igaz.

<p>De várj, lesz ez még rosszabb is!

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.seek(18)</kbd>                         <span class=u>&#x2460;</span></a>
<samp class=pp>18</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read(1)</kbd>                          <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;pyshell#12>", line 1, in &lt;module>
    egy_fájl.read(1)
  File "C:\Python31\lib\codecs.py", line 300, in decode
    (result, consumed) = self._buffer_decode(data, self.errors, final)
UnicodeDecodeError: 'utf8' codec can't decode byte 0x98 in position 0: unexpected code byte</samp></pre>
<ol>
<li>Lépjünk a 18. bájtra, és próbáljunk meg egy karaktert beolvasni.
<li>Miért nem sikerül ez? Mert nincs karakter a 18. bájtnál. A legközelebbi karakter a 17. bájtnál kezdődik (és három bájton át folytatódik). Egy karakter olvasása a közepéről sikertelen lesz, és <code>UnicodeDecodeError</code> kivételt dob.
</ol>

<h3 id=close>Fájlok bezárása</h3>

<p>A nyitott fájlok erőforrásokat fogyasztanak, és a fájl módjától függően más programok esetleg nem tudják elérni azokat. Fontos a fájlokat azonnal bezárni, amint végeztél a feldolgozásukkal.

<pre class='nd screen'>
# folytatás az előző példából
<samp class=p>>>> </samp><kbd class=pp>egy_fájl.close()</kbd></pre>

<p>Hát <em>ez</em> nem volt túl izgalmas.

<p>Az <var>egy_fájl</var> nevű adatfolyam-objektum továbbra is létezik, a <code>close()</code> metódusának meghívása nem semmisíti meg magát az objektumot. De azért így nem túl hasznos.

<pre class=screen>
# az előző példa folytatása
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read()</kbd>                           <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;pyshell#24>", line 1, in &lt;module>
    a_file.read()
ValueError: I/O operation on closed file.</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.seek(0)</kbd>                          <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;pyshell#25>", line 1, in &lt;module>
    a_file.seek(0)
ValueError: I/O operation on closed file.</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.tell()</kbd>                           <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;pyshell#26>", line 1, in &lt;module>
    a_file.tell()
ValueError: I/O operation on closed file.</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.close()</kbd>                          <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.closed</kbd>                           <span class=u>&#x2464;</span></a>
<samp class=pp>True</samp></pre>
<ol>
<li>Megpróbálhatsz olvasni egy bezárt fájlból, de ez <code>IOError</code> kivételt okoz.
<li>A bezárt fájlban nem tudsz pozicionálni sem.
<li>A bezárt fájlban nincs aktuális pozíció, így a <code>tell()</code> metódus hívása is meghiúsul.
<li>Talán meglepő, hogy a <code>close()</code> metódus hívása egy olyan adatfolyam-objektumon, amely fájlja be lett zárva, <em>nem</em> okoz kivételt. Egyszerűen nem csinál semmit.
<li>A bezárt adatfolyam-objektumoknak egy hasznos attribútumuk van: a <code>closed</code> attribútum megerősíti, hogy a fájl be van zárva.
</ol>

<h3 id=with>Fájlok automatikus bezárása</h3>

<aside>A <code>try..finally</code> jó. A <code>with</code> még jobb.</aside>

<p>Az adatfolyam-objektumok rendelkeznek explicit <code>close()</code> metódussal, de mi történik, ha a kódod hibás, és még a <code>close()</code> hívása előtt összeomlik? Az a fájl elméletileg sokkal tovább is nyitva maradhat, mint szükséges. Amíg a helyi számítógépen keresel hibát, ez nem nagy ügy. Egy éles szerveren már talán.

<p>A Python 2-nek volt erre egy megoldása: a <code>try..finally</code> blokk. Ez továbbra is működik Python 3-ban, és láthatod is mások kódjában, vagy olyan kódban, amit <a href=case-study-porting-chardet-to-python-3.html>Python 3-ra portoltak</a>. De a Python 2.6 bevezetett egy tisztább megoldást, amit a Python 3-ban előnyben részesítenek: a <code>with</code> utasítást.
<pre class='nd pp'><code>with open('examples/chinese.txt', encoding='utf-8') as egy_fájl:
    egy_fájl.seek(17)
    egy_karakter = egy_fájl.read(1)
    print(egy_karakter)</code></pre>

<p>Ez a kód meghívja az <code>open()</code> metódust, de soha nem jívja meg az <code>egy_fájl.close()</code>-t. A <code>with</code> utasítás kódblokkot kezd, mint egy <code>if</code> utasítás, vagy <code>for</code> ciklus. Ezen a kódblokkon belül az <var>egy_fájl</var> változót úgy használhatod, mint az <code>open()</code> által visszaadott adatfolyam-objektumot. Az összes normális adatfolyam-objektum metódus rendelkezésre áll &nbsp;&ndash;&nbsp;<code>seek()</code>, <code>read()</code>, amit csak akarsz. Amikor a <code>with</code> blokknak vége, a <em>Python automatikusan meghívja az <code>egy_fájl.close()</code>-t</em>.

<p>Itt a trükk: nem számít, hogyan vagy mikor lépsz ki a <code>with</code> blokkból, a Python bezárja a fájlt&hellip; még ha egy nem kezelt kivételen át is &#8222;lépsz ki&#8221; belőle. Így van: még ha a kódod kivételt is dob, és az egész program csikorogva leáll, a fájl be lesz zárva. Garantáltan.

<blockquote class=note>
<p><span class=u>&#x261E;</span>Technikailag a <code>with</code> utasítás egy <dfn>futási kontextust</dfn> hoz létre. Ezekben a példákban az adatfolyam-objektum <dfn>kontextuskezelőként</dfn> működik. A Python létrehozza az <var>egy_fájl</var> nevű adatfolyam-objektumot, és közli vele, hogy most belép egy futási kontextusba. Amikor a <code>with</code> kódblokk befejeződött, a Python közli az adatfolyam-objektummal, hogy most kilép a futási kontextusból, és az adatfolyam-objektum meghívja a saját <code>close()</code> metódusát. Lásd a <a href=special-method-names.html#context-managers>B függelék, &#8222;A <code>with</code> blokkban használható osztályok&#8221;</a> szakaszt a részletekért.
</blockquote>

<p>Nincs semmi fájlspecifikus a <code>with</code> utasításban; ez egy általános keretrendszer futási kontextusok létrehozására, és annak közlésére objektumokkal, hogy épp belépnek egy futási kontextusba vagy kilépnek abból. Ha a kérdéses objektum egy adatfolyam-objektum, akkor ez hasznos fájlközeli dolgokat csinál (például automatikusan bezárja a fájlt). De ez a viselkedés az adatfolyam-objektumban van meghatározva, nem a <code>with</code> utasításban. A kontextuskezelők használatára rengeteg más mód is van, a fájloktól függetlenül. Akár sajátot is létrehozhatsz, ahogyan majd a fejezet későbbi részében látni fogod.
<h3 id=for>Adatok olvasása soronként</h3>

<p>A szövegfájlok egy &#8222;sora&#8221; pontosan az, aminek elképzeled&nbsp;&ndash;&nbsp;beírsz pár szót, és megnyomod az <kbd>ENTER</kbd>-t, és máris egy új sorban vagy. Egy szövegsor karakterek sorozata, amiket elválaszt egy&hellip; mi is pontosan? Nos, ez bonyolult, mert a szövegfájlok több különböző karaktert is használhatnak a sor végének jelzésére. Minden operációs rendszernek megvan a saját megállapodása. Néhány a kocsivissza karaktert használja, mások a soremelés karaktert, és néhány mindkettőt elhelyezi minden sor végén.
<p>Lélegezz fel, mert a <em>Python alapértelmezésben automatikusan kezeli a sorvégeket</em>. Ha azt mondod, &#8222;Soronként be akarom olvasni ezt a szövegfájlt,I want&#8221; akkor a Python kitalálja, milyen sorvégződést használ a fájl, és innentől minden Csak Működik.
<blockquote class=note>
<p><span class=u>&#x261E;</span>Ha részletesebben szeretnéd befolyásolni, hogy mi számít sorvégnek, akkor átadhatod a <code>newline</code> paramétert az <code>open()</code> függvénynek. A véres részletekért lásd <a href=http://docs.python.org/3.1/library/io.html#module-interface>az <code>open()</code> függvény dokumentációját</a>.
</blockquote>

<p>Nos, akkor valójában hogy csinálod? Mármint a fájl soronkénti beolvasását. Olyan egyszerű, hogy gyönyörű.

<p class=d>[<a href=examples/oneline.py>az <code>oneline.py</code> letöltése</a>]
<pre class=pp><code>line_number = 0
<a>with open('examples/favorite-people.txt', encoding='utf-8') as egy_fájl:   <span class=u>&#x2460;</span></a>
<a>    for egy_sor in egy_fájl:                                               <span class=u>&#x2461;</span></a>
        sorszám += 1
<a>        print('{:>4} {}'.format(sorszám, egy_sor.rstrip()))                <span class=u>&#x2462;</span></a></code></pre>
<ol>
<li>A <a href=#with><code>with</code> minta használatával</a> biztonságosan megnyitod a fájlt, és hagyod, hogy Python bezárja helyetted.
<li>Egy fájl soronkénti beolvasásához használj <code>for</code> ciklust. Ennyi. Azon kívül, hogy a <code>read()</code>-hez hasonló explicit metódusai vannak, <em>az adatfolyam-objektum egyben <a href=iterators.html>iterátor</a> is</em>, ami minden értékkéréskor egy sort ad vissza.
<li>A <a href=strings.html#formatting-strings><code>format()</code> karakterlánc-metódus</a> használatával kiírathatod a sorszámot és magát a sort is. A <code>{:>4}</code> formátumleíró azt jelenti: &#8222;írd ki ezt az argumentumot jobbra igazítva 4 szóközön belül.&#8221; Az <var>egy_sor</var> változó tartalmazza az egész sort, a kocsivissza karakterekkel együtt. Az <code>rstrip()</code> karakterlánc-metódus eltávolítja a záró üres helyeket, beleértve a kocsivissza karaktereket is.
</ol>

<pre class='screen cmdline'>
<samp class=p>you@localhost:~/diveintopython3$ </samp><kbd class=pp>python3 examples/oneline.py</kbd>
<samp>   1 Dora
   2 Ethan
   3 Wesley
   4 John
   5 Anne
   6 Mike
   7 Chris
   8 Sarah
   9 Alex
  10 Lizzie</samp></pre>

<blockquote class=pf>
<p>Ezt a hibát kaptad?
<pre class='nd screen'>
<samp class=p>te@localhost:~/diveintopython3$ </samp><kbd class=pp>python3 examples/oneline.py</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "examples/oneline.py", line 4, in &lt;module>
    print('{:>4} {}'.format(line_number, a_line.rstrip()))
ValueError: zero length field name in format</samp></pre>
<p>Ha igen, akkor valószínűleg a Python 3.0-át használod. Komolyan frissítened kellene legalább Python 3.1-re.
<p>A Python 3.0 támogatta a karakterlánc-formázást, de csak <a href=strings.html#formatting-strings>expliciten számozottformátumleírókkal</a>. A Python 3.1 lehetővé teszi az argumentumindexek kihagyását a formátumleírókban. Összehasonlításul itt a Python 3.0-kompatibilis verzió:
<pre class='pp nd'><code>print('{<mark>0</mark>:>4} {<mark>1</mark>}'.format(sorszám, egy_sor.rstrip()))</code></pre>
</blockquote>

<p class=a>&#x2042;

<h2 id=writing>Írás szövegfájlokba</h2>

<aside>Csak nyiss meg egy fájlt, és kezdj el írni.</aside>

<p>A fájlokba nagyjából ugyanúgy írhatsz, ahogy olvasod azokat. Először megnyitsz egy fájlt, és kapsz egy adatfolyam-objektumot, aztán metódusokat használsz az adatfolyam-objektumon, hogy adatokat írj a fájlba, majd bezárod a fájlt.

<p>Egy fájl írásra való megnyitásához használd az <code>open()</code> függvényt, és add meg az írás módot. Két fájlmód használható az íráshoz:

<ul>
<li>Az &#8222;írás&#8221; mód felülírja a fájlt. Add át a <code>mode='w'</code> paramétert az <code>open()</code> függvénynek.
<li>A &#8222;hozzáfűzés&#8221; mód a fájl végéhez fog adatokat adni. Add át a <code>mode='a'</code> paramétert az <code>open()</code> függvénynek.
</ul>

<p>Mindkét mód automatikusan létrehozza a fájlt, ha még nem létezik, így nincs szükség semmi szöszmötölős &#8222;ha a fájl még nem létezik, akkor hozz létre egy új fájlt csak hogy először megnyithasd&#8221; függvényre. Csak nyisd meg a fájlt, és kezdd írni.

<p>Mindig zárd be a fájlokat, amint végeztél az írásukkal, hogy felszabadítsd a fájlhivatkozást, és biztosítsd, hogy az adatok valójában kiírásra kerülnek a háttértárra. Ahogyan az adatok fájlból olvasásakor, itt is meghívhatod az adatfolyam-objektum <code>close()</code> metódusát, vagy használhatod a <code>with</code> utasítást, és rábízhatod a fájl bezárását a Pythonra. Fogadni mernék, hogy kitalálod, melyik módszert javaslom.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>with open('teszt.log', mode='w', encoding='utf-8') as egy_fájl:</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>... </samp><kbd class=pp>    egy_fájl.write('a teszt sikerült')</kbd>                            <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>with open('teszt.log', encoding='utf-8') as egy_fájl:</kbd>
<samp class=p>... </samp><kbd class=pp>    print(egy_fájl.read())</kbd>
<samp class=pp>a teszt sikerült</samp>
<a><samp class=p>>>> </samp><kbd class=pp>with open('teszt.log', mode='a', encoding='utf-8') as egy_fájl:</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>... </samp><kbd class=pp>    a_file.write('és újra')</kbd>
<samp class=p>>>> </samp><kbd class=pp>with open('teszt.log', encoding='utf-8') as egy_fájl:</kbd>
<samp class=p>... </samp><kbd class=pp>    print(egy_fájl.read())</kbd>
<a><samp class=pp>a teszt sikerültés újra</samp>                                           <span class=u>&#x2463;</span></a></pre>
<ol>
<li>Bátran kezdesz a <code>teszt.log</code> nevű új fájl létrehozásával (vagy a meglévő fájl felülírásával), és a fájl írásra megnyitásával. A <code>mode='w'</code> paraméter azt jelenti, hogy írásra nyitod meg a fájlt. Igen, ez tényleg olyan veszélyes, mint amilyennek hangzik. Remélem, nem érdekelt annak a fájlnak a tartalma (ha volt), mert azok az adatok már elvesztek.
<li>Az <code>open()</code> függvény által visszaadott adatfolyam-objektum <code>write()</code> metódusával adhatsz adatokat az újonnan megnyitott fájlhoz. A<code>with</code> blokk végén a Python automatikusan bezárja a fájlt.
<li>Ez olyan jó móka volt, csináljuk meg újra. De most a <code>mode='a'</code> használatával, hogy hozzáfűzzünk a fájlhoz a felülírása helyett. A hozzáfűzés<em>soha</em> nem bántja a fájl meglévő tartalmát.
<li>Mind az eredetileg kiírt sor, mind a hozzáfűzött második most a <code>teszt.log</code> fájlban van. Vedd észre, hogy sem kocsivissza, sem soremelés karakterek nincsenek. Mivel nem írtál ki explicit módon ilyeneket egyik alkalommal sem, a fájl nem tartalmaz egyet sem. Kocsivissza karaktert a <code>'\r'</code> sorozat használatával, soremelést pedig a <code>'\n'</code> sorozattal írhatsz. Mivel egyiket sem tetted, a fájlba írt minden szöveg egy sorba került.
</ol>

<h3 id=encoding-again>Karakterkódolás megint</h3>

<p>Észrevetted az <code>encoding</code> paramétert, amit az <code>open()</code> függvény kapott, miközben <a href=#writing>megnyitottál egy fájlt írásra</a>? Ez fontos, soha ne hagyd ki! Ahogyan a fejezet elején láttad, a fájlok nem <i>karakterláncokat</i> tartalmaznak, hanem<i>bájtokat</i>. A &#8222;karakterlánc&#8221; szövegfájlból olvasása csak azért működik, mert megmondtad a Pythonnak, hogy milyen kódolást használjon a bájtok sorozatának olvasásához, és karakterlánccá konvertálásához. A szöveg fájlba írása ugyanazt a problémát veti fel, csak fordítva. Nem írhatsz karaktereket egy fájlba,<a href=strings.html#byte-arrays>a karakterek absztrakciók</a>. Ahhoz, hogy fájlba írhasd őket, a Pythonnak tudnia kell, hogyan konvertálja a karakterláncodat bájtok sorozatává. Egyetlen módszer van a helyes konverzió végrehajtására: az <code>encoding</code> paraméter megadása a fájl írásra való megnyitásakor.

<p class=a>&#x2042;

<h2 id=binary>Bináris fájlok</h2>

<p class=ss><img src=examples/beauregard.jpg alt='a kutyám, Beauregard' width=100 height=100>

<p>Nem minden fájl tartalmaz szöveget. Néhány a kutyám képét tartalmazza.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>egy_kép = open('examples/beauregard.jpg', mode='rb')</kbd>                <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>egy_kép.mode</kbd>                                                        <span class=u>&#x2461;</span></a>
<samp class=pp>'rb'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_kép.name</kbd>                                                        <span class=u>&#x2462;</span></a>
<samp class=pp>'examples/beauregard.jpg'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_kép.encoding</kbd>                                                    <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AttributeError: '_io.BufferedReader' object has no attribute 'encoding'</samp></pre>
<ol>
<li>A fájlok bináris módban való megnyitása egyszerű, de xxxészrevétlen. Az egyetlen különbség a szöveg módban való megnyitáshoz képest, hogy a <code>mode</code> paraméter tartalmaz egy <code>'b'</code> karaktert.
<li>A fájl bináris módban való megnyitásakor kapott adatfolyam-objektumnak sok attribútuma ugyanolyan, beleértve a <code>mode</code>-ot, ami az <code>open()</code> függvénynek átadott <code>mode</code> paramétert tükrözi.
<li>A bináris adatfolyam-objektumoknak van <code>name</code> attribútumuk is, ahogyan a szöveges adatfolyam-objektumoknak.
<li>Van itt azért egy különbség: a bináris adatfolyam-objektumnak nincs <code>encoding</code> attribútuma. Logikus, nem? Bájtokat, és nem karakterláncokat olvasol (vagy írsz), így nem kell a Pythonnak konverziót végeznie. Amit egy bináris fájlba teszel, pontosan azt veszed ki, nincs szükség konverzióra.
</ol>

<p>Említettem, hogy bájtokat olvasol? Ó, igen, azokat.

<pre class=screen>
# folytatás az előző példából
<samp class=p>>>> </samp><kbd class=pp>egy_kép.tell()</kbd>
<samp class=pp>0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>adat = egy_kép.read(3)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>adat</kbd>
<samp class=pp>b'\xff\xd8\xff'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(adat)</kbd>               <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'bytes'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_kép.tell()</kbd>          <span class=u>&#x2462;</span></a>
<samp class=pp>3</samp>
<samp class=p>>>> </samp><kbd class=pp>egy_kép.seek(0)</kbd>
<samp class=pp>0</samp>
<samp class=p>>>> </samp><kbd class=pp>adat = egy_kép.read()</kbd>
<samp class=p>>>> </samp><kbd class=pp>len(adat)</kbd>
<samp class=pp>3150</samp></pre>
<ol>
<li>A szövegfájlokhoz hasonlóan a bináris fájlok is beolvashatók egyszerre kis darabokban. De van egy alapvető különbség&hellip;
<li>&hellip;bájtokat olvasol, nem karakterláncokat. Mivel a fájlt bináris módban nyitottad meg, a <code>read()</code> metódus a<em>beolvasandó bájtok számát</em> várja, nem a karakterek számát.
<li>Ez azt jelenti, hogy soha nincs <a href=#read>váratlan eltérés</a> a <code>read()</code> metódusnak átadott szám és a <code>tell()</code> metódus által visszaadott pozícióindex között. A <code>read()</code> metódus bájtokat olvas, és a <code>seek()</code> és <code>tell()</code> metódusok a beolvasott bájtok számát tartják nyilván. A bináris fájlok esetén ezek mindig megegyeznek.
</ol>

<p class=a>&#x2042;

<h2 id=file-like-objects>Adatfolyam-objektumok nem fájl forrásokból</h2>

<aside>Egy hamis fájlból olvasáshoz csak hívd meg a <code>read()</code> metódust.</aside>

<p>Képzeld el, hogy egy függvénytárat írsz, és a függvénytárad egyik függvénye adatokat fog olvasni egy fájlból. A függvény egyszerűen várhat egy fájlnevet karakterláncként, megnyithatja a fájlt olvasásra, és bezárhatja kilépés előtt. De ne csináld ezt. Ehelyett az <abbr>API</abbr>-d várhat <em>egy tetszőleges adatfolyam-objektumot</em>.

<p>A legegyszerűbb esetben az adatfolyam-objektum bármi lehet, ha rendelkezik egy <code>read()</code> metódussal, ami egy elhagyható <var>size</var> paramétert vár, és visszaad egy karakterláncot. Amikor <var>size</var> paraméter nélkül hívják, a <code>read()</code> metódus be kell olvasson mindent a bemeneti forrásból, és vissza kell adnia az összes adatot egyetlen értékként. Amikor <var>size</var> paraméterrel hívják, annyit olvas a bemeneti forrásból, és annyi adatot ad vissza. Ha újra meghívják, ott folytatja, ahol abbahagyta, és visszaadja a következő adatdarabot.

<p>Ez pontosan úgy hangzik, mint a valódi fájl megnyitásakor kapott adatfolyam-objektum. A különbség, hogy <em>nem korlátozod magad valódi fájlokra</em>. Az &#8222;olvasott&#8221; bemeneti forrás bármi lehet: egy weboldal, egy karakterlánc a memóriában, akár egy másik program kimenete is. Amíg a függvényeid egy adatfolyam-objektumot várnak, és egyszerűen meghívják az objektum <code>read()</code> metódusát, tetszőleges bemeneti forrást kezelhetsz, ami fájlként viselkedik, a különböző bemenettípusokat külön-külön kezelő kód nélkül.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>egy_karakterlánc = 'PapayaWhip is the new black.'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>import io</kbd>                                  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl = io.StringIO(egy_karakterlánc)</kbd>   <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read()</kbd>                              <span class=u>&#x2462;</span></a>
<samp class=pp>'PapayaWhip is the new black.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read()</kbd>                              <span class=u>&#x2463;</span></a>
<samp class=pp>''</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.seek(0)</kbd>                             <span class=u>&#x2464;</span></a>
<samp class=pp>0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>egy_fájl.read(10)</kbd>                            <span class=u>&#x2465;</span></a>
<samp class=pp>'PapayaWhip'</samp>
<samp class=p>>>> </samp><kbd class=pp>egy_fájl.tell()</kbd>
<samp class=pp>10</samp>
<samp class=p>>>> </samp><kbd class=pp>egy_fájl.seek(18)</kbd>
<samp class=pp>18</samp>
<samp class=p>>>> </samp><kbd class=pp>egy_fájl.read()</kbd>
<samp class=pp>'new black.'</samp></pre>
<ol>
<li>Az <code>io</code> modul definiálja a <code>StringIO</code> osztályt, amelyet egy memóriabeli karakterlánc fájlként kezelésére használhatsz.
<li>A karakterláncból adatfolyam-objektum létrehozásához példányosítsd az <code>io.StringIO()</code> osztályt, és add át neki a &#8222;fájladatként&#8221; használandó karakterláncot. Most már van egy adatfolyam-objektumod, és mindenféle adatfolyam-szerű dolgot csinálhatsz vele.
<li>A <code>read()</code> metódus hívása &#8222;beolvassa&#8221; az egész &#8222;fájlt,&#8221; ami a <code>StringIO</code> objektum esetén egyszerűen visszaadja az eredeti karakterláncot.
<li>Ahogyan egy valódi fájlnál, a <code>read()</code> metódus ismételt hívása üres karakterláncot ad vissza.
<li>Expliciten a karakterlánc elejére pozicionálhatsz, ahogyan egy valódi fájlban pozicionálnál, a<code>StringIO</code> objektum <code>seek()</code> metódusnak használatával.
<li>A karakterláncot darabonként is beolvashatod, a <var>size</var> paraméter átadásával a <code>read()</code> metódusnak.
</ol>

<blockquote class=note>
<p>Az <span class=u>&#x261E;</span><code>io.StringIO</code> lehetővé teszi egy karakterlánc szövegfájlként kezelését. Létezik egy <code>io.BytesIO</code> osztály is, ami lehetővé teszi egy bájttömb bináris fájlként kezelését. </blockquote>

<h3 id=gzip>Tömörített fájlok kezelése</h3>

<p>A Python szabványos függvénytára tartalmaz a tömörített fájlok olvasását és írását támogató modulokat. Számos különböző tömörítési eljárás létezik, a két legnépszerűbb nem Windows rendszereken a <a href=http://docs.python.org/3.1/library/gzip.html>gzip</a> és <a href=http://docs.python.org/3.1/library/bz2.html>bzip2</a>. (Találkozhattál <a href=http://docs.python.org/3.1/library/zipfile.html>PKZIP archívumokkal</a> és <a href=http://docs.python.org/3.1/library/tarfile.html>GNU Tar archívumokkal</a> is. A Python rendelkezik modulokkal ezekhez is.)

<p>A <code>gzip</code> modul lehetővé teszi gzip-pel tömörített fájl olvasásához vagy írásához használható adatfolyam-objektum létrehozását. Az általa visszaadott adatfolyam-objektum támogatja a <code>read()</code> metódust (ha olvasásra nyitottad meg), vagy a <code>write()</code> metódust (ha írásra nyitottad meg). Ez azt jelenti, hogy használhatod a normális fájlokhoz megismert metódusokat <em>gzip-pel tömörített fájl közvetlen olvasására vagy írására</em>, anélkül, hogy ideiglenes fájlt kellene létrehoznod a kibontott adatok tárolásához.

<p>További extraként támogatja a <code>with</code> utasítást is, így hagyhatod, hogy a Python automatikusan bezárja a gzip-pel tömörített fájlodat, ha végeztél vele.

<pre class='nd screen cmdline'>
<samp class=p>te@localhost:~$ </samp><kbd>python3</kbd>

<samp class=p>>>> </samp><kbd class=pp>import gzip</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>with gzip.open('out.log.gz', mode='wb') as z_fájl:</kbd>                                      <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd class=pp>  z_fájl.write('Egy kilenc mérföldes séta nem vicc, különösen nem az esőben.'.encode('utf-8'))</kbd>
<samp class=p>... </samp>
<samp class=p>>>> </samp><kbd class=pp>exit()</kbd>

<a><samp class=p>te@localhost:~$ </samp><kbd>ls -l out.log.gz</kbd>                                                           <span class=u>&#x2461;</span></a>
<samp>-rw-r--r--  1 mark mark    79 2009-07-19 14:29 out.log.gz</samp>
<a><samp class=p>te@localhost:~$ </samp><kbd>gunzip out.log.gz</kbd>                                                          <span class=u>&#x2462;</span></a>
<a><samp class=p>te@localhost:~$ </samp><kbd>cat out.log</kbd>                                                                <span class=u>&#x2463;</span></a>
<samp>Egy kilenc mérföldes séta nem vicc, különösen nem az esőben.</samp></pre>
<ol>
<li>A gzip-pel tömörített fájlokat mindig bináris módban kell megnyitni. (Vedd észre a <code>'b'</code> karaktert a <code>mode</code> argumentumban.)
<li>Ezt a példát Linuxon állítottam elő. Ha nem ismered a parancssort: ez a parancs a Python parancsértelmezőben létrehozott, gzip-pel tömörített fájl &#8222;hosszú kiírását&#8221; jeleníti meg. Ez a kiírás megmutatja, hogy a fájl létezik (jó), és hogy 79xxx bájt hosszú. Ez valójában hosszabb, mint az a karakterlánc, amivel indultunk! A gzip fájlformátum tartalmaz egy rögzített hosszúságú fejlécet, ami néhány metaadatot tartalmaz a fájlról, így nagyon kis fájlok esetén nem hatékony.
<li>A <code>gunzip</code> parancs (ejtsd: &#8222;gé-unzip&#8221;) kibontja a fájlt, és a tartalmát egy új fájlban tárolja, aminek ugyanaz lesz a neve, mint a tömörített fájlnak, de a <code>.gz</code> fájlkiterjesztés nélkül.
<li>A <code>cat</code> parancs megjeleníti egy fájl tartalmát. Ez a fájl tartalmazza azt a karakterláncot, amit eredetileg közvetlenül az <code>out.log.gz</code> fájlba írtál a Python parancsértelmezőben.
</ol>

<blockquote class=pf>
<p>Ezt a hibát kaptad?
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>with gzip.open('out.log.gz', mode='wb') as z_fájl:</kbd>
<samp class=p>... </samp><kbd class=pp>        z_fájl.write('Egy kilenc mérföldes séta nem vicc, különösen nem az esőben.'.encode('utf-8'))</kbd>
<samp class=p>... </samp>
<samp class=traceback>Traceback (most recent call last):
 File "&lt;stdin>", line 1, in &lt;module>
AttributeError: 'GzipFile' object has no attribute '__exit__'</samp></pre>
<p>Ha igen, akkor valószínűleg a Python 3.0-át használod. Komolyan frissítened kellene legalább Python 3.1-re.
<p>A Python 3.0 rendelkezett egy <code>gzip</code> modullal, de nem támogatta a gzip-pel tömörített fájl objektum kontextuskezelőként való használatát. A Python 3.1 már képes a gzip-pel tömörített fájl objektumok használatára <code>with</code> utasításban. </blockquote>

<p class=a>&#x2042;

<h2 id=stdio>Szabványos bemenet, kimenet és hibakimenet</h2>

<aside><code>sys.stdin</code>, <code>sys.stdout</code>, <code>sys.stderr</code>.</aside>

<p>A parancssori guruknak már ismerős a szabványos bemenet, szabványos kimenet és szabványos hibakimenet fogalma. Ez a szakasz a többieknek szól.

<p>A szabványos kimenet és a szabványos hibakimenet (gyakran <code>stdout</code> és <code>stderr</code> rövidítésekkel használják) olyan adatcsatornák, amik minden  <abbr>UNIX</abbr>-szerű rendszerbe be vannak építve, beleértve a Mac OS X-et és Linuxot. Amikor a <code>print()</code> függvényt hívod, a kiírt dolog az  <code>stdout</code> adatcsatornába kerül. Amikor a programod összeomlik, és nyomkövetést ír ki, az az <code>stderr</code> adatcsatornába kerül. Alapértelmezésben ez a két adatcsatorna egyaránt arra a terminálablakra van irányítva, amiben dolgozol, amikor a programod kiír valamit, a kimenetet a terminálablakban látod, és amikor a program összeomlik, az is a terminálablakban jeleníti meg a nyomkövetést. A grafikus Python parancsértelmezőben az <code>stdout</code> és <code>stderr</code> adatcsatornák alapértelmezésben az &#8222;interaktív ablakba&#8221; vannak irányítva.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>for i in range(3):</kbd>
<a><samp class=p>... </samp><kbd class=pp>    print('PapayaWhip')</kbd>                <span class=u>&#x2460;</span></a>
<samp>PapayaWhip
PapayaWhip
PapayaWhip</samp>
<samp class=p>>>> </samp><kbd class=pp>import sys</kbd>
<samp class=p>>>> </samp><kbd class=pp>for i in range(3):</kbd>
<a><samp class=p>... </samp><kbd class=pp>    l = sys.stdout.write('is the')</kbd>     <span class=u>&#x2461;</span></a>
<samp>is theis theis the</samp>
<samp class=p>>>> </samp><kbd class=pp>for i in range(3):</kbd>
<a><samp class=p>... </samp><kbd class=pp>    l = sys.stderr.write('new black')</kbd>  <span class=u>&#x2462;</span></a>
<samp>new blacknew blacknew black</samp></pre>
<ol>
<li>A <code>print()</code> függvény, ciklusban. Semmi meglepő.
<li>Az <code>stdout</code> a <code>sys</code> modulban van definiálva, és ez egy <a href=#file-like-objects>adatfolyam-objektum</a>. A <code>write()</code> függvényének meghívása kiírja a neki átadott tetszőleges karakterláncot, majd visszaadja a kimenet hosszát. Valójában ez az, amit a <code>print</code> függvény ténylegesen csinál; hozzáad egy kocsivissza karaktert a kiírandó karakterlánc végéhez, és meghívja a <code>sys.stdout.write</code>-ot.
<li>A legegyszerűbb esetben a <code>sys.stdout</code> és a <code>sys.stderr</code> a kimenetüket ugyanoda küldik: a Python <abbr>IDE</abbr>-nek (ha ezt használod) vagy a terminálnak (ha a Pythont a parancssorból futtatod). A szabványos kimenethez hasonlóan a szabványos hibakimenet sem ad kocsivissza karaktereket a szöveghez. Ha kocsivissza karaktereket akarsz, akkor kocsivissza karaktereket kell írnod.
</ol>

<p>A <code>sys.stdout</code> és <code>sys.stderr</code> adatfolyam-objektumok, de csak írhatók. A <code>read()</code> metódusuk hívására tett kísérlet mindig <code>IOError</code> kivételt dob.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import sys</kbd>
<samp class=p>>>> </samp><kbd class=pp>sys.stdout.read()</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
IOError: not readable</samp></pre>

<h3 id=redirect>A szabványos kimenet átirányítása</h3>

<p>A <code>sys.stdout</code> és <code>sys.stderr</code> adatfolyam-objektumok, noha csak az írást támogatják. De nem konstansok, hanem változók. Ez azt jelenti, hogy új értéket rendelhetsz hozzájuk&nbsp;&ndash;&nbsp;bármely másik adatfolyam-objektumot&nbsp;&ndash;&nbsp;hogy az irányítsa át a kimenetét.
<p class=d>[<a href=examples/stdout.py>az <code>stdout.py</code> letöltése</a>]
<pre class=pp><code>import sys

class RedirectStdoutTo:
    def __init__(self, ki_új):
        self.ki_új = ki_új

    def __enter__(self):
        self.ki_régi = sys.stdout
        sys.stdout = self.ki_új

    def __exit__(self, *args):
        sys.stdout = self.ki_új

print('A')
with open('out.log', mode='w', encoding='utf-8') as egy_fájl, RedirectStdoutTo(egy_fájl):
    print('B')
print('C')</code></pre>

<p>Nézd csak:

<pre class='nd screen cmdline'>
<samp class=p>te@localhost:~/diveintopython3/examples$ </samp><kbd>python3 stdout.py</kbd>
<samp>A
C</samp>
<samp class=p>te@localhost:~/diveintopython3/examples$ </samp><kbd>cat out.log</kbd>
<samp>B</samp></pre>

<blockquote class=pf>
<p>Ezt a hibát kaptad?
<pre class='nd screen'>
<samp class=p>te@localhost:~/diveintopython3/examples$ </samp><kbd class=pp>python3 stdout.py</kbd>
<samp class=traceback>  File "stdout.py", line 15
    with open('out.log', mode='w', encoding='utf-8') as egy_fájl, RedirectStdoutTo(egy_fájl):
                                                                ^
SyntaxError: invalid syntax</samp></pre>
<p>Ha igen, akkor valószínűleg a Python 3.0-át használod. Komolyan frissítened kellene legalább Python 3.1-re.
<p>A Python 3.0 támogatta a <code>with</code> utasítást, de minden utasítás csak egy kontextuskezelőt tud használni. A Python 3.1 lehetővé teszi több kontextuskezelő összekötését egyetlen <code>with</code> utasításban.
</blockquote>

<p>Vegyük először az utolsó részt.

<pre class=pp><code>print('A')
with open('out.log', mode='w', encoding='utf-8') as egy_fájl, RedirectStdoutTo(egy_fájl):
    print('B')
print('C')</code></pre>

<p>Ez egy bonyolult <code>with</code> utasítás. Hadd írjam át valami felismerhetőbbre.

<pre class=pp><code>with open('out.log', mode='w', encoding='utf-8') as egy_fájl:
    with RedirectStdoutTo(egy_fájl):
        print('B')</code></pre>

<p>Ahogyan az újraírás mutatja, valójában <em>két</em> <code>with</code> utasításunk van, az egyik beágyazva a másik hatókörébe. A &#8222;külső&#8221; <code>with</code> utasításnak mostanra ismerősnek kell lennie: megnyit egy <abbr>UTF-8</abbr>-kódolású, <code>out.log</code> nevű fájlt írásra, és az adatfolyam-objektumot hozzárendeli az <var>egy_fájl</var> nevű változóhoz. De itt nem ez az egyetlen fura dolog.
<pre class='nd pp'><code>with RedirectStdoutTo(egy_fájl):</code></pre>

<p>Hol van az <code>as</code> kulcsszó? Valójában a <code>with</code> utasítás nem igényli. Mint ahogy meghívsz egy függvényt, és figyelmen kívül hagyod a visszatérési értékét, ugyanúgy használhatsz olyan <code>with</code> utasítást, ami nem rendeli a <code>with</code> kontextust változóhoz. Ebben az esetben csak a <code>RedirectStdoutTo</code> kontextus mellékhatásai érdekelnek.

<p>Mik ezek a mellékhatások? Vessünk egy pillantást a <code>RedirectStdoutTo</code> osztályra. Ez az osztály egy egyéni <a href=special-method-names.html#context-managers>kontextuskezelő</a>. Bármely osztály lehet kontextuskezelő, ezen két <a href=iterators.html#a-fibonacci-iterator>speciális metódus</a> definiálásával: <code>__enter__()</code> és <code>__exit__()</code>.

<pre class=pp><code>class RedirectStdoutTo:
<a>    def __init__(self, ki_új):    <span class=u>&#x2460;</span></a>
        self.ki_új = ki_új

<a>    def __enter__(self):            <span class=u>&#x2461;</span></a>
        self.ki_régi = sys.stdout
        sys.stdout = self.ki_új

<a>    def __exit__(self, *args):      <span class=u>&#x2462;</span></a>
        sys.stdout = self.ki_régi</code></pre>
<ol>
<li>Az <code>__init__()</code> metódus a példány létrehozása után azonnal meghívásra kerül. Egy paramétert vár, a kontextus élete során szabványos kimenetként használni kívánt adatfolyam-objektumot. Ez a metódus egyszerűen egy példányváltozóban menti az adatfolyam-objektumot, hogy később más metódusok is használhassák.
<li>Az <code>__enter__()</code> metódus egy <a href=iterators.html#a-fibonacci-iterator>speciális osztálymetódus</a>. A Python akkor hívja meg, amikor belép a kontextusba (<i>azaz</i> a <code>with</code> utasítás elején). Ez a metódus elmenti a <code>sys.stdout</code> aktuális értékét a <var>self.ki_régi</var> változóba, majd átirányítja a szabványos kimenetet a <var>self.ki_új</var> hozzárendelésével a <var>sys.stdout</var>-hoz.
<li>Az <code>__exit__()</code> metódus egy másik speciális osztálymetódus. A Python a kontextusból való kilépéskor hívja meg (<i>azaz</i> a <code>with</code> utasítás végén). Ez a metódus visszaállítja a szabványos kimenetet az eredeti értékére az elmentett <var>self.ki_régi</var> hozzárendelésével a <var>sys.stdout</var>-hoz.
</ol>

<p>Összegezve:

<pre class=pp><code>
<a>print('A')                                                                               <span class=u>&#x2460;</span></a>
<a>with open('out.log', mode='w', encoding='utf-8') as egy_fájl, RedirectStdoutTo(a_file):  <span class=u>&#x2461;</span></a>
<a>    print('B')                                                                           <span class=u>&#x2462;</span></a>
<a>print('C')                                                                               <span class=u>&#x2463;</span></a></code></pre>
<ol>
<li>Ez az <abbr>IDE</abbr>-be &#8222;interaktív ablakba&#8221; (vagy a terminálba, ha a parancssorból futtatod a parancsfájlt) fog írni.
<li>Ez a <a href=#with><code>with</code> utasítás</a> <em>kontextusok vesszőkkel elválasztott listáját</em> várja. A vesszőkkel elválasztott lista egymásba ágyazott <code>with</code> blokkok sorozataként működik. Az elsőként felsorolt kontextus a &#8222;külső&#8221; blokk, az utolsóként felsorolt a &#8222;belső&#8221; blokk. Az első kontextus megnyit egy fájlt, a második kontextus átirányítja a <code>sys.stdout</code>-ot az első kontextusban létrehozott adatfolyam-objektumra.
<li>Mivel ez a <code>print()</code> függvény a <code>with</code> utasítással létrehozott kontextussal kerül végrehajtásra, nem a képernyőre fog írni, hanem az <code>out.log</code> fájlba.
<li>A <code>with</code> kódblokknak vége van. A Python közölte minden egyes kontextuskezelővel, hogy tegyék meg azt, amit a kontextusból kilépéskor szoktak. A kontextuskezelők egy utolsó-be, első-ki (LIFO) vermet alkotnak. Kilépéskor a második kontextus visszaállította a <code>sys.stdout</code>-ot az eredeti értékére,  majd az első kontextus bezárta az <code>out.log</code> nevű fájlt. Mivel a szabványos kimenet vissza lett állítva az eredeti értékére, a <code>print()</code> függvény hívása újra a képernyőre fog írni.
</ol>

<p>A szabványos hibakimenet átirányítása pontosan ugyanígy működik, a <code>sys.stderr</code>-t használva a <code>sys.stdout</code> helyett.
<p class=a>&#x2042;

<h2 id=furtherreading>További olvasnivaló</h2>

<ul>
<li><a href=http://docs.python.org/py3k/tutorial/inputoutput.html#reading-and-writing-files>Fájlok olvasása és írása</a> a Python.org ismertetőben
<li><a href=http://docs.python.org/3.1/library/io.html>Az <code>io</code> modul</a>
<li><a href=http://docs.python.org/3.1/library/stdtypes.html#file-objects>Adatfolyam-objektumok</a>
<li><a href=http://docs.python.org/3.1/library/stdtypes.html#context-manager-types>Kontextuskezelő-típusok</a>
<li><a href=http://docs.python.org/3.1/library/sys.html#sys.stdout><code>sys.stdout</code> és <code>sys.stderr</code></a>
<li><a href=http://en.wikipedia.org/wiki/Filesystem_in_Userspace><abbr>FUSE</abbr> a Wikipédián</a>
</ul>

<p class=v><a href=refactoring.html rel=prev title='vissza az &#8222;Átdolgozásra&#8221;'><span class=u>&#x261C;</span></a> <a href=xml.html rel=next title='előre az &#8222;XML-re&#8221;'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
