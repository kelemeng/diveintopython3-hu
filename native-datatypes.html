<!DOCTYPE html>
<meta charset=utf-8>
<title>Natív adattípusok - Ugorj fejest a Python 3-ba</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 2}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=root value=Keresés></div></form>
<p>Itt vagy: <a href=index.html>Kezdőlap</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#native-datatypes>Ugorj fejest a Python 3-ba</a> <span class=u>&#8227;</span>
<p id=level>Nehézségi szint: <span class=u title=kezdő>&#x2666;&#x2666;&#x2662;&#x2662;&#x2662;</span>
<h1>Natív adattípusok</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> A csoda minden filozófia alapja, a vizsgálódás a fejlődésük, a tudatlanság a végük. <span class=u>&#x275E;</span><br>&ndash; Michel de Montaigne
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Ugorj fejest</h2>
<p class=f>Adattípusok. Tedd félre <a href=your-first-python-program.html>az első Python programod</a> egy
percre, és beszéljünk az adattípusokról. Pythonban <a href=your-first-python-program.html#declaringfunctions>minden értéknek van
adattípusa</a>, de nem kell deklarálnod a változók adattípusát. Hogy
működik ez? Az egyes változóknak eredetileg adott érték alapján a Python
meghatározza annak értékét, és nyilvántartja azt.
<p>A Python sok natív adattípussal rendelkezik. A fontosak az alábbiak:
<ol>
<li>A <b>logikai értékek</b> <code>True</code> vagy <code>False</code> értékűek lehetnek.
<li>A <b>számok</b> lehetnek egészek (<code>1</code> és <code>2</code>),
lebegőpontosak (<code>1.1</code> és <code>1.2</code>), törtek
(<code>1/2</code> és <code>2/3</code>) vagy akár <a
href=http://en.wikipedia.org/wiki/Complex_number>komplex számok</a> is.
<li>A <b>karakterláncok</b> Unicode karakterek sorozatai, <i>például</i> egy <abbr>HTML</abbr> dokumentum.
<li>A <b>bájtok</b> és <b>bájttömbök</b>, <i>például</i> egy <abbr>JPEG</abbr> képfájl.
<li>A <b>listák</b> értékek rendezett sorozatai.
<li>A <b>tuple</b>-ök értékek rendezett, nem módosítható sorozatai.
<li>A <b>halmazok</b> értékek rendezetlen kupacai.
<li>A <b>szótárak</b> kulcs-érték párok rendezetlen kupacai.
</ol>
<p>Természetesen ezeknél több típus van. Pythonban <a
href=your-first-python-program.html#everythingisanobject>minden
objektum</a>, emiatt léteznek <i>modul</i>, <i>függvény</i>,
<i>osztály</i>, <i>metódus</i>, <i>fájl</i> és még <i>lefordított kód</i>
típusok is. Ezek közül néhányat már láttál: <a
href=your-first-python-program.html#runningscripts>a moduloknak nevük
van</a>, <a href=your-first-python-program.html#docstrings>a függvényeknek
<code>docstring-jeik</code></a> <i class=baa>stb.</i> Az osztályokról az
<a href=iterators.html>Osztályok és iterátorok</a> fejezetben, a fájlokról
pedig a <a href=files.html>Fájlok</a> fejezetben fogsz többet megtudni.
<p>A karakterláncok és bájtok elég fontosak&nbsp;&ndash;&nbsp;és elég
bonyolultak&nbsp;&ndash;&nbsp;hogy saját fejezetet kapjanak. Előbb
nézzük a többit.
<p class=a>&#x2042;

<h2 id=booleans>Logikai értékek</h2>
<aside>Gyakorlatilag bármely kifejezést használhatod logikai kontextusban.</aside>
<p>A logikai értékek igazak vagy hamisak lehetnek. A Python két
konstanssal rendelkezik, amelyek közvetlenül <dfn>logikai</dfn> értékekhez
rendelhetők, ezek a <code><dfn>True</dfn></code> és
<code><dfn>False</dfn></code>. A kifejezések is logikai értékekké
értékelődnek ki. Bizonyos helyeken (mint az <code>if</code> utasítások), a
Python a kifejezés logikai értékre való kiértékelődését várja. Ezeket a
helyeket <i>logikai kontextusoknak</i> nevezzük. Gyakorlatilag bármely
kifejezést használhatod logikai kontextusban, és a Python megpróbálja
meghatározni annak igazságértékét. A különböző adattípusok különböző
szabályokkal rendelkeznek arra vonatkozóan, hogy logikai kontextusban mely
értékek számítanak igaznak vagy hamisnak. (A fejezet későbbi konkrét
példáinak tükrében majd jobban fogod látni ennek az értelmét.)
<p>Vegyük például ezt a részletet a <a
href=your-first-python-program.html#divingin><code>humansize.py</code></a>-ból:
<pre class='nd pp'><code>if size &lt; 0:
    raise ValueError('a szám nem lehet negatív')</code></pre>
<p>A <var>size</var> egy egész, a 0 egy egész, és a <code>&lt;</code> egy
numerikus műveleti jel. A <code>size &lt; 0</code> kifejezés eredménye
mindig logikai érték. Ezt te is kipróbálhatod az interaktív Python
parancsértelmezőben:
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>size = 1</kbd>
<samp class=p>>>> </samp><kbd class=pp>size &lt; 0</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>size = 0</kbd>
<samp class=p>>>> </samp><kbd class=pp>size &lt; 0</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>size = -1</kbd>
<samp class=p>>>> </samp><kbd class=pp>size &lt; 0</kbd>
<samp class=pp>True</samp></pre>
<p>Bizonyos, a Python 2-ből örökölt problémák miatt a logikai értékek
számokként kezelhetők. A <code>True</code> <code>1</code>; a
<code>False</code> 0.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>True + True</kbd>
<samp class=pp>2</samp>
<samp class=p>>>> </samp><kbd class=pp>True - False</kbd>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>True * False</kbd>
<samp class=pp>0</samp>
<samp class=p>>>> </samp><kbd class=pp>True / False</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
ZeroDivisionError: int division or modulo by zero</samp></pre>
<p>Jaj, jaj, jaj! Ezt ne csináld. Azt is felejtsd el, hogy szóba hoztam.

<p class=a>&#x2042;

<h2 id=numbers>Számok</h2>
<p>A számok izgalmasak. Olyan sok van belőlük! A Python támogatja mind az
<dfn>egész</dfn>, mind a <dfn>lebegőpontos</dfn> számokat. A
megkülönböztetésükhöz nincs típusdeklaráció, a Python a
<dfn>tizedespont</dfn> jelenléte vagy hiánya alapján tesz különbséget.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>type(1)</kbd>                 <span class=u>&#x2460;</span></a>
<samp class=pp>&lt;class 'int'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>isinstance(1, int)</kbd>      <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1 + 1</kbd>                   <span class=u>&#x2462;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1 + 1.0</kbd>                 <span class=u>&#x2463;</span></a>
<samp class=pp>2.0</samp>
<samp class=p>>>> </samp><kbd class=pp>type(2.0)</kbd>
<samp class=pp>&lt;class 'float'></samp></pre>
<ol>
<li>A <code>type()</code> függvény használatával ellenőrizheted
bármely érték vagy változó típusát. Ahogy az várható, az <code>1</code>
egy <code>int</code> (egész).
<li>Hasonlóan az <code>isinstance()</code> függvény használatával
ellenőrizheted, hogy egy érték vagy változó adott típusú-e.
<li>Egy <code>int</code> és egy másik <code>int</code> összeadásának
eredménye is egy <code>int</code>.
<li>Egy <code>int</code> hozzáadása egy <code>float</code>-hoz
 <code>float</code> (lebegőpontos) típust eredményez. A Python az
<code>int</code> értéket <code>float</code>-típusúvá konvertálja az
összeadás végrehajtásához, majd eredményként egy <code>float</code>-ot ad
vissza.
</ol>
<h3 id=number-coercion>Egészek lebegőpontossá konvertálása és fordítva</h3>
<p>Ahogy az imént láttad, egyes operátorok (mint az összeadás) szükség
esetén az egészeket lebegőpontos számokká konvertálja. Ezt a
típuskényszerítést te is elvégezheted.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>float(2)</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>2.0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>int(2.0)</kbd>                <span class=u>&#x2461;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>int(2.5)</kbd>                <span class=u>&#x2462;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>int(-2.5)</kbd>               <span class=u>&#x2463;</span></a>
<samp class=pp>-2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1.12345678901234567890</kbd>  <span class=u>&#x2464;</span></a>
<samp class=pp>1.1234567890123457</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(1000000000000000)</kbd>  <span class=u>&#x2465;</span></a>
<samp class=pp>&lt;class 'int'></samp></pre>
<ol>
<li>A <code>float()</code>  függvény hívásásával kifejezetten
<code>float</code> típusúvá konvertálhatsz egy <code>int</code>-et.
<li>Nem meglepő módon, az <code>int()</code> hívásával egy
<code>float</code> <code>int</code>-té konvertálható.
<li>Az <code>int()</code> függvény csonkol, nem kerekít.
<li>Az <code>int()</code> függvény a negatív számokat 0 felé
csonkolja. Ez egy valódi csonkítás függvény, nem pedig alsó egészrész.
<li>A lebegőpontos számok 15 tizedesjegy pontosságúak.
<li>Az egészek tetszőlegesen nagyok lehetnek.
</ol>
<blockquote class='note compare python2'>
<p><span class=u>&#x261E;</span>A Python 2 megkülönbözette az
<code>int</code> és <code>long</code> egészeket. Az <code>int</code>
adattípust a <code>sys.maxint</code> korlátozta, amely platformonként
változott, de általában <code>2<sup>32</sup>-1</code> volt. A Python 3
csak egy egész típussal rendelkezik, amely nagyrészt úgy viselkedik, mint
a Python 2 régi <code>long</code> típusa. A részletekért lásd a <a
href=http://www.python.org/dev/peps/pep-0237><abbr>PEP</abbr> 237</a>-et.
</blockquote>
<h3 id=common-numerical-operations>Általános numerikus műveletek</h3>
<p>A számokkal mindenféle dolgokat csinálhatsz.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>11 / 2</kbd>      <span class=u>&#x2460;</span></a>
<samp class=pp>5.5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11 // 2</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>&minus;11 // 2</kbd>    <span class=u>&#x2462;</span></a>
<samp class=pp>&minus;6</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11.0 // 2</kbd>   <span class=u>&#x2463;</span></a>
<samp class=pp>5.0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11 ** 2</kbd>     <span class=u>&#x2464;</span></a>
<samp class=pp>121</samp>
<a><samp class=p>>>> </samp><kbd class=pp>11 % 2</kbd>      <span class=u>&#x2465;</span></a>
<samp class=pp>1</samp>
</pre>
<ol>
<li>A <code>/</code> operátor lebegőpontos osztást végez. Akkor is
<code>float</code> típusú eredményt ad, ha a számláló és a nevező is
<code>int</code>.
<li>A <code>//</code> operátor egy fura egészosztást végez. Ha az eredmény
pozitív, akkor veheted úgy, hogy 0 tizdesjegyre csonkít (nem kerekít), de
legyél óvatos vele.
<li>Negatív számok egészosztásakor a <code>//</code> operátor
&#8222;felfelé&#8221; kerekít a legközelebbi egészre. Matematikailag nézve
&#8222;lefelé&#8221; kerekít, mivel a <code>&minus;6</code> kisebb, mint
<code>&minus;5</code>, de becsaphat, ha azt várod, hogy
<code>&minus;5</code>-re csonkít.
<li>A <code>//</code> operátor nem mindig ad vissza egészet. Ha a
számláló vagy a nevező <code>float</code>, akkor is a legközelebbi egészre
csonkít, de a tényleges visszatérési érték egy <code>float</code> lesz.
<li>A <code>**</code> operátor &#8222;hatványozást&#8221; jelent.
<code>11<sup>2</sup></code> = <code>121</code>.
<li>A <code>%</code> operátor megadja a maradékot egészosztás után. A
<code>11</code> osztva <code>2</code>-vel <code>5</code>, a maradék
<code>1</code>, így az eredmény <code>1</code>.
</ol>
<blockquote class='note compare python2'>
<p><span class=u>&#x261E;</span>Python 2-ben a <code>/</code> operátor
általában egészosztást jelentett, de egy speciális utasítás beszúrásával
rávehető volt lebegőpontos osztásként való viselkedésre is. Python 3-ban
a <code>/</code> operátor mindig lebegőpontos osztást jelent. A
részletekért lásd a <a
href=http://www.python.org/dev/peps/pep-0238/><abbr>PEP</abbr> 238</a>-at.
</blockquote>
<h3 id=fractions>Törtek</h3>
<p>A Python nem csak egész és lebegőpontos számokat kezel, de el tudja
végezni a középiskolában tanult (és azonnal elfelejtett) elegáns
műveleteket is.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import fractions</kbd>              <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>x = fractions.Fraction(1, 3)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>x</kbd>
<samp class=pp>Fraction(1, 3)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>x * 2</kbd>                         <span class=u>&#x2462;</span></a>
<samp class=pp>Fraction(2, 3)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>fractions.Fraction(6, 4)</kbd>      <span class=u>&#x2463;</span></a>
<samp class=pp>Fraction(3, 2)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>fractions.Fraction(0, 0)</kbd>      <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "fractions.py", line 96, in __new__
    raise ZeroDivisionError('Fraction(%s, 0)' % numerator)
ZeroDivisionError: Fraction(0, 0)</samp></pre>
<ol>
<li>A törtek használatának elkezdéséhez importáld a <code>fractions</code>
modult.
<li>Tört definiálásához hozz létre egy <code>Fraction</code> objektumot,
és add át a számlálót és nevezőt.
<li>A törtekkel végrehajthatod a szokásos matematikai műveleteket. A
műveletek egy új <code>Fraction</code> objektumot adnak vissza. <code>2 * (1/3) = (2/3)</code>
<li>A <code>Fraction</code> objektum automatikusan egyszerűsíti a
törteket. <code>(6/4) = (3/2)</code>
<li>A Pythonnak van annyi esze, hogy ne hozzon létre nulla nevezőjű törteket.
</ol>
<h3 id=trig>Trigonometria</h3>
<p>Pythonban alapszintű trigonometriai számításokat is végezhetsz.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>math.pi</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>3.1415926535897931</samp>
<a><samp class=p>>>> </samp><kbd class=pp>math.sin(math.pi / 2)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>1.0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>math.tan(math.pi / 4)</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>0.99999999999999989</samp></pre>
<ol>
<li>A <code>math</code> modul rendelkezik egy &pi; konstanssal, amely a
kör kerületének és átmérőjének aránya.
<li>A <code>math</code> modul rendelkezik az összes alapszintű
trigonometriai függvénnyel, beleértve a <code>sin()</code>,
<code>cos()</code>, <code>tan()</code> és ezek változatait, mint az
<code>asin()</code>.
<li>Ne feledd azonban, hogy a Python pontossága nem végtelen. A
<code>tan(&pi; / 4)</code> eredményének <code>1.0</code>-nak kellene
lennie, nem <code>0.99999999999999989</code>-nek.
</ol>
<h3 id=numbers-in-a-boolean-context>Számok logikai kontextusban</h3>
<aside>A nulla értékek hamisak, a nem nulla értékek igazak. </aside>
<p><a href=#booleans>Logikai kontextusban</a>, például <code>if</code>
utasításokban használhatsz számokat. A nulla értékek hamisak, a
nem-nulla értékek pedig igazak.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>def is_it_true(valami):</kbd>               <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd class=pp>  if valami:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("igen, ez igaz")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("nem, ez hamis")</kbd> <samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(1)</kbd>                         <span class=u>&#x2461;</span></a>
<samp>igen, ez igaz</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(-1)</kbd>
<samp>igen, ez igaz</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(0)</kbd>
<samp>nem, ez hamis</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(0.1)</kbd>                       <span class=u>&#x2462;</span></a>
<samp>igen, ez igaz</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(0.0)</kbd>
<samp>nem, ez hamis</samp>
<samp class=p>>>> </samp><kbd class=pp>import fractions</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(fractions.Fraction(1, 2))</kbd>  <span class=u>&#x2463;</span></a>
<samp>igen, ez igaz</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(fractions.Fraction(0, 1))</kbd>
<samp>nem, ez hamis</samp></pre>
<ol>
<li>Tudtad, hogy az interaktív Python parancsértelmezőben is definiálhatsz
saját függvényeket? Csak nyomd meg az <kbd>ENTER</kbd>-t az egyes sorok
végén, a befejezéshez pedig egy üres sorban nyomd meg az
<kbd>ENTER</kbd>-t.
<li>Logikai kontextusban a nem nulla egészek igazak, a 0 hamis.
<li>A nem nulla lebegőpontos számok igazak, a <code>0.0</code> hamis. Légy
óvatos ezzel! Ha a legkisebb kerekítési hiba is előfordul (nem lehetetlen,
mint azt az előző szakaszban láttad), akkor a Python a
<code>0.0000000000001</code>-et fogja tesztelni a 0 helyett, és
<code>True</code> értéket ad.
<li>Törtek is használhatók logikai kontextusban. A <code>Fraction(0,
n)</code> hamis minden <var>n</var> értékre. Minden más tört igaz.
</ol>
<p class=a>&#x2042;

<h2 id=lists>Listák</h2>
<p>A list a Python igásló adattípusa. Amikor azt mondom,
&#8222;<dfn>lista</dfn>&#8221;, azt gondolhatod: &#8222;olyan
tömb, amelyet előre kell deklarálni, csak azonos típusú elemeket
tartalmazhat, <i class=baa>stb</i>&#8221;. Ne gondold. A listák ennél
sokkal menőbbek.
<blockquote class='note compare perl5'>
<p><span class=u>&#x261E;</span>A lista Pythonban olyan, mint egy tömb
Perl 5-ben. Perl 5-ben a tömböket tároló változók a <code>@</code>
karakterrel kezdődnek, Pythonban a változók tetszőleges nevűek lehetnek,
és a Python maga tartja nyilván az adattípust.
</blockquote>
<blockquote class='note compare java'>
<p><span class=u>&#x261E;</span>Python listái sokkal többet tudnak, mint a
Java tömbök (de úgy is használhatod, ha ez minden vágyad). Jobban hasonlít
az <code>ArrayList</code> osztályhoz, amely tetszőleges objektumokat képes
tárolni, és dinamikusan tud bővülni az új elemek hozzáadásakor.
</blockquote>
<h3 id=creatinglists>Lista létrehozása</h3>
<p>A listák létrehozása egyszerű: tedd szögletes zárójelbe az értékek
vesszőkkel elválasztott listáját.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'mpilgrim', 'z', 'example']</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'mpilgrim', 'z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[0]</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>'a'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[4]</kbd>                                        <span class=u>&#x2462;</span></a>
<samp class=pp>'example'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[-1]</kbd>                                       <span class=u>&#x2463;</span></a>
<samp class=pp>'example'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[-3]</kbd>                                       <span class=u>&#x2464;</span></a>
<samp class=pp>'mpilgrim'</samp></pre>
<ol>
<li>Először egy öt elemű listát adsz meg. Ne feledd, hogy ezek megtartják
az eredeti sorrendjüket. Ez nem véletlen. A lista elemek rendezett
halmaza.
<li>A lista használható nullával kezdődően indexelt tömbként. A nem üres lista első eleme mindig <code>a_list[0]</code>.
<li>Ezen öt elemű lista utolsó eleme az <code>a_list[4]</code>, mert a
listaelemek indexelése mindig nullától kezdődik.
<li>A negatív index az elemeket a lista végétől visszafelé számolva éri
el. A nem üres lista utolsó eleme mindig az <code>a_list[-1]</code>.
<li>Ha negatív index zavaró, akkor képzeld el így:
<code>a_list[-<var>n</var>] == a_list[len(a_list) - <var>n</var>]</code>. 
Ebben a listában <code>a_list[-3] == a_list[5 - 3] == a_list[2]</code>.
</ol>
<h3 id=slicinglists>Lista szeletelése</h3>
<aside>Az a_list[0] az a_list első eleme.</aside>
<p>Miután definiáltál egy listát, bármely részét megkaphatod új listaként. Ezt
a lista <i>szeletelésének</i> nevezzük.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'mpilgrim', 'z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[1:3]</kbd>            <span class=u>&#x2460;</span></a>
<samp class=pp>['b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[1:-1]</kbd>           <span class=u>&#x2461;</span></a>
<samp class=pp>['b', 'mpilgrim', 'z']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[0:3]</kbd>            <span class=u>&#x2462;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[:3]</kbd>             <span class=u>&#x2463;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[3:]</kbd>             <span class=u>&#x2464;</span></a>
<samp class=pp>['z', 'example']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[:]</kbd>              <span class=u>&#x2465;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim', 'z', 'example']</samp></pre>
<ol>
<li>Egy lista &#8222;szeletnek&#8221; nevezett bármely részét megkaphatod
két index megadásával. A visszatérési érték egy új lista, amely a lista
minden elemét tartalmazza az első szeletindextől (ebben az esetben
<code>a_list[1]</code>) kezdve a második szeletindexig (ebben az esetben
<code>a_list[3]</code>), de azt nem beleértve.
<li>A szeletelés akkor is működik, ha az egyik vagy mindkét szeletindex
negatív. Ha ez segít, akkor így is tekintheted: a listát balról jobbra
olvasva az első szeletindex megadja az első elemet, amit akarsz, a második
szeletindex pedig megadja az első elemet, amit már nem akarsz. A
visszatérési érték a kettő között minden.
<li>A listák indexelése nullától kezdődik, így az <code>a_list[0:3]</code>
a lista első három elemét adja vissza az <code>a_list[0]</code> elemtől az
<code>a_list[3]</code> elemig, de az utóbbit már nem tartalmazza.
<li>Ha a bal oldali szeletindex a 0, akkor kihagyható, és a Python a 0-t
feltételezi. Így az <code>a_list[:3]</code> ugyanaz, mint az
<code>a_list[0:3]</code> mert a kezdő 0-t a Python feltételezi.
<li>Hasonlóan, ha a jobb oldali szeletindex az utolsó elem indexe, akkor
kihagyható. Így az <code>a_list[3:]</code> ugyanaz, mint az
<code>a_list[3:5]</code>, mert ez a lista öt elemű. Van itt egy kellemes
szimmetria. Ebben az öt elemű listában az <code>a_list[:3]</code>
visszaadja az első 3 elemet, az <code>a_list[3:]</code> pedig az utolsó
két elemet. Tulajdonképpen az <code>a_list[:<var>n</var>]</code>
mindig az első <var>n</var> elemet adja vissza, az
<code>a_list[<var>n</var>:]</code> pedig a többit, a lista hosszától
függetlenül.
<li>Ha mindkét szeletindex kimarad, akkor a lista minden elemét
tartalmazni fogja az új lista. De ez nem azonos az eredeti
<var>a_list</var> változóval. Ez egy új lista, amely ugyanazokkal az
elemekkel rendelkezik. Az <code>a_list[:]</code> a lista teljes
lemásolására használható.
</ol>
<h3 id=extendinglists>Elemek felvétele a listába</h3>
<p>Négy módon lehet elemeket felvenni a listába.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = a_list + [2.0, 3]</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_list</kbd>                        <span class=u>&#x2461;</span></a>
<samp class=pp>['a', 2.0, 3]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.append(True)</kbd>           <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 2.0, 3, True]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.extend(['négy', '&Omega;'])</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 2.0, 3, True, 'négy', '&Omega;']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.insert(0, '&Omega;')</kbd>         <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['&Omega;', 'a', 2.0, 3, True, 'négy', '&Omega;']</samp></pre>
<ol>
<li>A <code>+</code> operátor összefűzi a listákat, ezzel létrehozva egy
új listát. Egy lista tetszőleges számú elemet tartalmazhat; nincs
méretkorlát (az elérhető memórián kívül). Ha azonban a memóriahasználat
fontos szempont, akkor tudnod kell, hogy a listaösszefűzés egy második
listát hoz létre a memóriában. Ebben az esetben az új lista azonnal
hozzárendelődik a meglévő <var>a_list</var> változóhoz. Így ez a kódsor
igazából egy kétlépéses folyamat&nbsp;&ndash;&nbsp;összefűzés, majd
hozzárendelés&nbsp;&ndash;&nbsp;amely (ideiglenesen) rengeteg memóriát tud
használni, ha nagy listákkal dolgozol.
<li>Egy lista tetszőleges adattípusú elemeket tartalmazhat, és egy adott
lista elemeinek nem kell azonos típusúaknak lenniük. Ez a lista egy
karakterláncot, egy lebegőpontos számot és egy egészet tartalmaz.
<li>Az <code>append()</code> metódus egy elemet ad a lista végéhez. (Most
már <em>négy</em> különböző adattípus van a listában!)
<li>A listák osztályokként vannak megvalósítva. Egy
lista &#8222;létrehozása&#8221; valójában egy osztály példányosítása. Mint
ilyen, a lista rendelkezik rajta műveleteket végző metódusokkal. Az
<code>extend()</code> metódus egy argumentumot vár, amely egy lista, és az
argumentum minden elemét hozzáfűzi az eredeti listához.
<li>Az <code>insert()</code> metódus egyetlen elemet szúr be a listába. Az
első argumentum a lista első olyan elemének indexe, amely ki lesz mozdítva
a pozícójából. A lista elemeinek nem kell egyedieknek lenniük, most például
két külön <code>'&Omega;'</code> értékű elem van a listában: az első elem
(<code>a_list[0]</code>) és az utolsó elem (<code>a_list[6]</code>).
</ol>

<blockquote class='note compare perl'>
<p><span class=u>&#x261E;</span>Az <code><var>a_list</var>.insert(0,
<var>érték</var>)</code> olyan, mint az <code>unshift()</code> függvény
Perlben. Felvesz egy elemet a lista elejére, és az összes többi elem
indexe megnő eggyel, hogy helyet csináljanak az új elemnek.
</blockquote>

<p>Nézzük meg közelebbről az <code>append()</code> és <code>extend()</code> közti különbséget.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'c']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.extend(['d', 'e', 'f'])</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'c', 'd', 'e', 'f']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_list)</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>6</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list[-1]</kbd>
<samp class=pp>'f'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.append(['g', 'h', 'i'])</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'c', 'd', 'e', 'f', ['g', 'h', 'i']]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_list)</kbd>                     <span class=u>&#x2463;</span></a>
<samp class=pp>7</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list[-1]</kbd>
<samp class=pp>['g', 'h', 'i']</samp></pre>
<ol>
<li>Az <code>extend()</code> metódus egyetlen argumentumot vár, amely
mindig egy lista, és ennek a listának minden elemét hozzáfűzi az
<var>a_list</var> listához.
<li>Ha egy három elemű listával indulsz, és kiterjeszted egy újabb három
elemet tartalmazó listával, akkor egy hat elemű listát kapsz.
<li>Másrészt, az <code>append()</code> metódus egyetlen argumentumot
vár, amely tetszőleges adattípusú lehet. Itt az <code>append()</code>
metódust egy három elemű listával hívod meg.
<li>Ha egy hat elemű listával indulsz, és az append() használatával
hozzáfűzöl egy listát, akkor... egy hét elemű listát kapsz. Miért hét? 
Mert az imént hozzáfűzött utolsó elem <em>maga is egy lista</em>. A listák
tetszőleges típusú adatokat tartalmazhatnak, beleértve más listákat is. 
Lehet, hogy néha ezt akarod, lehet hogy néha nem. De ezt kérted, ezt
kapod.
</ol>
<h3 id=searchinglists>Értékek keresése egy listában</h3>
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'új', 'mpilgrim', 'új']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.count('új')</kbd>        <span class=u>&#x2460;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'új' in a_list</kbd>            <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>'c' in a_list</kbd>
<samp class=pp>False</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.index('mpilgrim')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>3</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.index('új')</kbd>        <span class=u>&#x2463;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.index('c')</kbd>         <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
ValueError: list.index(x): x not in list</samp></pre>
<ol>
<li>Ahogy az várható, a <code>count()</code> metódus visszaadja egy lista
adott értékeinek előfordulásainak számát.
<li>Ha csak azt szeretnéd tudni, hogy egy elem szerepel-e a listában vagy
sem, akkor az <code>in</code> operátor kicsit gyorsabb, mint a
<code>count()</code> metódus. Az <code>in</code> operátor mindig a
<code>True</code> vagy <code>False</code> értéket adja vissza, azt nem
adja meg, hogy az érték hányszor jelenik meg a listában.
<li>Az <code>in</code> operátor és a <code>count()</code> metódus sem adja
meg, hogy az érték <em>hol</em> jelenik meg a listában. Ha szeretnéd
tudni, hogy a listában hol van egy érték, akkor használd
az <code>index()</code> metódust. A Python alapértelmezésben az egész
listában keres, noha megadhatsz egy elhagyható második argumentumot, a
keresés kezdő indexét, sőt egy elhagyható harmadik argumentumot is, a
keresés befejező indexét (mindkettő nullától kezdődik).
<li>Az <code>index()</code> metódus az érték <em>első</em> előfordulását
találja meg a listában. Ebben az esetben az <code>'új'</code> kétszer
fordul elő a listában, az <code>a_list[2]</code> és <code>a_list[4]</code>
elemekként, de az <code>index()</code> metódus csak az első előfordulás
indexét adja vissza.
<li>Ahogy azt <em>nem</em> várnád, ha az elem nem található meg a
listában, akkor az <code>index()</code> metódus kivételt dob.
</ol>

<p>Várjunk csak? Így van: az <code>index()</code> metódus kivételt dob, ha
nem találja az értéket a listában. Ez látványosan eltér a legtöbb
nyelvtől, amelyek általában érvénytelen indexet (mint a <code>-1</code>)
adnak vissza. Noha ez elsőre idegesítőnek tűnhet, szerintem idővel
értékelni fogod. Ez azt jelenti, hogy a programod a probléma forrásánál
fog összeomlani, nem pedig később furán és némán. Ne feledd, <a
href=#creatinglists>a <code>-1</code> egy érvényes listaindex</a>. Ha az
<code>index()</code> metódus <code>-1</code>-et adna vissza, az jónéhány,
nem túl vidám hibakeresési körhöz vezethetne!

<h3 id=removingfromlists>Elemek eltávolítása a listából</h3>

<aside>A listákban soha nincsenek lyukak.</aside>

<p>A listák képesek automatikusan bővülni és szűkülni. A bővülés
részt már láttad. Az elemek listából való eltávolítására is számos
különböző módszer van.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'új', 'mpilgrim', 'új']</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_list[1]</kbd>
<samp class=pp>'b'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>del a_list[1]</kbd>         <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'új', 'mpilgrim', 'új']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list[1]</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>'új'</samp></pre>
<ol>
<li>A lista adott elemének törlésére a <code><dfn>del</dfn></code>
utasítás használható.
<li>Az <code>1</code>-es index elérése az <code>1</code>-es index törlése
után <em>nem</em> eredményez hibát. Minden, a törölt elem utáni elem
eltolja a helyzeti indexét az elem törlésével létrejött &#8222;lyuk
kitöltéséhez&#8221;.
</ol>

<p>Nem ismered a helyzeti indexet? Nem gond, az elemeket érték alapján is
eltávolíthatod.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.remove('új')</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'mpilgrim', 'új']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.remove('új')</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'mpilgrim']</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list.remove('új')</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
ValueError: list.remove(x): x not in list</samp></pre>
<ol>
<li>Egy elemet a listából a <code>remove()</code> metódussal is
eltávolíthatsz. A <code>remove()</code> metódus egy <em>értéket</em> vár,
és eltávolítja az adott érték első előfordulását a listából. Ismét, a
törölt elem mögötti elemek helyzeti indexe csökkenni fog, hogy
&#8222;kitöltsék a lyukat&#8221;. A listákban soha nincsenek lyukak.
<li>A <code>remove()</code> metódust annyiszor hívhatod, ahányszor csak
akarod, de kivételt fog dobni, ha a listában nem szereplő értéket próbálsz
eltávolítani.
</ol>

<h3 id=popgoestheweasel>Elemek eltávolítása a listából: tiszteletkör</h3>

<p>Egy másik érdekes metódus a <code>pop()</code>. A <code>pop()</code>
metódus egy újabb lehetőség <a href=#removingfromlists>elemek
eltávolítására egy listából</a>, de van benne egy csavar.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'új', 'mpilgrim']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>'mpilgrim'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'b', 'új']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.pop(1)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'b'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['a', 'új']</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>
<samp class=pp>'új'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>
<samp class=pp>'a'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list.pop()</kbd>   <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
IndexError: pop from empty list</samp></pre>
<ol>
<li>Ha argumentumok nélkül hívod, a <code>pop()</code> listametódus
eltávolítja a utolsó elemet a listából, <em>és visszaadja az eltávolított
értéket</em>.
<li>A lista tetszőleges elemére is meghívhatod a pop() metódust. Csak adj át egy helyzeti
indexet a <code>pop()</code> metódusnak. Ekkor
eltávolítja az elemet, az azt követő összes elemet elmozgatja &#8222;a
lyuk kitöltéséhez&#8221;, és visszaadja az eltávolított értéket.
<li>A <code>pop()</code> üres listán való hívásakor kivételt dob.
</ol>

<blockquote class='note compare perl'>
<p><span class=u>&#x261E;</span>A <code>pop()</code> listametódus
argumentumok nélküli hívása olyan, mint a <code>pop()</code> függvény
Perlben. Eltávolítja a lista utolsó elemét, és visszaadja az eltávolított
elem értékét. A Perl egy másik, <code>shift()</code> nevű függvénnyel is
rendelkezik, amely eltávolítja az első elemet, és visszaadja az értékét.
Pythonban ez egyenlő az <code><var>a_list</var>.pop(0)</code> hívással.
</blockquote>

<h3 id=lists-in-a-boolean-context>Listák logikai kontextusban</h3>
<aside>Az üres listák hamisak, minden más lista igaz.</aside>
<p><a href=#booleans>Logikai kontextusban</a>, például <code>if</code>
utasításokban használhatsz listákat is. <pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(valami):</kbd>
<samp class=p>... </samp><kbd class=pp>  if valami:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("igen, ez igaz")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("nem, ez hamis")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true([])</kbd>             <span class=u>&#x2460;</span></a>
<samp>nem, ez hamis</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(['a'])</kbd>          <span class=u>&#x2461;</span></a>
<samp>igen, ez igaz</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true([False])</kbd>        <span class=u>&#x2462;</span></a>
<samp>igen, ez igaz</samp></pre>
<ol>
<li>Logikai kontextusban az üres lista hamis.
<li>Egy legalább egy elemű lista igaz.
<li>Egy legalább egy elemű lista igaz. Az elemek értéke lényegtelen.
</ol>

<p class=a>&#x2042;

<h2 id=tuples>Tuple-ök</h2>

<p>A <dfn>tuple</dfn> egy megváltoztathatatlan lista. A tuple létrehozása után semmilyen módon sem módosítható.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple = ("a", "b", "mpilgrim", "z", "példa")</kbd>    <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_tuple</kbd>
<samp class=pp>('a', 'b', 'mpilgrim', 'z', 'példa')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple[0]</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>'a'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple[-1]</kbd>                                       <span class=u>&#x2462;</span></a>
<samp class=pp>'példa'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple[1:3]</kbd>                                      <span class=u>&#x2463;</span></a>
<samp class=pp>('b', 'mpilgrim')</samp></pre>
<ol>
<li>A tuple ugyanúgy definiálható, mint egy lista, kivéve hogy az elemek
halmaza zárójelek és nem szögletes zárójelek közt van.
<li>Egy tuple elemeinek meghatározott sorrendje van, mint a listák esetén. A
tuple indexei nullától kezdődnek, mint a listák esetén, így egy nem üres
tuple első eleme mindig <code>a_tuple[0]</code>.
<li>A negatív indexek a tuple végétől számítódnak, mint a listák esetén.
<li>A szeletelés is működik, mint a listák esetén. Lista szeletelésekor
egy új listát kapsz, tuple szeletelésekor egy új tuple-t.
</ol>

<p>A tuple és a lista közti legnagyobb különbség, hogy a tuple nem
módosítható. Technikai kifejezéssel élve a tuple-ök
<dfn>megváltoztathatatlanok</dfn>. Gyakorlati szempontból nincsenek olyan
metódusaik, amelyek lehetővé tennék a módosításukat. A listák rendelkeznek
olyan metódusokkal, mint az <code>append()</code>, <code>extend()</code>,
<code>insert()</code>, <code>remove()</code> és <code>pop()</code>. A
tuple-ök ezek egyikével sem. A tuple szeletelhető (mert az egy új tuple-t
hoz létre), és ellenőrizheted, hogy egy tuple tartalmaz-e egy adott
értéket (mert ez nem változtatja meg a tuple-t), és ez minden.
<pre class=screen>
# az előző példa folytatása
<samp class=p>>>> </samp><kbd class=pp>a_tuple</kbd>
<samp class=pp>('a', 'b', 'mpilgrim', 'z', 'példa')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple.append("új")</kbd>                   <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
AttributeError: 'tuple' object has no attribute 'append'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple.remove("z")</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (innermost last):
  File "&lt;interactive input>", line 1, in ?
AttributeError: 'tuple' object has no attribute 'remove'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_tuple.index("példa")</kbd>                 <span class=u>&#x2462;</span></a>
<samp class=pp>4</samp>
<a><samp class=p>>>> </samp><kbd class=pp>"z" in a_tuple</kbd>                         <span class=u>&#x2463;</span></a>
<samp class=pp>True</samp>
</pre>
<ol>
<li>Nem adhatsz elemeket a tuple-höz. A tuple-ök nem rendelkeznek
<code>append()</code> vagy <code>extend()</code> metódussal.
<li>Nem távolíthatsz el elemeket egy tuple-ből. A tuple-ök nem rendelkeznek
<code>remove()</code> vagy <code>pop()</code> metódussal.
<li><em>Megkereshetsz</em> elemeket a tuple-ben, mivel ez nem módosítja a tuple-t.
<li>Használhatod az <code>in</code> operátort is egy elem meglétének
ellenőrzésére a tuple-ben.
</ol>

<p>Akkor mire jók a tuple-ök?</p> 

<ul> 
<li>A tuple-ök gyorsabbak a listáknál. Ha értékek konstans halmazát
definiálod, és a végighaladáson kívül semmit sem akarsz vele csinálni,
akkor használj tuple-t a lista helyett.
<li>A kódot biztonságosabbá teszi, ha a nem módosítandó adatokat
&#8222;írásvédetté&#8221; teszed. A tuple használata lista helyett olyan,
mintha egy közvetett <code>assert</code> utasításod lenne, amely jelzi,
hogy ezek az adatok konstansak, és külön elhatározás (és egy bizonyos
függvény) szükséges a felülbírálásához.
<li>Egyes tuple-ök használhatók szótárkulcsokként (konkrétan olyan tuple-ök,
amelyek <i>megváltoztathatatlan</i> értékeket, például karakterláncokat,
számokat és más tuple-öket tartalmaznak). A listák soha nem használhatók
szótárkulcsokként, mivel a listák megváltoztathatók.
</ul>

<blockquote class=note>
<p><span class=u>&#x261E;</span>A tuple-ök átalakíthatók listákká, és
fordítva. A beépített <code>tuple()</code> függvény egy listát vár, és
visszaad egy tuple-t ugyanazokkal az elemekkel, a <code>list()</code>
függvény pedig egy tuple-t vár és listát ad vissza. Gyakorlatilag a
<code>tuple()</code> befagyasztja a listát, a <code>list()</code> pedig
kiolvasztja.
</blockquote>

<h3 id=tuples-in-a-boolean-context>Tuple-ök logikai kontextusban</h3>

<p><a href=#booleans>Logikai kontextusban</a>, például <code>if</code>
utasításokban használhatsz tuple-öket is. <pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(valami):</kbd>
<samp class=p>... </samp><kbd class=pp>  if valami:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("igen, ez igaz")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("nem, ez hamis")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(())</kbd>             <span class=u>&#x2460;</span></a>
<samp>nem, ez hamis</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(('a', 'b'))</kbd>     <span class=u>&#x2461;</span></a>
<samp>igen, ez igaz</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true((False,))</kbd>       <span class=u>&#x2462;</span></a>
<samp>igen, ez igaz</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type((False))</kbd>              <span class=u>&#x2463;</span></a>
<samp class=pp>&lt;class 'bool'></samp>
<samp class=p>>>> </samp><kbd class=pp>type((False,))</kbd>
<samp class=pp>&lt;class 'tuple'></samp></pre>
<ol>
<li>Logikai kontextusban az üres tuple hamis.
<li>Egy legalább egy elemű tuple igaz.
<li>Egy legalább egy elemű tuple igaz. Az elemek értéke lényegtelen. De mit csinál ott az a vessző?
<li>Egy egy elemű tuple létrehozásához vesszőt kell tennie az érték után. 
A vessző nélkül a Python azt feltételezi, hogy egy extra pár zárójelet
tettél ki, ami ártalmatlan, de nem hoz létre tuple-t.
</ol>

<h3 id=multivar>Több érték hozzárendelése egyszerre</h3>

<p>Itt egy menő programozási trükk: Pythonban egy tuple használatával
egyszerre több értéket is hozzárendelhetsz változókhoz.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>v = ('a', 2, True)</kbd>
<a><samp class=p>>>> </samp><kbd>(x, y, z) = v</kbd>       <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>x</kbd>
<samp class=pp>'a'</samp>
<samp class=p>>>> </samp><kbd class=pp>y</kbd>
<samp class=pp>2</samp>
<samp class=p>>>> </samp><kbd class=pp>z</kbd>
<samp class=pp>True</samp></pre>
<ol>
<li>A <var>v</var> egy három elemű tuple, az <code>(x, y, z)</code> pedig
egy három változót tartalmazó tuple. Az egymáshoz rendelésükkel a
<var>v</var> értékei a változókhoz lesznek rendelve, a megadott
sorrendben.
</ol>

<p>Ezt sok mindenre fel lehet használni. Tegyük fel, hogy neveket
szeretnél rendelni egy értéktartományhoz. A beépített <code>range()</code>
függvényt többváltozós értékadásban az egymást követő értékek
hozzárendeléséhez használhatod.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>(HÉTFŐ, KEDD, SZERDA, CSÜTÖRTÖK, PÉNTEK, SZOMBAT, VASÁRNAP) = range(7)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>HÉTFŐ</kbd>                                                                   <span class=u>&#x2461;</span></a>
 <samp class=pp>0</samp>
<samp class=p>>>> </samp><kbd class=pp>KEDD</kbd>
 <samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>VASÁRNAP</kbd>
<samp class=pp>6</samp></pre>
<ol>
<li>A beépített <code>range()</code> függvény egészek sorozatát állítja
elő. (Technikailag a <code>range()</code> függvény egy <a
href=iterators.html>iterátort</a> ad vissza, nem pedig listát vagy
tuple-t, de erről a különbségről később fogsz tanulni.) A
<var>HÉTFŐ</var>, <var>KEDD</var>, <var>SZERDA</var>,
<var>CSÜTÖRTÖK</var>, <var>PÉNTEK</var>, <var>SZOMBAT</var> és
<var>VASÁRNAP</var> a definiált változók. (Ez a példa a
<code>calendar</code> modulból származik, amely naptárakat ír ki, mint a
<code>cal</code> nevű <abbr>UNIX</abbr> program. A <code>calendar</code>
modul egész konstansokat definiál a hét napjaihoz.)
<li>Most minden változó rendelkezik egy értékkel: a <var>HÉTFŐ</var> a 0,
a <var>KEDD</var> <code>1</code> és így tovább.
</ol>

<p>A több érték hozzárendelése használatával olyan függvényeket építhetsz,
amelyek több értéket adnak vissza, egyszerűen az értékeket tartalmazó
tuple visszaadásával. A hívó ezt kezelheti egyetlen tuple-öként vagy
értékeket rendelhet az egyes változókhoz. Sok szabványos Python
függvénytár így tesz, beleértve az <code>os</code> modult, amelyet <a
href=comprehensions.html#os>a következő fejezetben</a> fogsz megismerni.
<p class=a>&#x2042;

<h2 id=sets>Halmazok</h2>

<p>A <dfn>halmaz</dfn> egyedi értékek rendezetlen &#8222;kupaca&#8221;. 
Egy halmaz tetszőleges megváltoztathatatlan adattípusú értékeket
tartalmazhat. Ha van két halmazod, akkor végrehajthatsz rajtuk általános
halmazműveleteket, mint az unió, metszet és különbség.
<h3 id=creating-a-set>Halmaz létrehozása</h3>

<p>Kezdjük az elején. Egy halmazt létrehozni könnyű.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = {1}</kbd>     <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(a_set)</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'set'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2}</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2}</samp></pre>
<ol>
<li>Egy egy értékkel rendelkező halmaz létrehozásához tedd az értéket
kapcsos zárójelek (<code>{}</code>) közé.
<li>A halmazok valójában <a
href=iterators.html#defining-classes>osztályokként</a> vannak
megvalósítva, de emiatt most ne aggódj.
<li>Egy több értékkel rendelkező halmaz létrehozásához vesszőkel válaszd el
az értékeket, és tedd az egészet kapcsos zárójelek közé.
</ol>

<p>Halmazt egy <a href=#lists>listából</a> is létrehozhatsz.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['a', 'b', 'mpilgrim', True, False, 42]</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = set(a_list)</kbd>                           <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_set</kbd>                                         <span class=u>&#x2461;</span></a>
<samp class=pp>{'a', False, 'b', True, 'mpilgrim', 42}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list</kbd>                                        <span class=u>&#x2462;</span></a>
<samp class=pp>['a', 'b', 'mpilgrim', True, False, 42]</samp></pre>
<ol>
<li>Egy listából halmaz létrehozásához használd a <code>set()</code> függvényt. (Azok a pedánsok, akik ismerik a halmazok megvalósítását, rá fognak mutatni, hogy ez valójában nem függvényhívás, hanem egy osztály példányosítása. <em>Megígérem</em>, hogy a könyv hátralévő részeiben meg fogod ismerni a különbséget. Egyelőre elég annyi, hogy a <code>set()</code> függvényszerűen működik, és egy halmazt ad vissza.)
<li>Ahogyan azt korábban említettem, egy halmaz tetszőleges adattípusú értékeket
tartalmazhat. Ahogyan még korábban említettem, a halmazok <em>rendezetlenek</em>. Ez a halmaz nem emlékszik a létrehozásához használt lista eredeti sorrendjére. Ha elemeket adsz a halmazhoz, az nem fog emlékezni a hozzáadás sorrendjére.
<li>Az eredeti lista változatlan.
</ol>

<p id=emptyset>Még nincsenek értékeid? Nem gond. Létrehozhatsz üres halmazt is.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_set = set()</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_set</kbd>            <span class=u>&#x2461;</span></a>
<samp class=pp>set()</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(a_set)</kbd>      <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;class 'set'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_set)</kbd>       <span class=u>&#x2463;</span></a>
<samp class=pp>0</samp>
<a><samp class=p>>>> </samp><kbd class=pp>not_sure = {}</kbd>    <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>type(not_sure)</kbd>
<samp class=pp>&lt;class 'dict'></samp></pre>
<ol>
<li>Üres halmaz létrehozásához hívd meg a <code>set()</code> függvényt argumentumok nélkül.
<li>Az üres halmaz kiírt ábrázolása egy kicsit furcsán néz ki. Talán ezt vártad: <code>{}</code>? Az egy üres szótárat jelölne, nem pedig egy üres halmazt. A szótárakkal a fejezet későbbi részében fogsz megismerkedni.
<li>A furcsa kiírt ábrázolás ellenére <em>ez</em> egy halmaz&hellip;
<li>&hellip;és ennek a halmaznak nincsenek elemei.
<li>A Python 2-ből áthozott örökség miatt nem hozhatsz létre üres halmazt két kapcsos zárójellel. Az egy üres szótárat hozna létre, nem pedig egy üres halmazt.
</ol>

<h3 id=modifying-sets>Halmaz módosítása</h3>

<p>Meglévő halmazhoz két különböző módon adhatsz értékeket: az <code>add()</code> és az <code>update()</code> metódusokkal.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.add(4)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 4}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_set)</kbd>    <span class=u>&#x2461;</span></a>
<samp class=pp>3</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.add(1)</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 4}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(a_set)</kbd>    <span class=u>&#x2463;</span></a>
<samp class=pp>3</samp></pre>
<ol>
<li>Az <code>add()</code> metódus egyetlen argumentumot vár, amely tetszőleges adattípusú lehet, és az adott értéket hozzáadja a halmazhoz.
<li>Ez a halmaz most 3 elemmel rendelkezik.
<li>A halmazok <em>egyedi értékek</em> kupacai. Ha egy már létező értéket próbálsz hozzáadni, akkor nem történik semmi. Nem fog kivételt dobni, csak nem csinál semmit.
<li>A halmaznak <em>továbbra is</em> 3 eleme van.
</ol>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2, 3}</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 3}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.update({2, 4, 6})</kbd>                       <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_set</kbd>                                         <span class=u>&#x2461;</span></a>
<samp class=pp>{1, 2, 3, 4, 6}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.update({3, 6, 9}, {1, 2, 3, 5, 8, 13})</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 3, 4, 5, 6, 8, 9, 13}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.update([10, 20, 30])</kbd>                    <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 2, 3, 4, 5, 6, 8, 9, 10, 13, 20, 30}</samp></pre>
<ol>
<li>Az <code>update()</code> metódus egy argumentumot vár, egy halmazt, és minden elemét hozzáadja az eredeti halmazhoz. Olyan, mintha a halmaz minden egyes elemére meghívtad volna az <code>add()</code> metódust.
<li>A többször szereplő értékek figyelmen kívül maradnak, mivel a halmazok egy értéket csak egyszer tartalmazhatnak.
<li>Az <code>update()</code> metódust ténylegesen tetszőleges számú argumentummal hívhatod meg. Két halmazzal hívva az <code>update()</code> metódus az egyes halmazok összes elemét hozzáadja az eredeti halmazhoz (a többször szereplő értékek eldobásával).
<li>Az <code>update()</code> metódus számos különböző adattípus objektumait képes kezelni, beleértve a listákat is. Egy listával hívva az <code>update()</code> metódus a lista összes elemét hozzáadja az eredeti halmazhoz.
</ol>

<h3 id=removing-from-sets>Elemek eltávolítása a halmazból</h3>

<p>Három módon távolíthatsz el egyedi értékeket a halmazból. Az első kettő, a <code>discard()</code> és <code>remove()</code> között egy apró különbség van.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 3, 6, 10, 15, 21, 28, 36, 45}</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 10, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.discard(10)</kbd>                        <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.discard(10)</kbd>                        <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.remove(21)</kbd>                         <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{1, 3, 36, 6, 45, 15, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.remove(21)</kbd>                         <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
KeyError: 21</samp></pre>
<ol>
<li>A <code>discard()</code> metódus egyetlen értéket vár argumentumként, és eltávolítja azt az értéket a halmazból.
<li>Ha a <code>discard()</code> metódust a halmazban nem létező értékkel hívod, akkor nem csinál semmi. Nem fog kivételt dobni, csak nem csinál semmit.
<li>A <code>discard()</code> metódus is egyetlen értéket vár argumentumként, és szintén eltávolítja azt az értéket a halmazból.
<li>Itt a különbség: ha az érték nem létezik a halmazban, akkor a <code>remove()</code> metódus egy <code>KeyError</code> kivételt dob.
</ol>

<p>A listákhoz hasonlóan a halmazoknak is van <code>pop()</code> metódusuk.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 3, 6, 10, 15, 21, 28, 36, 45}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>                                <span class=u>&#x2460;</span></a>
<samp class=pp>1</samp>
<samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>
<samp class=pp>3</samp>
<samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>
<samp class=pp>36</samp>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{6, 10, 45, 15, 21, 28}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.clear()</kbd>                              <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>set()</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.pop()</kbd>                                <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
KeyError: 'pop from an empty set'</samp></pre>
<ol>
<li>A <code>pop()</code> metódus egyetlen értéket távolít el a halmazból, és visszaadja az értéket. Mivel azonban a halmazok rendezetlenek, nincs &#8222;utolsó&#8221; értékük, így nincs lehetőség az eltávolított érték befolyásolására. Teljesen tetszőleges.
<li>A <code>clear()</code> metódus <em>minden</em> értéket eltávolít a halmazból, és egy üres halmazt hagy. Ez egyenértékű az <code>a_set = set()</code> hívással, amely egy új üres halmazt hoz létre, és az <var>a_set</var> változó korábbi értékét felülírja.
<li>Üres halmazból nem lehet értéket kivenni a pop() metódussal, ez egy <code>KeyError</code> kivételt dob.
</ol>

<h3 id=common-set-operations>Általános halmazműveletek</h3>

<p>A Python <code>set</code> típusa számos általános halmazműveletet támogat.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {2, 4, 5, 9, 12, 21, 30, 51, 76, 127, 195}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>30 in a_set</kbd>                                                     <span class=u>&#x2460;</span></a>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>31 in a_set</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>b_set = {1, 2, 3, 5, 6, 8, 9, 12, 15, 17, 18, 21}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.union(b_set)</kbd>                                              <span class=u>&#x2461;</span></a>
<samp class=pp>{1, 2, 195, 4, 5, 6, 8, 12, 76, 15, 17, 18, 3, 21, 30, 51, 9, 127}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.intersection(b_set)</kbd>                                       <span class=u>&#x2462;</span></a>
<samp class=pp>{9, 2, 12, 5, 21}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.difference(b_set)</kbd>                                         <span class=u>&#x2463;</span></a>
<samp class=pp>{195, 4, 76, 51, 30, 127}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.symmetric_difference(b_set)</kbd>                               <span class=u>&#x2464;</span></a>
<samp class=pp>{1, 3, 4, 6, 8, 76, 15, 17, 18, 195, 127, 30, 51}</samp></pre>
<ol>
<li>Annak teszteléséhez, hogy egy érték eleme-e egy halmaznak, használd az <code>in</code> operátort. Ez ugyanúgy működik, mint a listák esetén.
<li>Az <code>union()</code> metódus egy új halmazt ad vissza, amely tartalmazza az összes, <em>valamelyik</em> halmazban jelen lévő elemet.
<li>Az <code>intersection()</code> metódus egy új halmazt ad vissza, amely tartalmazza az összes, <em>mindkét</em> halmazban jelen lévő elemet.
<li>A <code>difference()</code> metódus egy új halmazt ad vissza, amely tartalmazza az <var>a_set</var> halmazban jelen lévő, de a <var>b_set</var> halmazban jelen nem lévő elemet.
<li>A <code>symmetric_difference()</code> metódus egy új halmazt ad vissza, amely tartalmazza az összes, <em>pontosan egy</em> halmazban jelen lévő elemet.
</ol>

<p>Ezen metódusok közül három szimmetrikus.

<pre class=screen>
# az előző példa folytatása
<a><samp class=p>>>> </samp><kbd class=pp>b_set.symmetric_difference(a_set)</kbd>                                       <span class=u>&#x2460;</span></a>
<samp class=pp>{3, 1, 195, 4, 6, 8, 76, 15, 17, 18, 51, 30, 127}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.symmetric_difference(a_set) == a_set.symmetric_difference(b_set)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.union(a_set) == a_set.union(b_set)</kbd>                                <span class=u>&#x2462;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.intersection(a_set) == a_set.intersection(b_set)</kbd>                  <span class=u>&#x2463;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.difference(a_set) == a_set.difference(b_set)</kbd>                      <span class=u>&#x2464;</span></a>
<samp class=pp>False</samp></pre>
<ol>
<li>Az <var>a_set</var> szimmetrikus különbsége a <var>b_set</var>-től eltérőnek <em>tűnik</em> a <var>b_set</var> és az <var>a_set</var> szimmetrikus különbségétől, de ne feledd, a halmazok rendezetlenek. Bármely két halmaz, amelyek ugyanazokat az elemeket tartalmazzák (és egyikben sincs több), egyenlőnek számít.
<li>Itt pontosan ez történik. Ne hagyd, hogy a Python Shell becsapjon a halmazok kiírt ábrázolásával. Ugyanazokat az értékeket tartalmazzák, emiatt egyenlők.
<li>Két halmaz uniója is szimmetrikus.
<li>Két halmaz metszete is szimmetrikus.
<li>Két halmaz különbsége nem szimmetrikus. Ennek van értelme, hasonló egy szám kivonásához egy másik számból. Az operandusok sorrendje számít.
</ol>

<p>Végül néhány, a halmazokkal kapcsolatos kérdés.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = {1, 2, 3}</kbd>
<samp class=p>>>> </samp><kbd class=pp>b_set = {1, 2, 3, 4}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.issubset(b_set)</kbd>    <span class=u>&#x2460;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>b_set.issuperset(a_set)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_set.add(5)</kbd>             <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_set.issubset(b_set)</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>b_set.issuperset(a_set)</kbd>
<samp class=pp>False</samp></pre>
<ol>
<li>Az <var>a_set</var> a <var>b_set</var> <dfn>részhalmaza</dfn>&nbsp;&ndash;&nbsp;az <var>a_set</var> minden eleme a <var>b_set</var>-nek is eleme.
<li>A kérdést megfordítva a <var>b_set</var> az <var>a_set</var> <dfn>szülőhalmazaxxx</dfn>, mert az <var>a_set</var> elemei a<var>b_set</var>-nek is elemei.
<li>Amint hozzáadsz egy olyan értéket az <var>a_set</var>-hez, amely nincs a <var>b_set</var>-ben, mindkét teszt <code>False</code> értéket ad vissza.
</ol>

<h3 id=sets-in-a-boolean-context>Halmazok logikai kontextusban</h3>

<p><a href=#booleans>Logikai kontextusban</a>, például <code>if</code>
utasításokban használhatsz halmazokat is. <pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(valami):</kbd>
<samp class=p>... </samp><kbd class=pp>  if valami:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("igen, ez igaz")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("nem, ez hamis")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true(set())</kbd>          <span class=u>&#x2460;</span></a>
<samp>nem, ez hamis</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({'a'})</kbd>          <span class=u>&#x2461;</span></a>
<samp>igen, ez igaz</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({False})</kbd>        <span class=u>&#x2462;</span></a>
<samp>igen, ez igaz</samp></pre>
<ol>
<li>Logikai kontextusban az üres halmaz hamis.
<li>Egy legalább egy elemű halmaz igaz.
<li>Egy legalább egy elemű halmaz igaz. Az elemek értéke lényegtelen.
</ol>

<p class=a>&#x2042;

<h2 id=dictionaries>Szótárak</h2>

<p>A <dfn>szótár</dfn> kulcs-érték párok rendezetlen halmaza. Amikor a szótárhoz hozzáadsz egy kulcsot, akkor a kulcs értékét is meg kell adnod. (Az érték később bármikor módosítható.) A Python szótárak az ismert kulcsú értékek lekérésére vannak optimalizálva, de ez nem működik fordítva.
<blockquote class='note compare perl5'>
<p><span class=u>&#x261E;</span>A szótár Pythonban olyan, mint egy hash
Perl 5-ben. Perl 5-ben a hasheket tároló változók a <code>%</code>
karakterrel kezdődnek. Pythonban a változók tetszőleges nevűek lehetnek,
és a Python maga tartja nyilván az adattípust.
</blockquote>
<h3 id=creating-dictionaries>Szótár létrehozása</h3>
<p>Egy szótárat létrehozni könnyű. A szintaxis hasonló a <a href=#sets>halmazokhoz</a>, de értékek helyett kulcs-érték párok vannak. A meglévő szótárból az értékeket a kulcsuk alapján keresheted ki.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict = {'kiszolgáló': 'db.diveintopython3.org', 'adatbázis': 'mysql'}</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'server': 'db.diveintopython3.org', 'database': 'mysql'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['kiszolgáló']</kbd>                                                     <span class=u>&#x2461;</span></a>
'db.diveintopython3.org'
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['adatbázis']</kbd>                                                      <span class=u>&#x2462;</span></a>
'mysql'
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['db.diveintopython3.org']</kbd>                                         <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
KeyError: 'db.diveintopython3.org'</samp></pre>
<ol>
<li>Első lépésként létrehozol egy két elemű szótárat, és az <var>a_dict</var> változóhoz rendeled. Minden elem egy kulcs-érték pár, és az elemek halmaza kapcsos zárójelek közt van.
<li>A <code>'kiszolgáló'</code> egy kulcs, és a hozzá tartozó érték, amelyre <code>a_dict['kiszolgáló']</code> formában hivatkozhatsz, a<code>'db.diveintopython3.org'</code>.
<li>Az <code>'adatbázis'</code> egy kulcs, és a hozzá tartozó érték, amelyre <code>a_dict['adatbázis']</code> formában hivatkozhatsz, a<code>'mysql'</code>.
<li>Az értékeket lekérheted kulcs alapján, de a kulcsokat nem kérheted le érték alapján. Emiatt az <code>a_dict['kiszolgáló']</code> visszatérési értéke<code>'db.diveintopython3.org'</code>, de az <code>a_dict['db.diveintopython3.org']</code> kivételt dob, mert a <code>'db.diveintopython3.org'</code> nem egy kulcs.
</ol>
<h3 id=modifying-dictionaries>Szótár módosítása</h3>
<p>A szótáraknak nincs előre meghatározott méretkorlátjuk. Bármikor hozzáadhatsz új kulcs-érték párokat egy szótárhoz, vagy módosíthatod egy meglévő kulcs értékét. Az előző példa folyatása:
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'kiszolgáló': 'db.diveintopython3.org', 'adatbázis': 'mysql'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['database'] = 'blog'</kbd>         <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'kiszolgáló': 'db.diveintopython3.org', 'adatbázis': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['felhasználó'] = 'mark'</kbd>      <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>                              <span class=u>&#x2462;</span></a>
<samp class=pp>{'kiszolgáló': 'db.diveintopython3.org', 'felhasználó': 'mark', 'adatbázis': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['felhasználó'] = 'dora'</kbd>      <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'kiszolgáló': 'db.diveintopython3.org', 'felhasználó': 'dora', 'adatbázis': 'blog'}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict['Felhasználó'] = 'mark'</kbd>      <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'Felhasználó': 'mark', 'kiszolgáló': 'db.diveintopython3.org', 'felhasználó': 'dora', 'adatbázis': 'blog'}</samp></pre>
<ol>
<li>A szótárban nem lehetnek többször szereplő kulcsok. Egy érték meglévő kulcshoz rendelése törli a régi értéket.
<li>Bármikor hozzáadhatsz új kulcs-érték párokat. Ez a szintaxis azonos a meglévő értékek módosításához használttal.
<li>Az új szótárelem (kulcs: <code>'felhasználó'</code>, érték: <code>'mark'</code>) középen jelenik meg. Tulajdonképpen az csak véletlen volt, hogy az első példában az elemek sorrendben jelentek meg, ugyanannyira véletlen, hogy most nem sorrendben jelennek meg.
<li>Egy érték meglévő szótárkulcshoz rendelése egyszerűen lecseréli a régi értéket az újra.
<li>Vajon ez megváltoztatja a <code>felhasználó</code> kulcs értékét "mark"-ra? Nem! Nézd meg jobban a kulcsot&nbsp;&ndash;&nbsp;az egy nagy <kbd>F</kbd> a <kbd>"Felhasználó"</kbd>-ban. A szótárkulcsok megkülönböztetik a kis- és nagybetűket, így ez az utasítás egy új kulcs-érték párt hoz létre, nem pedig egy meglévőt ír felül. Számodra hasonlónak tűnhetnek, de Python szempontjából teljesen különbözők.
</ol>
<h3 id=mixed-value-dictionaries>Vegyes értékű szótárak</h3>
<p>A szótárak nem csupán karakterláncokat tárolhatnak. A szótárértékek tetszőleges adattípusúak lehetnek, beleértve az egész és logikai értékeket, tetszőleges objektumokat vagy akár más szótárakat is. Ezen túl egy szótáron belül az értékeknek nem kell azonos típusúaknak lenniük, szükség szerint keverhetők. A használható szótárkulcstípusok köre korlátozottabb, de a kulcsok lehetnek karakterláncok, egészek és még néhány egyéb típusúak. Egy szótáron belül a kulcsok adattípusai szintén keverhetők.
<p>Tulajdonképpen már láttál egy nem-karakterlánc kulcsokat és értékeket tartalmazó szótárat az <a href=your-first-python-program.html#divingin>első Python programodban</a>.
<pre class='nd pp'><code>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}</code></pre>
<p>Szedjük ezt szét az interaktív parancsértelmezőben.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],</kbd>
<samp class=p>... </samp><kbd class=pp>            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>len(SUFFIXES)</kbd>      <span class=u>&#x2460;</span></a>
<samp class=pp>2</samp>
<a><samp class=p>>>> </samp><kbd class=pp>1000 in SUFFIXES</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>True</samp>
<a><samp class=p>>>> </samp><kbd class=pp>SUFFIXES[1000]</kbd>     <span class=u>&#x2462;</span></a>
<samp class=pp>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>SUFFIXES[1024]</kbd>     <span class=u>&#x2463;</span></a>
<samp class=pp>['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>SUFFIXES[1000][3]</kbd>  <span class=u>&#x2464;</span></a>
<samp class=pp>'TB'</samp></pre>
<ol>
<li>A <a href=#lists>listákhoz</a> és <a href=#sets>halmazokhoz</a> hasonlóan a <code>len()</code> függvény megadja a kulcsok számát a szótárban.
<li>A listákhoz és halmazokhoz hasonlóan az <code>in</code> operátorral tesztelheted, hogy egy adott kulcs szerepel-e a szótárban.
<li>Az <code>1000</code> egy <em>kulcs</em> a <code>SUFFIXES</code> szótárban, az értéke egy nyolc elemet (pontosabban nyolc karakterláncot) tartalmazó lista.
<li>Hasonlóképpen az <code>1024</code> is egy kulcs a <code>SUFFIXES</code> szótárba, az értéke szintén egy nyolc elemet tartalmazó lista.
<li>Mivel a <code>SUFFIXES[1000]</code> egy lista, az elemeit a 0-tól kezdődő indexük alapján elérheted.
</ol>
<h3 id=dictionaries-in-a-boolean-context>Szótárak logikai kontextusban</h3>
<aside>Az üres szótárak hamisak, minden más szótár igaz.</aside>
<p><a href=#booleans>Logikai kontextusban</a>, például <code>if</code>
utasításokban használhatsz szótárakat is. <pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(valami):</kbd>
<samp class=p>... </samp><kbd class=pp>  if valami:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("igen, ez igaz")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("nem, ez hamis")</kbd>
<samp class=p>...</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({})</kbd>             <span class=u>&#x2460;</span></a>
<samp>nem, ez hamis</samp>
<a><samp class=p>>>> </samp><kbd class=pp>is_it_true({'a': 1})</kbd>       <span class=u>&#x2461;</span></a>
<samp>igen, ez igaz</samp></pre>
<ol>
<li>Logikai kontextusban az üres szótár hamis.
<li>Egy legalább egy kulcs-érték párt tartalmazó szótár igaz.
</ol>
<p class=a>&#x2042;

<h2 id=none><code>None</code></h2>
<p>A <code><dfn>None</dfn></code> egy speciális konstans Pythonban. Ez egy <dfn>null</dfn> érték. A <code>None</code> nem ugyanaz, mint a <code>False</code>. A <code>None</code> nem 0. A <code>None</code> nem egy üres karakterlánc. A <code>None</code> összehasonlítása bármivel, ami nem <code>None</code> mindig <code>False</code> értéket ad.
<p>A <code>None</code> az egyetlen nullérték. Saját adattípussal rendelkezik (<code>NoneType</code>). A <code>None</code> bármely változóhoz hozzárendelhető, de nem hozhatsz létre más <code>NoneType</code> objektumokat. Minden változó, amely értéke <code>None</code>, egyenlő egymással.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>type(None)</kbd>
<samp class=pp>&lt;class 'NoneType'></samp>
<samp class=p>>>> </samp><kbd class=pp>None == False</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>None == 0</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>None == ''</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>None == None</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>x = None</kbd>
<samp class=p>>>> </samp><kbd class=pp>x == None</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>y = None</kbd>
<samp class=p>>>> </samp><kbd class=pp>x == y</kbd>
<samp class=pp>True</samp>
</pre>
<h3 id=none-in-a-boolean-context><code>None</code> logikai kontextusban</h3>
<p>A <a href=#booleans>logikai kontextusokban</a> a <code>None</code> hamis és a <code>not None</code> igaz.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>def is_it_true(valami):</kbd>
<samp class=p>... </samp><kbd class=pp>  if valami:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("igen, ez igaz")</kbd>
<samp class=p>... </samp><kbd class=pp>  else:</kbd>
<samp class=p>... </samp><kbd class=pp>    print("nem, ez hamis")</kbd>
<samp class=p>...</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(None)</kbd>
<samp>nem, ez hamis</samp>
<samp class=p>>>> </samp><kbd class=pp>is_it_true(not None)</kbd>
<samp>igen, ez igaz</samp></pre>
<p class=a>&#x2042;

<h2 id=furtherreading>További olvasnivaló</h2>
<ul>
<li><a href=http://docs.python.org/3.1/library/stdtypes.html#boolean-operations-and-or-not>Logikai műveletek</a>
<li><a href=http://docs.python.org/3.1/library/stdtypes.html#numeric-types-int-float-long-complex>Numerikus típusok</a>
<li><a href=http://docs.python.org/3.1/library/stdtypes.html#sequence-types-str-unicode-list-tuple-buffer-xrange>Sorozat típusok</a>
<li><a href=http://docs.python.org/3.1/library/stdtypes.html#set-types-set-frozenset>Halmaz típusok</a>
<li><a href=http://docs.python.org/3.1/library/stdtypes.html#mapping-types-dict>Leképezés típusok</a>
<li><a href=http://docs.python.org/3.1/library/fractions.html>A <code>fractions</code> modul</a>
<li><a href=http://docs.python.org/3.1/library/math.html>A <code>math</code> modul</a>
<li><a href=http://www.python.org/dev/peps/pep-0237/><abbr>PEP</abbr> 237: Unifying Long Integers and Integers</a>
<li><a href=http://www.python.org/dev/peps/pep-0238/><abbr>PEP</abbr> 238: Changing the Division Operator</a>
</ul>
<p class=v><a href=your-first-python-program.html rel=prev title='vissza &#8222;Az első Python programod&#8221; fejezetre'><span class=u>&#x261C;</span></a> <a href=comprehensions.html rel=next title='előre az &#8222;Összehasonlítások&#8221; fejezetre'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
