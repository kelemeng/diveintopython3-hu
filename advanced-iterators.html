<!DOCTYPE html>
<meta charset=utf-8>
<title>Speciális iterátorok - Ugorj fejest a Python 3-ba</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 8}
mark{display:inline}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Keresés></div></form>
<p>Itt vagy: <a href=index.html>Kezdőlap</a> <span
class=u>&#8227;</span> <a href=table-of-contents.html#advanced-iterators>Ugorj fejest a Python 3-ba</a> <span class=u>&#8227;</span>
<p id=level>Nehézségi szint: <span class=u title=advanced>&#x2666;&#x2666;&#x2666;&#x2666;&#x2662;</span>
<h1>Speciális iterátorok</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> A nagy bolhák hátán kisebb bolhák lakmároznak,<br>A kisebb bolhák hátán pedig még kisebb bolhák, és így tovább a végtelenségig. <span class=u>&#x275E;</span><br>&ndash; Augustus De Morgan
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Ugorj fejest</h2>
<p class=f>Ahogyan a <a href=regular-expressions.html>reguláris kifejezések</a> felturbózzák a <a href=strings.html>karakterláncokat</a>, az <code>itertools</code> modul az <a href=iterators.html>iterátorokat</a> turbózza fel. De előbb szeretnék mutatni egy klasszikus, angol nyelvű rejtvényt.

<pre class=nd><code>HAWAII + IDAHO + IOWA + OHIO == STATES
510199 + 98153 + 9301 + 3593 == 621246

H = 5
A = 1
W = 0
I = 9
D = 8
O = 3
S = 6
T = 2
E = 4</code></pre>

<p>Az ilyen rejtvényeket <i>kriptaritmusoknak</i> vagy <i>alfametikáknak</i> nevezik. A betűk valódi szavakká állnak össze, de ha az egyes betűket egy <code>0&ndash;9</code> közti számmal helyettesíted, akkor egy aritmetikai egyenlet áll elő. A feladat a betűkhöz tartozó számjegyek megtalálása. Az egyes betűk minden előfordulása ugyanannak a számjegynek felel meg, a számjegyek nem ismétlődhetnek, és egyik &#8222;szó&#8221; sem kezdődhet a 0 számjeggyel.

<aside>A legismertebb alfametikus feladvány a <code>SEND + MORE = MONEY</code>.</aside>

<p>Ebben a fejezetben egy hihetetlen Python programba ugrunk fejest, amelyet eredetileg Raymond Hettinger írt. Ez a program alfametikus feladatokat old meg <em>összesen 14 sor kóddal</em>.

<p class=d>[<a href=examples/alphametics.py>az <code>alphametics.py</code> letöltése</a>]
<pre class=pp><code>import re
import itertools

def solve(puzzle):
    words = re.findall('[A-Z]+', puzzle.upper())
    unique_characters = set(''.join(words))
    assert len(unique_characters) &lt;= 10, 'Too many letters'
    first_letters = {word[0] for word in words}
    n = len(first_letters)
    sorted_characters = ''.join(first_letters) + \
        ''.join(unique_characters - first_letters)
    characters = tuple(ord(c) for c in sorted_characters)
    digits = tuple(ord(c) for c in '0123456789')
    zero = digits[0]
    for guess in itertools.permutations(digits, len(characters)):
        if zero not in guess[:n]:
            equation = puzzle.translate(dict(zip(characters, guess)))
            if eval(equation):
                return equation

if __name__ == '__main__':
    import sys
    for puzzle in sys.argv[1:]:
        print(puzzle)
        solution = solve(puzzle)
        if solution:
            print(solution)</code></pre>

<p>A programot a parancssorból futtathatod. Linuxon ez így néz ki. (A program futása eltarthat egy ideig, a számítógéped sebességétől függően, és nincs folyamatjelző. Légy türelmes!)

<pre class='nd screen cmdline'>
<samp class=p>te@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "HAWAII + IDAHO + IOWA + OHIO == STATES"</kbd>
<samp>HAWAII + IDAHO + IOWA + OHIO = STATES
510199 + 98153 + 9301 + 3593 == 621246</samp>
<samp class=p>te@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "I + LOVE + YOU == DORA"</kbd>
<samp>I + LOVE + YOU == DORA
1 + 2784 + 975 == 3760</samp>
<samp class=p>te@localhost:~/diveintopython3/examples$ </samp><kbd>python3 alphametics.py "SEND + MORE == MONEY"</kbd>
<samp>SEND + MORE == MONEY
9567 + 1085 == 10652</samp></pre>

<p class=a>&#x2042;

<h2 id=re-findall>Egy minta összes előfordulásának megkeresése</h2>

<p>A program első lépésként megkeresi a feladvány összes betűjét (A&ndash;Z).

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.findall('[0-9]+', '16 2-by-4s in rows of 8')</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>['16', '2', '4', '8']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.findall('[A-Z]+', 'SEND + MORE == MONEY')</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>['SEND', 'MORE', 'MONEY']</samp></pre>
<ol>
<li>A <code>re</code> modul a Python <a href=regular-expressions.html>reguláris kifejezés</a> megvalósítása. Ez tartalmazza a <code>findall()</code> nevű függvényt, amely egy reguláris kifejezésként megadott mintát és egy karakterláncot vár, és megkeresi a minta összes előfordulását a karakterláncban. Ebben az esetben a minta számok sorozatára illeszkedik. A <code>findall()</code> függvény a mintára illeszkedő összes részkarakterlánc listáját adja vissza.
<li>Itt a reguláris kifejezés minta betűk sorozatára illeszkedik. A visszatérési érték ismét egy lista, és minden eleme a reguláris kifejezés mintára illeszkedő karakterlánc.
</ol>

<p>A következő példa is egy pici gondolkodásra fog késztetni.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>re.findall(' s.*? s', "The sixth sick sheikh's sixth sheep's sick.")</kbd>
<samp class=pp>[' sixth s', " sheikh's s", " sheep's s"]</samp></pre>

<aside>Ez az angol nyelv <a href=http://en.wikipedia.org/wiki/Tongue-twister>legkeményebb nyelvtörője</a>.</aside>

<p>Meglepődtél? A reguláris kifejezés egy szóközt, egy <code>s</code> betűt, majd tetszőleges karakterek lehetséges legrövidebb sorozatát (<code>.*?</code>), majd egy szóközt, és egy újabb <code>s</code> betűt keres. Nos, a bemeneti karakterláncra nézve, öt találatot látok:

<ol>
<li><code>The<mark> sixth s</mark>ick sheikh's sixth sheep's sick.</code>
<li><code>The sixth<mark> sick s</mark>heikh's sixth sheep's sick.</code>
<li><code>The sixth sick<mark> sheikh's s</mark>ixth sheep's sick.</code>
<li><code>The sixth sick sheikh's<mark> sixth s</mark>heep's sick.</code>
<li><code>The sixth sick sheikh's sixth<mark> sheep's s</mark>ick.</code>
</ol>

<p>Azonban a <code>re.findall()</code> függvény csak három találatot adott vissza. Ezen belül az első, harmadik és ötödik találatot adta vissza. Miért van ez így? Mert <em>nem adja vissza az egymást átfedő találatokat</em>. Az első találat átfedi a másodikat, így az első visszaadásra kerül, a második pedig kimarad. Ezután a harmadik átfedi a negyediket, így a harmadik visszaadásra kerül, a negyedik pedig kimarad. Végül az ötödik is visszaadásra kerül. Három találat, nem öt.

<p>Ennek semmi köze az alfametikus megoldóhoz, csak érdekesnek találom.

<p class=a>&#x2042;

<h2 id=unique-items>Egy sorozat egyedi elemeinek megkeresése</h2>

<p>A <a href=native-datatypes.html#sets>halmazok</a> triviálissá teszik egy sorozat egyedi elemeinek megtalálását.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = ['The', 'sixth', 'sick', "sheik's", 'sixth', "sheep's", 'sick']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>set(a_list)</kbd>                      <span class=u>&#x2460;</span></a>
<samp class=pp>{'sixth', 'The', "sheep's", 'sick', "sheik's"}</samp>
<samp class=p>>>> </samp><kbd class=pp>a_string = 'EAST IS EAST'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>set(a_string)</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=pp>{'A', ' ', 'E', 'I', 'S', 'T'}</samp>
<samp class=p>>>> </samp><kbd class=pp>words = ['SEND', 'MORE', 'MONEY']</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>''.join(words)</kbd>                   <span class=u>&#x2462;</span></a>
<samp class=pp>'SENDMOREMONEY'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>set(''.join(words))</kbd>              <span class=u>&#x2463;</span></a>
<samp class=pp>{'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</samp></pre>
<ol>
<li>Egy több karakterláncból álló lista esetén a <code>set()</code> függvény visszaadja a lista egyedi karakterláncainak halmazát. Ennek van értelme, ha úgy gondolsz rá, mint egy <code>for</code> ciklusra. Vegyük a lista első elemét, tegyük be a halmazba. A másodikat. A harmadikat. A negyediket. Az ötödiket&nbsp;&ndash;&nbsp;várj, ilyen már van a halmazban, így most kimarad, mert a Python nem engedélyezi a másodpéldányokat. A hatodikat. A hetediket&nbsp;&ndash;&nbsp;újra egy másodpéldány, ismét kimarad. A végeredmény? Az eredeti lista összes egyedi eleme másodpéldányok nélkül. Az eredeti listát nem is kell rendezni előtte.
<li>Ugyanez a módszer működik karakterláncokkal is, mert a karakterlánc csak karakterek sorozata.
<li>Karakterláncok listáját véve a <code>''.join(<var>a_list</var>)</code> összefésüli az összes karakterláncot egyetlen eggyé.
<li>Karakterláncok egy listáját átadva, ez a kódsor visszaadja a karakterláncok összes egyedi karakterét, másodpéldányok nélkül.
</ol>

<p>Az alfametikus megoldó ezt a módszert használja a feladvány összes egyedi karakterét tartalmazó halmaz felépítéséhez.
<pre class='nd pp'><code>unique_characters = set(''.join(words))</code></pre>

<p>Ez a lista később a számjegyek karakterekhez rendelésénél lesz felhasználva, amikor a megoldó végigjárja a lehetséges megoldásokat.
<p class=a>&#x2042;

<h2 id=assert>Kijelentések tétele</h2>

<p>Sok programozási nyelvhez hasonlóan a Python is rendelkezik egy <code>assert</code> utasítással. Így működik:

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>assert 1 + 1 == 2</kbd>                                     <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>assert 1 + 1 == 3</kbd>                                     <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AssertionError</samp>
<a><samp class=p>>>> </samp><kbd class=pp>assert 2 + 2 == 5, "Csak a 2 nagyon nagy értékeihez"</kbd>  <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AssertionError: Csak a 2 nagyon nagy értékeihez</samp></pre>
<ol>
<li>Az <code>assert</code> utasítást tetszőleges érvényes Python kifejezés követheti. Ebben az esetben az <code>1 + 1 == 2</code> kifejezés <code>True</code>-ra értékelődik ki, így az <code>assert</code> utasítás nem csinál semmit.
<li>Ha azonban a Python kifejezés <code>False</code>-ra értékelődik ki, akkor az <code>assert</code> utasítás <code>AssertionError</code> kivételt dob.
<li>Megadhatsz egy emberek által olvasható üzenetet is, amely az <code>AssertionError</code> dobásakor kiírásra kerül.
</ol>

<p>Emiatt ez a sor kód:

<pre class='nd pp'><code>assert len(unique_characters) &lt;= 10, 'Túl sok betű'</code></pre>

<p>&hellip;ezzel egyenértékű:

<pre class='nd pp'><code>if len(unique_characters) > 10:
    raise AssertionError('Túl sok betű')</code></pre>

<p>Az alfametikus megoldó pontosan ezt az <code>assert</code> utasítást használja, hogy időben megálljon, ha a feladvány tíz egyedi betűnél többet tartalmazna. Mivel minden betűhöz egyedi számjegy kerül hozzárendelésre, és csak tíz számjegy van, a tíz betűnél többet tartalmazó feladványoknak nem lehet megoldásuk.
<p class=a>&#x2042;

<h2 id=generator-expressions>Generátorkifejezések</h2>

<p>A generátorkifejezés olyan, mint egy függvény nélküli <a href=generators.html>generátorfüggvény</a>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>unique_characters = {'E', 'D', 'M', 'O', 'N', 'S', 'R', 'Y'}</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>gen = (ord(c) for c in unique_characters)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>gen</kbd>                                        <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;generator object &lt;genexpr> at 0x00BADC10></samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(gen)</kbd>                                  <span class=u>&#x2462;</span></a>
<samp class=pp>69</samp>
<samp class=p>>>> </samp><kbd class=pp>next(gen)</kbd>
<samp class=pp>68</samp>
<a><samp class=p>>>> </samp><kbd class=pp>tuple(ord(c) for c in unique_characters)</kbd>   <span class=u>&#x2463;</span></a>
<samp class=pp>(69, 68, 77, 79, 78, 83, 82, 89)</samp></pre>
<ol>
<li>Egy generátorkifejezés olyan, mint egy névtelen függvény, amely értékeket ad vissza. Maga a kifejezés úgy néz ki, mint egy <a href=comprehensions.html#listcomprehension>listafeldolgozó</a>, de szögletes zárójelek helyett zárójelek közt van.
<li>A generátorkifejezés egy&hellip; iterátort ad vissza.
<li>A <code>next(<var>gen</var>)</code> hívása az iterátorból származó következő értéket adja vissza.
<li>Ha szeretnéd, végiglépkedhetsz az összes lehetséges értéken, és visszaadhatsz egy ennest, listát vagy halmazt a generátorkifejezés átadásával a <code>tuple()</code>, <code>list()</code> vagy <code>set()</code> függvénynek. Ezekben az esetekben nincs szükséged extra zárójelekre&nbsp;&ndash;&nbsp;csak add át a &#8222;nyers&#8221; <code>ord(c) for c in unique_characters</code> kifejezést a <code>tuple()</code> függvénynek, és a Python megállapítja, hogy ez egy generátorkifejezés.
</ol>

<blockquote class=note>
<p><span class=u>&#x261E;</span>Listafeldolgozó helyett generátorkifejezést használva egyaránt spórolhatsz a <abbr>CPU</abbr> és a <abbr>RAM</abbr> használatán is. Ha csak azért építesz egy listát, hogy rögtön eldobhasd (<i>például</i> a <code>tuple()</code> vagy <code>set()</code> függvénynek átadva), használj generátorkifejezést.
</blockquote>

<p>Ugyanezt máshogy is elérheted egy <a href=generators.html>generátorfüggvény</a> használatával:

<pre class='nd pp'><code>def ord_map(a_string):
    for c in a_string:
        yield ord(c)

gen = ord_map(unique_characters)</code></pre>

<p>A generátorkifejezés tömörebb, de funkcionálisan egyenértékű.
<p class=a>&#x2042;

<h2 id=permutations>Permutációk kiszámítása&hellip; lusta módra!</h2>

<p>Először is, mi a csuda az a permutáció? A permutáció egy matematikai fogalom. (Valójában több meghatározás van, az épp használt matematikai rendszertől függően. Itt a kombinatorikáról van szó, de ha ez nem jelent neked semmit, akkor se aggódj. Mint mindig, a <a href=http://hu.wikipedia.org/wiki/Permut%C3%A1ci%C3%B3>Wikipédia a barátod</a>.)

<p>Az alapötlet a következő: veszed elemek (számok, betűk, táncoló medvék) listáját, és az összes lehetséges módon felosztod kisebb listákra. Az összes kisebb lista azonos méretű, akár egy eleműek is lehetnek, de az elemek teljes számával egyenlő méretűek is. Ja és egyáltalán nem lehetnek ismétlődések. A matematikusok olyanokat mondanak, mint például &#8222;keressük meg 3 különböző elem permutációit egyszerre kettőt véve&#8221;, ami azt jelenti, hogy egy 3 elemből álló listád van, és meg akarod találni az összes lehetséges rendezett párt.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>                              <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>perms = itertools.permutations([1, 2, 3], 2)</kbd>  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>                                   <span class=u>&#x2462;</span></a>
<samp class=pp>(1, 2)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(1, 3)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<a><samp class=pp>(2, 1)</samp>                                            <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(2, 3)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(3, 1)</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>(3, 2)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>                                   <span class=u>&#x2464;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp></pre>
<ol>
<li>Az <code>itertools</code> modul mindenféle jópofa dolgot tartalmaz, beleértve egy <code>permutations()</code> függvényt, amely elvégzi a permutációk keresésének fáradtságos munkáját.
<li>A <code>permutations()</code> függvény egy sorozatot (itt egy három számból álló listát) és egy számot vár, amely a kisebb csoportokba beosztandó elemek száma. A függvény egy iterátort ad vissza, amelyet felhasználhatsz egy <code>for</code> ciklusban vagy bármely más helyen, ami iterál. Itt saját kezűleg lépkedek végig az iterátoron az értékek megjelenítéséhez.
<li>Az <code>[1, 2, 3]</code> első permutációja egyszerre 2 elemet véve az <code>(1, 2)</code>.
<li>Figyeld meg, hogy a permutációk rendezettek: a <code>(2, 1)</code> eltér az <code>(1, 2)</code>-től.
<li>Ennyi az egész! Ez az <code>[1, 2, 3]</code> összes permutációja egyszerre két elemet véve. Az <code>(1, 1)</code> és <code>(2, 2)</code> párok soha nem jelennek meg, mert ismétléseket tartalmaznak, így nem érvényes permutációk. Ha nincs több permutáció, akkor az iterátor egy <code>StopIteration</code> kivételt dob.
</ol>

<aside>Az <code>itertools</code> modul mindenféle jópofa dolgot tartalmaz.</aside>

<p>A <code>permutations()</code> függvénynek nem kötelező listát átadni. Tetszőleges sorozatot kaphat&nbsp;&ndash;&nbsp;akár egy karakterláncot is.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>perms = itertools.permutations('ABC', 3)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<a><samp class=pp>('A', 'B', 'C')</samp>                               <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('A', 'C', 'B')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('B', 'A', 'C')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('B', 'C', 'A')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('C', 'A', 'B')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=pp>('C', 'B', 'A')</samp>
<samp class=p>>>> </samp><kbd class=pp>next(perms)</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
StopIteration</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.permutations('ABC', 3))</kbd>    <span class=u>&#x2462;</span></a>
<samp class=pp>[('A', 'B', 'C'), ('A', 'C', 'B'),
 ('B', 'A', 'C'), ('B', 'C', 'A'),
 ('C', 'A', 'B'), ('C', 'B', 'A')]</samp></pre>
<ol>
<li>Egy karakterlánc csupán karakterek sorozata. A permutációk keresése szempontjából az <code>'ABC'</code> egyenértékű a <code>['A', 'B', 'C']</code> listával.
<li>A 3 elem első permutációja <code>['A', 'B', 'C']</code> egyszerre 3 elemet véve <code>('A', 'B', 'C')</code>. Öt másik permutáció is van&nbsp;&ndash;&nbsp;ugyanaz a három karakter minden elképzelhető sorrendben.
<li>Mivel a <code>permutations()</code> függvény mindig egy iterátort ad vissza, a permutációk hibakeresése egyszerűen megoldható az iterátor átadásával a beépített <code>list()</code> függvénynek, így az összes permutáció azonnal megjeleníthető.
</ol>

<p class=a>&#x2042;

<h2 id=more-itertools>További menő dolgok az <code>itertools</code> modulban</h2>
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.product('ABC', '123'))</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>[('A', '1'), ('A', '2'), ('A', '3'), 
 ('B', '1'), ('B', '2'), ('B', '3'), 
 ('C', '1'), ('C', '2'), ('C', '3')]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.combinations('ABC', 2))</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>[('A', 'B'), ('A', 'C'), ('B', 'C')]</samp></pre>
<ol>
<li>Az <code>itertools.product()</code> függvény a két sorozat Descartes-szorzatát tartalmazó iterátort ad vissza.
<li>Az <code>itertools.combinations()</code> függvény az adott sorozat összes adott hosszú kombinációját adja vissza. Ez olyan, mint az <code>itertools.permutations()</code> függvény, csak a kombinációk nem tartalmaznak olyan elemeket, amelyek ugyanazon elemek más sorrendben lévő másodpéldányai. Így az <code>itertools.permutations('ABC', 2)</code> visszaadja mind az <code>('A', 'B')</code> és <code>('B', 'A')</code> elemeket (többek közt), de az <code>itertools.combinations('ABC', 2)</code> nem adja vissza a <code>('B', 'A')</code> elemet, mert az az <code>('A', 'B')</code> másodpéldánya más sorrendben.
</ol>

<p class=d>[<a href=examples/favorite-people.txt>a <code>favorite-people.txt</code> letöltése</a>]
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>names = list(open('examples/favorite-people.txt', encoding='utf-8'))</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Dora\n', 'Ethan\n', 'Wesley\n', 'John\n', 'Anne\n',
'Mike\n', 'Chris\n', 'Sarah\n', 'Alex\n', 'Lizzie\n']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = [name.rstrip() for name in names]</kbd>                             <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Dora', 'Ethan', 'Wesley', 'John', 'Anne',
'Mike', 'Chris', 'Sarah', 'Alex', 'Lizzie']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = sorted(names)</kbd>                                                 <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Alex', 'Anne', 'Chris', 'Dora', 'Ethan',
'John', 'Lizzie', 'Mike', 'Sarah', 'Wesley']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>names = sorted(names, key=len)</kbd>                                        <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>names</kbd>
<samp class=pp>['Alex', 'Anne', 'Dora', 'John', 'Mike',
'Chris', 'Ethan', 'Sarah', 'Lizzie', 'Wesley']</samp></pre>
<ol>
<li>Ez a kifejezés a szövegfájl sorainak listáját adja vissza.
<li>Sajnos (jelen példa szempontjából) a <code>list(open(<var>filename</var>))</code> kifejezés tartalmazza a sorok végén lévő kocsivissza karaktert is. Ez a listafeldolgozó az <code>rstrip()</code> karakterlánc-metódust használja a záró üres hely eltávolítására a karakterláncok végéről. (A karakterláncok rendelkeznek egy <code>lstrip()</code> metódussal is a kezdő üres hely eltávolításához, és egy <code>strip()</code> metódussal mindkettő eltávolításához.)
<li>A <code>sorted()</code> függvény egy listát vár, és rendezve adja vissza. Alapértelmezésben ábécérendbe rendez.
<li>De a <code>sorted()</code> függvény kaphat függvényt is a <var>key</var> paraméteren keresztül, ekkor aszerint rendez. Ebben az esetben a rendezési függvény a <code>len()</code>, így a <code>len(<var>minden elem</var>)</code> szerint rendez. A rövidebb nevek jönnek előre, aztán a hosszabbak, végül a leghosszabbak.
</ol>

<p>Mi köze van ennek az <code>itertools</code> modulhoz? Örülök, hogy megkérdezted!
<pre class=screen>
&hellip;folytatás az előző interaktív parancsértelmezőből&hellip;
<samp class=p>>>> </samp><kbd class=pp>import itertools</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>groups = itertools.groupby(names, len)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>groups</kbd>
<samp class=pp>&lt;itertools.groupby object at 0x00BB20C0></samp>
<samp class=p>>>> </samp><kbd class=pp>list(groups)</kbd>
<samp class=pp>[(4, &lt;itertools._grouper object at 0x00BA8BF0>),
 (5, &lt;itertools._grouper object at 0x00BB4050>),
 (6, &lt;itertools._grouper object at 0x00BB4030>)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>groups = itertools.groupby(names, len)</kbd>   <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>for name_length, name_iter in groups:</kbd>    <span class=u>&#x2462;</span></a>
<samp class=p>... </samp><kbd class=pp>    print('{0:d} betűs nevek:'.format(name_length))</kbd>
<samp class=p>... </samp><kbd class=pp>    for name in name_iter:</kbd>
<samp class=p>... </samp><kbd class=pp>        print(name)</kbd>
<samp class=p>... </samp>
<samp>4 betűs nevek:
Alex
Anne
Dora
John
Mike
5 betűs nevek:
Chris
Ethan
Sarah
6 betűs nevek:
Lizzie
Wesley</samp></pre>
<ol>
<li>Az <code>itertools.groupby()</code> függvény egy sorozatot és egy kulcsfüggvényt vár, és visszaad egy iterátort, amely párokat generál. Minden pár a <code>kulcsfüggvény(<var>minden elem</var>)</code> eredményét, és egy másik iterátort tartalmaz, amely az összes azonos kulcsú elemet tartalmazza.
<li>A <code>list()</code> függvény hívása &#8222;kimerítette&#8221; az iterátort, <i>azaz</i> előállítottad az iterátor minden elemét a lista létrehozásához. Nincs &#8222;újraindítás&#8221; gomb az iterátorokon, az egyszer már kimerített iterátoron nem kezdhetsz újra végigjárni. Ha újra végig szeretnél rajta járni (mondjuk a soron következő <code>for</code> ciklusban), akkor újra meg kell hívnod az <code>itertools.groupby()</code> metódust egy új iterátor létrehozásához.
<li>Ebben a példában a <em>már hossz szerint rendezett</em> névlistát tekintve az <code>itertools.groupby(names, len)</code> az összes 4 betűs nevet egy iterátorba teszi, az összes 5 betűset egy másikba és így tovább. A <code>groupby()</code> függvény teljesen általános, csoportosíthatja a karakterláncokat az első betű szerint, a számokat a tényezőik száma szerint vagy tetszőleges kulcsfüggvény szerint, amit csak el tudsz képzelni.
</ol>
<!-- YO DAWG, WE HEARD YOU LIKE LOOPING, SO WE PUT AN ITERATOR IN YOUR ITERATOR SO YOU CAN LOOP WHILE YOU LOOP. -->

<blockquote class=note>
<p><span class=u>&#x261E;</span>Az <code>itertools.groupby()</code> függvény csak akkor működik, ha a bemeneti sorozat már rendezve van a csoportosító függvény által. A fenti példában a nevek listáját a <code>len()</code> függvénnyel csoportosítottad. Ez csak azért működött, mert a bemenet már rendezve volt hossz szerint. </blockquote>

<p>Nagyon figyelsz?
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>list(range(0, 3))</kbd>
<samp class=pp>[0, 1, 2]</samp>
<samp class=p>>>> </samp><kbd class=pp>list(range(10, 13))</kbd>
<samp class=pp>[10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.chain(range(0, 3), range(10, 13)))</kbd>        <span class=u>&#x2460;</span></a>
<samp class=pp>[0, 1, 2, 10, 11, 12]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(zip(range(0, 3), range(10, 13)))</kbd>                    <span class=u>&#x2461;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(zip(range(0, 3), range(10, 14)))</kbd>                    <span class=u>&#x2462;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12)]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(itertools.zip_longest(range(0, 3), range(10, 14)))</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>[(0, 10), (1, 11), (2, 12), (None, 13)]</samp></pre>
<ol>
<li>Az <code>itertools.chain()</code> függvény két iterátort vár, és egy olyan iterátort ad vissza, amely az első elemeit, majd azok után a második elemeit tartalmazza. (Valójában tetszőleges számú iterátort át lehet neki adni, hogy aztán a függvénynek való átadásuk sorrendjében összefűzze azokat.)
<li>A <code>zip()</code> függvény egy teljesen hétköznapi dolgot tesz, amely azonban különösen hasznosnak fog bizonyulni: tetszőleges számú sorozatot vár, és visszaad egy iterátort, amely az egyes sorozatokból az első, második, harmadik stb. elemeket tartalmazó enneseket ad vissza.
<li>A <code>zip()</code> függvény a legrövidebb sorozat végén áll meg. A <code>range(10, 14)</code> 4 elemet (10, 11, 12 és 13) tartalmaz, de a <code>range(0, 3)</code> csak hármat, így a <code>zip()</code> függvény egy 3 elemű iterátort ad vissza.
<li>Másrészről az <code>itertools.zip_longest()</code> függvény a <em>leghosszabb</em> sorozat végén áll meg, <code>None</code> értékeket szúrva be a rövidebb sorozatok vége utáni elemekhez.
</ol>

<p id=dict-zip>Oké, ez mind nagyon érdekes, de mi köze van az alfametikus megoldóhoz? A következő:

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>characters = ('S', 'M', 'E', 'D', 'O', 'N', 'R', 'Y')</kbd>
<samp class=p>>>> </samp><kbd class=pp>guess = ('1', '2', '0', '3', '4', '5', '6', '7')</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>tuple(zip(characters, guess))</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>(('S', '1'), ('M', '2'), ('E', '0'), ('D', '3'),
 ('O', '4'), ('N', '5'), ('R', '6'), ('Y', '7'))</samp>
<a><samp class=p>>>> </samp><kbd class=pp>dict(zip(characters, guess))</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>{'E': '0', 'D': '3', 'M': '2', 'O': '4',
 'N': '5', 'S': '1', 'R': '6', 'Y': '7'}</samp></pre>
<ol>
<li>Ha adva van egy betűkből és egy számokból álló lista (itt mindkettő 1 karakterből álló karakterláncként jelenik meg), akkor a <code>zip</code> függvény létrehozza a betűk és számjegyek sorba rendezett párjait.
<li>Miért menő ez? Mert ez az adatszerkezet pontosan megfelel a <code>dict()</code> függvénynek való átadáshoz, hogy az létrehozzon egy szótárat, amelynek kulcsai betűk, értékei pedig számjegyek. (Ez természetesen nem az egyetlen megoldás. Használhatnál <a href=comprehensions.html#dictionarycomprehension>szótárfeldolgozót</a> is a szótár közvetlen létrehozásához.) Noha a szótár kiírt ábrázolása a párokat eltérő sorrendben sorolja fel (a szótárak maguk nem rendelkeznek &#8222;sorrenddel&#8221;), azért láthatod, hogy minden betű egy számjegyhez tartozik, az eredeti <var>characters</var> és <var>guess</var> sorozatok sorrendje alapján.
</ol>

<p id=guess>Az alfametikus megoldó ezt a módszert használja egy szótár létrehozásához, amely a feladvány betűit leképezi a megoldás számjegyeire, minden lehetséges megoldás esetén.
<pre class='nd pp'><code>characters = tuple(ord(c) for c in sorted_characters)
digits = tuple(ord(c) for c in '0123456789')
...
for guess in itertools.permutations(digits, len(characters)):
    ...
<mark>    equation = puzzle.translate(dict(zip(characters, guess)))</mark></code></pre>

<p>De mi az a <code>translate()</code> metódus? Ó, most jutunk el az <em>igazán</em> vidám részhez.

<p class=a>&#x2042;

<h2 id=string-translate>Egy új karakterlánc-manipulálási módszer</h2>

<p>A Python karakterláncok sok metódussal rendelkeznek. Ezen metódusok némelyikével a <a href=strings.html>Karakterláncok fejezetben</a> már megismerkedtél: <code>lower()</code>, <code>count()</code> és <code>format()</code>. Most szeretnék megmutatni egy hatékony, de kevéssé ismert karakterlánc-manipulálási módszert: a <code>translate()</code> metódust.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table = {ord('A'): ord('O')}</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table</kbd>                         <span class=u>&#x2461;</span></a>
<samp class=pp>{65: 79}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'MARK'.translate(translation_table)</kbd>       <span class=u>&#x2462;</span></a>
<samp class=pp>'MORK'</samp></pre>
<ol>
<li>A karakterláncok lefordítása egy fordítási táblával kezdődik, ez egy szótár, amely egy karaktert egy másikra képez le. Valójában a &#8222;karakter&#8221; kifejezés helytelen&nbsp;&ndash;&nbsp;a fordítási tábla egy <em>bájtot</em> képez le egy másikra.
<li>Emlékezz, a bájtok a Python 3-ban egész számok. Az <code>ord()</code> függvény visszaadja egy karakter <abbr>ASCII</abbr> értékét, amely az A&ndash;Z esetén mindig egy 65 és 90 közti bájt.
<li>Egy karakterlánc <code>translate()</code> metódusa egy fordítási táblát vár, és átfuttatja rajta a karakterláncot. Azaz a fordítási tábla kulcsainak minden előfordulását lecseréli a megfelelő értékre. Ebben az esetben &#8222;lefordítja&#8221; a <code>MARK</code> szót <code>MORK</code>-ra.
</ol>

<aside>Most jutunk el az <em>igazán</em> vidám részhez.

</aside>

<p>Mi köze van ennek az alfametikus feladványok megoldásához? Amint kiderül, rengeteg.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>characters = tuple(ord(c) for c in 'SMEDONRY')</kbd>       <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>characters</kbd>
<samp class=pp>(83, 77, 69, 68, 79, 78, 82, 89)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>guess = tuple(ord(c) for c in '91570682')</kbd>            <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>guess</kbd>
<samp class=pp>(57, 49, 53, 55, 48, 54, 56, 50)</samp>
<a><samp class=p>>>> </samp><kbd class=pp>translation_table = dict(zip(characters, guess))</kbd>     <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>translation_table</kbd>
<samp class=pp>{68: 55, 69: 53, 77: 49, 78: 54, 79: 48, 82: 56, 83: 57, 89: 50}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'SEND + MORE == MONEY'.translate(translation_table)</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'9567 + 1085 == 10652'</samp></pre>
<ol>
<li>Egy <a href=#generator-expressions>generátorkifejezés</a> használatával gyorsan kiszámítjuk a karakterlánc minden egyes karakterének bájtértékét. A <var>characters</var> ennes a <var>sorted_characters</var> értékét példázza az <code>alphametics.solve()</code> függvényben.
<li>Egy másik generátorkifejezés használatával gyorsan kiszámítjuk a karakterlánc számjegyeinek bájtértékeit. Az eredményként kapott <var>guess</var> ennes az <code>alphametics.solve()</code> függvényben az <a href=#guess><code>itertools.permutations()</code> függvény</a> által visszaadott formátumú.
<li>Ezt a fordítási táblát a <a href=#dict-zip><var>characters</var> és <var>guess</var> zip metódussal való egyesítése</a> és az eredményül kapott párok sorozatából egy szótár összeállításával kapjuk. Ez pontosan ugyanaz, mint amit az <code>alphametics.solve()</code> függvény csinál a <code>for</code> cikluson belül.
<li>Végül átadjuk ezt a fordítási táblát az eredeti feladvány karakterlánc <code>translate()</code> metódusának. Ez a karakterlánc minden betűjét átalakítja a megfelelő számjeggyé (a <var>characters</var> betűi és a <var>guess</var> számjegyei alapján). Az eredmény egy érvényes Python kifejezés, karakterláncként.
</ol>

<p>Ez meglehetősen meggyőző. De mit lehet kezdeni egy karakterlánccal, amely egyúttal érvényes Python kifejezés is?
<p class=a>&#x2042;

<h2 id=eval>Tetszőleges karakterláncok kiértékelése Python kifejezésekként</h2>

<p>Ez a feladvány utolsó darabja (vagy inkább a feladványmegoldó utolsó darabja). A rengeteg karakterlánc-manipuláció után egy ilyen karakterláncot kapsz: <code>'9567 + 1085 == 10652'</code>. De ez egy karakterlánc, és mire jó egy karakterlánc? Most lép színre az <code>eval()</code>, az univerzális Python kiértékelési eszköz.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>eval('1 + 1 == 2')</kbd>
<samp class=pp>True</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('1 + 1 == 3')</kbd>
<samp class=pp>False</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('9567 + 1085 == 10652')</kbd>
<samp class=pp>True</samp></pre>

<p>De várj, van még más is! Az <code>eval()</code> függvény nincs logikai kifejezésekre korlátozva. Képes kezelni <em>bármely</em> Python kifejezést és <em>tetszőleges</em> adattípust adhat vissza.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>eval('"A" + "B"')</kbd>
<samp class=pp>'AB'</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('"MARK".translate({65: 79})')</kbd>
<samp class=pp>'MORK'</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('"AAAAA".count("A")')</kbd>
<samp class=pp>5</samp>
<samp class=p>>>> </samp><kbd class=pp>eval('["*"] * 5')</kbd>
<samp class=pp>['*', '*', '*', '*', '*']</samp></pre>

<p>De várj, ez nem minden!

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5")</kbd>         <span class=u>&#x2460;</span></a>
<samp class=pp>25</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("pow(x, 2)")</kbd>     <span class=u>&#x2461;</span></a>
<samp class=pp>25</samp>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("math.sqrt(x)")</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>2.2360679774997898</samp></pre>
<ol>
<li>Az <code>eval()</code> által kapott kifejezés az <code>eval()</code> híváson kívül definiált globális változókra is hivatkozhat. Ha függvényen belül hívod, akkor helyi változókra is hivatkozhat.
<li>És függvényekre is.
<li>És modulokra is.
</ol>

<p>Hé, várj egy percet&hellip;

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import subprocess</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("subprocess.getoutput('ls ~')")</kbd>                  <span class=u>&#x2460;</span></a>
<samp class=pp>'Asztal         Gyűjtemény         Képek \
 Dokumentumok       Videók          Nyilvános   \
 Zenék           Oldalak'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("subprocess.getoutput('rm /valami/véletlen/fájl')")</kbd>  <span class=u>&#x2461;</span></a></pre>
<ol>
<li>A <code>subprocess</code> modul lehetővé teszi a parancsértelmező tetszőleges parancsainak futtatását, és az eredmény lekérését Python karakterláncként.
<li>A parancsértelmező bizonyos parancsainak futtatása végzetes következményekkel járhat.
</ol>

<p>Ennél is rosszabb a helyzet, mert van egy globális <code>__import__()</code> függvény, amely egy modulnevet vár karakterláncként, importálja a modult, és visszaad egy hivatkozást rá. Az <code>eval()</code> erejével egyesítve előállíthatsz egy olyan kifejezést, amely letörli az összes fájlod:
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm /valami/véletlen/fájl')")</kbd>  <span class=u>&#x2460;</span></a></pre>
<ol>
<li>Most képzeld el az <code>'rm -rf ~'</code> kimenetét. Valójában nem lenne kimenete, de fájljaid sem maradnának.
</ol>

<p class=xxxl>Az eval() GONOSZ

<p>A gonosz rész a megbízhatatlan forrásokból származó tetszőleges kifejezések kiértékelése. Az <code>eval()</code> függvényt csak megbízható bemeneten szabad használni. Természetesen a trükk a &#8222;megbízható&#8221; bemenet meghatározása. De van egy dolog, amiben biztos vagyok: ezt az alfametikus megoldót <b>NEM</b> szabad kitenni az internetre egy vicces kis webszolgáltatásként. Ne kövesd el azt a hibát, hogy úgy gondolod: &#8222;Ugyan már, a függvény rengeteg karakterlánc-manipulációt végez, mielőtt megkapja a kiértékelendő karakterláncot, <em>nem tudom elképzelni</em>, hogyan lehetne ezt kihasználni.&#8221; Valaki ki <b>FOGJA</b> találni, hogyan lehet megadni a karakterlánc-manipulációkat túlélő rosszindulatú végrehajtható kódot (<a href=http://www.securityfocus.com/blogs/746>furább dolgok is történtek már</a>), és akkor elköszönhetsz a kiszolgálódtól.

<p>De biztos van <em>valami</em> lehetőség a kifejezések biztonságos kiértékelésére, nem? Az <code>eval()</code> nem tehető be egy homokozóba, ahol nem tudja elérni vagy károsítani a külvilágot? Hát, igen is meg nem is.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>x = 5</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5", {}, {})</kbd>               <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'x' is not defined</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("x * 5", {"x": x}, {})</kbd>         <span class=u>&#x2461;</span></a>
<samp class=p>25</samp>
<samp class=p>>>> </samp><kbd class=pp>import math</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>eval("math.sqrt(x)", {"x": x}, {})</kbd>  <span class=u>&#x2462;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name 'math' is not defined</samp></pre>
<ol>
<li>Az <code>eval()</code> függvénynek átadott második és harmadik paraméter a kifejezés kiértékeléséhez használandó globális és helyi névterekként működnek. Ebben az esetben mindkettő üres, ami azt jelenti, hogy az <code>"x * 5"</code> karakterlánc kiértékelésekor nincs hivatkozás az <var>x</var>-re a globális vagy helyi névtérben, így az <code>eval()</code> kivételt dob.
<li>A globális névtérbe felvehetsz egyedi értékeket azok egyenkénti felsorolásával. Ezután azok&nbsp;&ndash;&nbsp;és csak azok&nbsp;&ndash;&nbsp;elérhetők lesznek a kiértékelés során.
<li>Noha importáltad a <code>math</code> modult, nem vetted fel az <code>eval()</code> függvénynek átadott névtérbe, így a kiértékelés meghiúsult.
</ol>

<p>Hát, ez könnyű volt. Hadd csináljam meg most azt az alfametikus webszolgáltatást!

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>eval("pow(5, 2)", {}, {})</kbd>                   <span class=u>&#x2460;</span></a>
<samp class=pp>25</samp>
<a><samp class=p>>>> </samp><kbd class=pp>eval("__import__('math').sqrt(5)", {}, {})</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>2.2360679774997898</samp></pre>
<ol>
<li>Noha csak üres szótárakat adtál át a globális és helyi névtereknek, a Python összes beépített függvénye továbbra is elérhető a kiértékelés során. Így a <code>pow(5, 2)</code> működik, mert az <code>5</code> és a <code>2</code> literálok, a <code>pow()</code> pedig beépített függvény.
<li>Sajnos (és ha nem látod miért sajnos, olvass tovább) az <code>__import__()</code> függvény szintén beépített, így ez is működik.
</ol>

<p>Igen, ez azt jelenti, hogy továbbra is lehet huncut dolgokat csinálni, még ha a globális és helyi névtereket kifejezetten üres szótárakra is állítottad az <code>eval()</code> hívásakor:
<pre class='nd screen'><samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm /valami/véletlen/fájl')", {}, {})</kbd></pre>

<p>Hoppá. Örülök, hogy nem csináltam meg azt az alfametikus webszolgáltatást. Létezik <em>valami</em> módszer az <code>eval()</code> biztonságos használatára? Hát, igen is meg nem is.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>eval("__import__('math').sqrt(5)",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp>
<samp class=p>>>> </samp><kbd class=pp>eval("__import__('subprocess').getoutput('rm -rf /')",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;string>", line 1, in &lt;module>
NameError: name '__import__' is not defined</samp></pre>
<ol>
<li>Megbízhatatlan kifejezések biztonságos kiértékeléséhez definiálnod kell egy globális névtérszótárat, amely leképezi a <code>"__builtins__"</code> modulnevet a Python null értékére, a <code>None</code>-ra. A felszín alatt a &#8222;beépített&#8221; függvényeket egy <code>"__builtins__"</code> nevű álmodul tartalmazza. Ez az álmodul (<i>azaz</i> a beépített függvények halmaza) elérhető a kiértékelt kifejezések számára, hacsak nem bírálod felül kifejezetten.
<li>Győződj meg róla, hogy a <code>__builtins__</code> modult bírálod felül. Nem a <code>__builtin__</code>, <code>__built-ins__</code> vagy valami más változatot, amely működni épp működik, de katasztrofális kockázatoknak tesz ki.
</ol>

<p>Akkor az <code>eval()</code> végre már biztonságos? Hát, igen is meg nem is.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>eval("2 ** 2147483647",</kbd>
<a><samp class=p>... </samp><kbd class=pp>    {"__builtins__":None}, {})</kbd>          <span class=u>&#x2460;</span></a>
</pre>
<ol>
<li>Még a <code>__builtins__</code> elérése nélkül is indíthatsz egy szolgáltatás megbénításával járó támadást. Például a <code>2</code> <code>2147483647</code>. hatványra emelése a kiszolgálód <abbr>CPU</abbr>-kihasználtságát meglehetősen hosszú időre 100%-ra tornázza fel. (Ha ezt az interaktív parancsértelmezőben próbáltad ki, akkor nyomd meg párszor a <kbd>Ctrl-C</kbd> kombinációt a megszakításához.) Technikailag ez a kifejezés idővel vissza <em>fog</em> adni egy értéket, de addig a kiszolgálód rengeteg értelmetlen számolást fog végezni.
</ol>

<p>Végső soron <em>lehetséges</em> biztonságosan kiértékelni megbízhatatlan Python kifejezéseket, a &#8222;biztonságos&#8221; bizonyos definíciója mellett, amely a való életben nem bizonyul annyira hasznosnak. Ez rendben van, ha csak játszol, és rendben van, ha mindig csak megbízható bemenetet adsz át. De minden más csak felhívás keringőre.

<p class=a>&#x2042;

<h2 id=alphametics-finale>Mindent összerakva</h2>

<p>Ismételjünk: ez a program alfametikus feladványokat old meg nyers erő használatával, <i>azaz</i> az összes lehetséges megoldás kimerítő keresése útján. Ehhez&hellip;
<ol>
<li><a href=#re-findall>Megkeresi a feladvány összes betűjét</a> a <code>re.findall()</code> függvénnyel
<li><a href=#unique-items>Megkeresi a feladvány összes <em>egyedi</em> betűjét</a> halmazokkal és <code>set()</code> függvénnyel
<li><a href=#assert>Ellenőrzi, hogy 10 egyedi betűnél több van-e</a> (ez azt jelentené, hogy a feladvány biztosan megoldhatatlan) egy <code>assert</code> utasítással
<li><a href=#generator-objects>A betűket átalakítja az ASCII megfelelőikre</a> egy generátorobjektummal
<li><a href=#permutations>Kiszámítja az összes lehetséges megoldást</a> az <code>itertools.permutations()</code> függvénnyel
<li><a href=#string-translate>Minden lehetséges megoldást átalakít Python kifejezéssé</a> a <code>translate()</code> karakterlánc-metódussal
<li><a href=#eval>Teszteli az összes lehetséges megoldást a Python kifejezést kiértékelve</a> az <code>eval()</code> függvénnyel
<li>Visszaadja az első megoldást, amely <code>True</code>-ra értékelődött ki
</ol>

<p>&hellip;mindössze 14 sor kódban.

<p class=a>&#x2042;

<h2 id=furtherreading>További olvasnivaló</h2>

<ul>
<li><a href=http://docs.python.org/3.1/library/itertools.html>Az <code>itertools</code> modul</a>
<li><a href=http://www.doughellmann.com/PyMOTW/itertools/><code>itertools</code>&nbsp;&ndash;&nbsp;Iterator functions for efficient looping</a>
<li><a href=http://blip.tv/file/1947373/>Nézd meg Raymond Hettinger &#8222;Easy AI with Python&#8221; előadását</a> a PyCon 2009-en
<li><a href=http://code.activestate.com/recipes/576615/>Recipe 576615: Alphametics solver</a>, Raymond Hettinger eredeti alfametikus megoldója a Python 2-höz
<li><a href=http://code.activestate.com/recipes/users/178123/>Több recept Raymond Hettingertől</a> az ActiveState kódtárolóban
<li><a href=http://en.wikipedia.org/wiki/Verbal_arithmetic>Alfametika a Wikipédián</a>
<li><a href=http://www.tkcs-collins.com/truman/alphamet/index.shtml>Alfametikus index</a>, amely <a href=http://www.tkcs-collins.com/truman/alphamet/alphamet.shtml>rengeteg feladványt</a> és <a href=http://www.tkcs-collins.com/truman/alphamet/alpha_gen.shtml>egy saját feladványok készítéséhez használható generátort</a> tartalmaz
</ul>

<p>Hatalmas köszönet Raymond Hettingernek, amiért beleegyezett kódja újralicencelésébe, így át tudtam portolni Python 3-ra, és felhasználhattam ezen fejezet alapjául.

<p class=v><a href=iterators.html rel=prev title='vissza az &#8222;Osztályok és iterátorokra&#8221;'><span class=u>&#x261C;</span></a> <a href=unit-testing.html rel=next title='tovább az &#8222;Egységtesztelésre&#8221;'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
