<!DOCTYPE html>
<meta charset=utf-8>
<title>Karakterláncok - Ugorj fejest a Python 3-ba</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 4}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Keresés></div></form>
<p>Itt vagy: <a href=index.html>Kezdőlap</a> <span
class=u>&#8227;</span> <a href=table-of-contents.html#strings>Ugorj fejest a Python 3-ba</a> <span class=u>&#8227;</span>
<p id=level>Nehézségi szint: <span class=u title=közepes>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Karakterláncok</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Azért mondom, mert az egyik barátom vagy. <br>
Az én ábécém ott kezdődik, ahol a tiéd véget ér! <span class=u>&#x275E;</span><br>&ndash; Dr. Seuss, On Beyond Zebra!
</blockquote>
<p id=toc>&nbsp;
<h2 id=boring-stuff>Unalmas dolgok, amelyeket meg kell értened a fejesugrás előtt</h2>
<p class=f>Kevesen gondolnak bele, de a szöveg hihetetlenül bonyolult. Kezdjük az ábécével. <a href=http://en.wikipedia.org/wiki/Bougainville_Province>Bougainville</a> lakosai rendelkeznek a világ legrövidebb ábécéjével, az ő <a href=http://en.wikipedia.org/wiki/Rotokas_alphabet>Rotokas ábécéjük</a> csak 12 betűből áll: A, E, G, I, K, O, P, R, S, T, U és V. A spektrum másik végén a kínai, japán, és koreai nyelvek állnak, több ezer karakterrel. Az angol természetesen 26 betűt tartalmaz&nbsp;&ndash;&nbsp;52-t, ha a kis- és nagybetűket külön számolod&nbsp;&ndash;&nbsp;, valamint néhány <i class=baa>!@#$%&amp;</i> írásjelet.
<p>Amikor &#8222;szövegről&#8221; beszélsz, akkor valószínűleg &#8222;a számítógéped képernyőjén megjelenő karakterekre és szimbólumokra&#8221; gondolsz. De a számítógépek nem karaktereket és szimbólumokat kezelnek, hanem biteket és bájtokat. Minden szöveg, amit valaha a számítógép képernyőjén láttál, valójában egy adott <i>karakterkódolásban</i> van tárolva. Nagy vonalakban a karakterkódolás biztosítja a leképezést a képernyőn látható és a számítógép által a memóriában és lemezen tárolt dolgok között. Számos különböző karakterkódolás létezik, egyesek adott nyelvekre vannak optimalizálva, például oroszra, kínaira vagy angolra, míg mások több nyelven is használhatók.

<p>A valóság ennél bonyolultabb. Sok karakter több kódolásban is közös, de az egyes kódolások eltérő bájtsorozatokat használhatnak ezen karakterek tárolására a memóriában vagy a lemezen. A karakterkódolásra emiatt egyfajta visszafejtési kulcsként gondolhatsz. Amikor valakitől kapsz egy bájtsorozatot&nbsp;&ndash;&nbsp;egy fájlt, weboldalt, akármit&nbsp;&ndash;&nbsp;és azt mondja, hogy ez &#8222;szöveg&#8221;, akkor a bájtok karakterekké dekódolásához tudnod kell, hogy melyik karakterkódolást használta. Ha rossz kulcsot kapsz, vagy nem is kapsz kulcsot, akkor magadra maradsz a kód feltörésének irigylésre nem méltó feladatával. Esélyes, hogy elrontod, az eredmény pedig értelmetlen zagyvaság lesz.
<aside>Minden, amit a karakterláncokról tudni véltél, téves.</aside>

<p>Bizonyára láttál már olyan weboldalakat, mint ez, amelyek fura kérdőjelszerű karaktereket tartalmaztak az aposztrófok vagy az ékezetes betűk helyén. Ez általában azt jelenti, hogy az oldal szerzője nem adta meg a karakterkódolását, a böngésződ pedig csak találgatni tudott, amelynek eredménye várt és váratlan karakterek keveréke lett. Angolul az ilyesmi csak zavaró, de más nyelveken, például magyarul az eredmény teljesen olvashatatlan is lehet.

<p>A világ minden jelentős nyelvéhez léteznek karakterkódolások. Mivel minden nyelv különböző, és a memória- és lemezterület történelmileg drága volt, minden karakterkódolás az adott nyelvre van optimalizálva. Ez alatt azt értem, hogy minden kódolás ugyanazokat a számokat(0&ndash;255) használta az adott nyelv karaktereinek ábrázolására. Például valószínűleg ismered az <abbr>ASCII</abbr> kódolást, amely az angol karaktereket 0 - 127 közti számokként tárolja. (A 65 a nagybetűs &#8222;A&#8221;, a 97 a kisbetűs &#8222;a&#8221; stb.) Az angol ábécé nagyon egyszerű, így teljes egészében leírható kevesebb, mint 128 számmal. Azok számára, akik tudnak 2-es alapon számolni, ez egy bájt 8 bitjéből 7-et jelent.

<p>Az olyan nyugat-európai nyelvek, mint a francia, spanyol és német, több betűvel rendelkeznek, mint az angol. Pontosabban vannak mellékjelekkel kombinált betűik, mint a <code>&ntilde;</code> karakter a spanyolban. A leggyakoribb kódolás ezekhez a nyelvekhez a CP-1252, amelyet &#8222;windows-1252&#8221;-nek is neveznek, mert széles körben használatos Microsoft Windowson. A CP-1252 kódolás átveszi az <abbr>ASCII</abbr> kódolás által a 0&ndash;127 tartományban használt karaktereket, de aztán kiterjed a 128&ndash;255 tartományra az olyan karakterekhez, mint az n hullámvonallal (241), ü (252) stb. Ez továbbra is egybájtos kódolás, a legnagyobb lehetséges szám, a 255 továbbra is elfér egy bájton.

<p>Egyes nyelvek, például a kínai, japán és koreai olyan sok karakterrel rendelkeznek, hogy több-bájtos karakterkészleteket igényelnek. Ez azt jelenti, hogy minden&#8222;karaktert&#8221; egy kétbájtos szám képvisel 0&ndash;65535 között. De a különböző több-bájtos kódolások ugyanazzal a problémával szembesülnek, mint a különböző egybájtos kódolások, vagyis hogy mind ugyanazokat a számokat használja különböző értelmű dolgokra. Egyszerűen csak a számok tartománya nagyobb, mert sokkal több karaktert kell ábrázolni.

<p>Ez nagyjából rendben volt a hálózatok előtti világban, ahol a &#8222;szöveget&#8221; magadnak írtad be, és néha kinyomtattad. Nem volt sok&#8222;sima szöveg&#8221;. A forráskód <abbr>ASCII</abbr> volt, és mindenki más szövegszerkesztőket használt, amelyek saját (nem szöveges) formátumokat használtak, amelyek nyilvántartották a karakterkódolási információkat a gazdag formázási stílusokkal stb. együtt. Ezeket a dokumentumokat ugyanazzal a szövegszerkesztővel olvasták, mint az eredeti szerző, így minden működött, többé-kevésbé.

<p>Most gondolj az olyan globális hálózatok felemelkedésére, mint az e-mail és a web. Rengeteg &#8222;sima szöveg&#8221; repüli körbe a földgolyót, amelyeket az egyik számítógépen írnak, a másikon továbbítanak, a harmadikon pedig fogadnak és megjelenítenek. A számítógépek csak számokat látnak, de a számok különböző dolgokat jelenthetnek. Jaj ne! Mit kéne csinálni? Nos, a rendszereket arra kellett tervezni, hogy minden &#8222;sima szöveggel&#8221; együtt átvigyék a kódolási információkat. Ne feledd, a visszafejtési kulcs képezi le a számítógépek által olvasható számokat az ember által olvasható karakterekre. Egy hiányzó visszafejtési kulcs téves, olvashatatlan vagy még rosszabb szöveget eredményez.

<p>Most gondolj arra, hogy egy helyen több szövegdarabot kell tárolni, például ugyanabban az adatbázistáblában, amely az általad valaha kapott összes e-mailt tárolja. Ekkor is tárolni kell a karakterkódolást minden szövegdarab mellett, hogy megfelelően jeleníthesd meg. Az hiszed ez nehéz? Próbálj meg az e-mail adatbázisodban keresni, ez több kódolás közti menet közbeni konvertálást jelent. Ugye milyen jól hangzik?

<p>Most gondolj a többnyelvű dokumentumok lehetőségére, ahol több nyelv karakterei vannak egymás mellett ugyanabban a dokumentumban. (Tipp: az ezzel próbálkozó programok általában escape kódokat használtak a &#8222;módok&#8221; közti váltáshoz. Puff, most orosz koi8-r módban vagy, így a 241 jelentése Я; puff, most Mac Greek módban vagy, így a 241 jelentése ώ.) És természetesen keresni is akarsz <em>azokban</em> a dokumentumokban is.

<p>Most elbőgheted magad, mert minden, amit a karakterláncokról tudni véltél, téves, és nincs olyan, hogy &#8222;sima szöveg&#8221;.
<p class=a>&#x2042;

<h2 id=one-ring-to-rule-them-all>Unicode</h2>

<p><i>Színre lép a <dfn>Unicode</dfn>.</i>

<p>A Unicode rendszert arra tervezték, hogy <em>minden</em> nyelv <em>minden</em> karakterét ábrázolni tudja. A Unicode minden betűt, karaktert vagy ideogrammát egy 4 bájtos számként ábrázol. Minden szám egy egyedi karaktert képvisel, amelyet legalább egy nyelvben használnak. (Nem minden szám van használatban, de több, mint 65535, így 2 bájt nem lenne elég.) A több nyelvben használt karakterek általában ugyanazzal a számmal rendelkeznek, kivéve ha komoly etimológiai érvek szólnak ez ellen. Ennek ellenére karakterenként pontosan egy szám van, és számonként pontosan egy karakter. Minden szám mindig egy dolgot jelent; nincsenek nyilvántartandó &#8222;módok&#8221;. Az <code>U+0041</code> mindig az <code>'A'</code>, még ha egy adott nyelvben nincs is <code>'A'</code> karakter.
<p>A felszínen ez jó ötletnek tűnik. Egy kódolás mind felett. Több nyelv ugyanabban a dokumentumban. Nincs több &#8222;módváltás&#8221; a kódolások adatfolyamon belüli váltásához. De azonnal adja magát a nyilvánvaló kérdés. Négy bájt? Minden egyes karakterhez<span class=u title='interrobang!'>&#8253;</span> Ez rettenetesen pazarlónak tűnik, különösen olyan nyelvekhez, mint az angol vagy a spanyol, amelyek egy bájtnál (256 számnál) is kevesebbet igényelnek minden lehetséges karakter leírásához. Valójában még az ideogrammákat használó nyelvek (mint a kínai) esetén is pazarló, mert ezekhez sem kell karakterenként két bájtnál több soha.

<p>Van egy Unicode kódolás, amely karakterenként négy bájtot használ. A neve UTF-32, mert 32 bit = 4 bájt. Az UTF-32 egy magától értetődő kódolás; veszi az összesUnicode karaktert (egy 4 bájtos szám), és azt a karaktert ugyanazzal a számmal ábrázolja. Ennek vannak előnyei, a legfontosabb, hogy egy karakterlánc <var>N.</var> karakterét állandó idő alatt lehet megtalálni, mert az <var>N.</var> karakter a <var>4&times;N.</var> bájtnál kezdődik. Van sok hátránya is, a legnyilvánvalóbb, hogy négy nyomorult bájtot igényel minden nyomorult karakter tárolásához.

<p>Noha rengeteg Unicode karakter van, a legtöbben gyakorlatilag nem fognak soha semmit használni az első 65535-ön kívül. Emiatt létezik egy másik Unicode kódolás is, az UTF-16 (mert 16 bit = 2 bájt). Az UTF-16 minden karaktert 0&ndash;65535 között tárol két bájton, és piszkos trükköket használ, ha a ritkán használt, &#8222;asztrálsíkon&#8221; lévő Unicode karaktereket kell ábrázolnod a 65535 fölött. A legnyilvánvalóbb előny: Most az UTF-16 kétszer olyan helytakarékos, mint az UTF-32, mert minden karakter tárolása pontosan két bájtot igényel csak négy bájt helyett (kivéve amelyiké nem). És még mindig egyszerűen és konstans idő alatt megtalálható egy karakterlánc <var>N.</var> karaktere, ha feltételezzük, hogy a karakterlánc nem tartalmazza az asztrálsíkon lévő karakterek egyikét sem. Ez egy jó feltételezés, egészen addig, amíg már nem.

<p>Azonban az UTF-32 és az UTF-16 egyaránt rendelkezik nem nyilvánvaló hátrányokkal. A különböző számítógéprendszerek az egyes bájtokat különböző módokon tárolják. Ez azt jelenti, hogy az <code>U+4E2D</code> karakter UTF-16 használatakor tárolható <code>4E 2D</code> vagy <code>2D 4E</code> formában is, attól függően, hogy a rendszer big-endian vagy little-endian. (Az UTF-32 esetén még több lehetséges bájtsorrend van.) Amíg a dokumentumaid soha nem hagyják el a számítógéped, biztonságban vagy&nbsp;&ndash;&nbsp;ugyanazon számítógép különböző alkalmazásai ugyanazt a bájtsorrendet használják. Azonban abban a percben, hogy dokumentumokat akarsz rendszerek között átvinni, mondjuk valamilyen világszintű hálózaton, akkor jelezned kell a bájtjaid tárolási sorrendjét. Ellenkező esetben a fogadó rendszer nem fogja tudni, hogy a <code>4E 2D</code> kétbájtos sorozat jelentése <code>U+4E2D</code> vagy <code>U+2D4E</code>.
<p><em>Ennek</em> a problémának a megoldásához a több-bájtos Unicode kódolások definiálnak egy &#8222;bájtsorrendjelet&#8221;, amely egy speciális nem nyomtatható  karakter. Ezt a dokumentum elején elhelyezve jelezheted a bájtok sorrendjét. Az UTF-16 esetén a bájtsorrendjel az <code>U+FEFF</code>. Ha egy <code>FF FE</code> bájtokkal kezdődő UTF-16 dokumentumot kapsz, akkor a bájtsorrend az egyik, ha az <code>FE FF</code> bájtokkal kezdődik, akkor a bájtsorrend a másik.

<p>Az UTF-16 ezzel együtt sem teljesen ideális, különösen ha rengeteg <abbr>ASCII</abbr> karakterrel dolgozol. Ha belegondolsz, akkor még egy kínai weboldal is rengeteg <abbr>ASCII</abbr> karaktert fog tartalmazni&nbsp;&ndash;&nbsp;a nyomtatható kínai karaktereket körülvevő összes elemet és attribútumot. Az <var>N.</var> karakter konstans idő alatti megtalálása szép dolog, de még itt van az asztrálsíkon lévő karakterek kellemetlen problémája, ami miatt nem tudod <em>garantálni</em>, hogy minden karakter pontosan két bájtos, emiatt nem lehet <em>valóban</em> megtalálni az <var>N.</var> karaktert konstans idő alatt, hacsak nem tartasz fenn egy külön indexet. És tudod, annyi de annyi <abbr>ASCII</abbr> szöveg van a világban&hellip;
<p>Mások is gondolkoztak ezeken a kérdéseken, és kitaláltak egy megoldást:

<p class=xxxl>UTF-8

<p>Az UTF-8 egy <em>változó hosszúságú</em> kódolási rendszer a Unicode-hoz. Ez azt jelenti, hogy különböző karakterek különböző számú bájtot foglalnak. Az <abbr>ASCII</abbr> karakterekhez (A-Z stb.) az <abbr>UTF-8</abbr> karakterenként csak egy bájtot használ. Tulajdonképpen pontosan ugyanazokat a bájtokat használja. Az <abbr>UTF-8</abbr> első 128 karaktere (0&ndash;127) megkülönböztethetetlen az <abbr>ASCII</abbr>-étól. A &#8222;kiterjesztett latin&#8221; karakterek, mint a &ntilde; és &ouml; két bájtot foglalnak. (A bájtok nem egyszerűen az Unicode kódpontot jelentik, mint UTF-16 esetén; komoly bittologatás is szerepet kap.) A kínai karakterek, mint a &#x4E2D; három bájtot foglalnak. A ritkán használt &#8222;asztrálsík&#8221; karakterek négy bájtot.

<p>Hátrányok: mivel minden karakter különböző számú bájtot foglalhat, az <var>N.</var> karakter megkeresése egy O(N) művelet&nbsp;&ndash;&nbsp;azaz minél hosszabb a karakterlánc, annál tovább tart egy adott karakter megkeresése. Ezen kívül bittologatás szükséges a karakterek bájtokká kódolásához és a bájtok visszafejtéséhez karakterekké.

<p>Előnyök: az általános <abbr>ASCII</abbr> karakterek kódolása szuperhatékony. Nem rosszabb az UTF-16-nál a kiterjesztett latin karakterek esetén. Jobb az UTF-32-nél a kínai karakterekhez. Ezen túl (és ezt el kell hinned nekem, mert nem fogom megmutatni a matekját) pontosan a bittologatás természete miatt nincsenek problémák a bájtsorrendből. Egy <abbr>UTF-8</abbr> kódolású dokumentum pontosan ugyanazt a bájtsorozatot használja minden számítógépen.

<p class=a>&#x2042;

<h2 id=divingin>Ugorj fejest</h2>

<p>A Python 3-ban minden karakterlánc Unicode karakterek sorozata. Nincs olyan, hogy <abbr>UTF-8</abbr> kódolású Python karakterlánc, vagy CP-1252 kódolású Python karakterlánc. Az &#8222;<abbr>UTF-8</abbr> ez a karakterlánc?&#8221; kérdés érvénytelen. Az <abbr>UTF-8</abbr> a karakterek bájtok sorozataként való kódolásának módja. Ha egy adott karakterláncot át szeretnél alakítani adott karakterkódolású bájtok sorozatává, akkor a Python 3 megoldja. Ha egy adott bájtsorozatot karakterlánccá szeretnél alakítani, akkor a Python 3 azt is megoldja. A bájtok nem karakterek, a bájtok bájtok. A karakter egy absztrakció. Egy karakterlánc ezen absztrakciók sorozata.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>s = '深入 Python'</kbd>     <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>len(s)</kbd>               <span class=u>&#x2461;</span></a>
<samp class=pp>9</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s[0]</kbd>                 <span class=u>&#x2462;</span></a>
<samp class=pp>'深'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s + ' 3'</kbd>             <span class=u>&#x2463;</span></a>
<samp class=pp>'深入 Python 3'</samp></pre>
<ol>
<li>Egy karakterlánc létrehozásához zárd azt idézőjelek közé. A Python karakterláncok meghatározhatók egyszeres (<code>'</code>) vagy dupla idézőjelekkel (<code>"</code>). <!--"-->
<li>A beépített <code><dfn>len</dfn>()</code> függvény visszaadja a karakterlánc hosszát, <i>azaz</i> a karakterek számát. Ez ugyanaz a függvény, amit a <a href=native-datatypes.html#extendinglists>listák, tuple-ök, halmazok vagy szótárak hosszának meghatározására</a> használtál. A karakterlánc olyan, mint egy karaktertuple.
<li>Ahogy a listák egyes elemei, úgy a karakterláncok egyes karakterei is elérhetők indexelés használatával.
<li>Ahogyan listákat, úgy a karakterláncokat is <dfn>összefűzheted</dfn> a <code>+</code> operátor használatával.
</ol>

<p class=a>&#x2042;

<h2 id=formatting-strings>Karakterláncok formázása</h2>

<aside>A karakterláncok egyszeres vagy dupla idézőjelekkel definiálhatók.</aside>
<p>Vessünk még egy pillantást a <a href=your-first-python-program.html#divingin><code>humansize.py</code></a> programra:

<p class=d>[<a href=examples/humansize.py>a <code>humansize.py</code> letöltése</a>]
<pre class=pp><code><a>SUFFIXES = {1000: ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],         <span class=u>&#x2460;</span></a>
            1024: ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']}

def approximate_size(size, a_kilobyte_is_1024_bytes=True):
<a>    '''Egy fájlméret emberek által olvasható formába konvertálása.          <span class=u>&#x2461;</span></a>

    Kulcsszó argumentumok:
    size -- a fájlméret bájtban
    a_kilobyte_is_1024_bytes -- ha True (alapértelmezett), akkor az 1024 többszöröseit használja
                                ha False, akkor az 1000 többszöröseit használja

    Visszaad: karakterláncot

<a>    '''                                                                     <span class=u>&#x2462;</span></a>
    if size &lt; 0:
<a>        raise ValueError('a szám nem lehet negatív')                        <span class=u>&#x2463;</span></a>

    multiple = 1024 if a_kilobyte_is_1024_bytes else 1000
    for suffix in SUFFIXES[multiple]:
        size /= multiple
        if size &lt; multiple:
<a>            return '{0:.1f} {1}'.format(size, suffix)                       <span class=u>&#x2464;</span></a>

    raise ValueError('a szám túl nagy')</code></pre>
<ol>
<li><code>'KB'</code>, <code>'MB'</code>, <code>'GB'</code>&hellip; ezek mind karakterláncok.
<li>A függvény docstringjei is karakterláncok. Ez a docstring többsoros, emiatt három egymás utáni idézőjelet használ a karakterlánc kezdésére és befejezésére.
<li>Ez a három egymás utáni idézőjel zárja a docstringet.
<li>Ez egy újabb karakterlánc, emberek által olvasható hibaüzenetként átadva a kivételnek.
<li>Ez egy&hellip; hé, hát ez meg mi?
</ol>

<p>A Python 3 támogatja az értékek karakterláncokba <dfn>formázását</dfn>. Noha ez nagyon bonyolult kifejezéseket is tartalmazhat, a legalapvetőbb felhasználási módja egy értéknek helykitöltőt tartalmazó karakterláncba való beszúrása.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>felhasználó = 'mark'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>jelszó = 'PapayaWhip'</kbd>                               <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>"{0} jelszava ez: {1}".format(felhasználó, jelszó)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>"mark jelszava ez: PapayaWhip"</samp></pre>
<ol>
<li>Nem, a jelszavam igazából nem <kbd>PapayaWhip</kbd>.
<li>Rengeteg minden történik itt. Először is, ez egy metódushívás egy karakterliterálon. <em>A karakterláncok objektumok</em>, és az objektumoknak metódusaik vannak. Másodszor, az egész kifejezés egy karakterlánccá értékelődik ki. Harmadszor, a <code>{0}</code> és a <code>{1}</code> <i>helyettesítőmezők</i>, amelyeket a <code><dfn>format</dfn>()</code> metódusnak átadott argumentumok helyettesítenek.
</ol>

<h3 id=compound-field-names>Összetett mezőnevek</h3>

<p>Az előző példa a legegyszerűbb esetet mutatja be, ahol a helyettesítőmezők egyszerű egészek. Az egész helyettesítőmezők helyzeti indexekként vannak kezelve a <code>format()</code> metódus argumentumlistájában. Ez azt jelenti, hogy a <code>{0}</code> az első argumentummal lesz helyettesítve (<var>felhasználó</var> ebben az esetben), a <code>{1}</code> a második argumentummal lesz helyettesítve (<var>jelszó</var>) stb. Annyi helyzeti indexed lehet, ahány argumentumod van, és annyi argumentumod lehet, amennyit csak akarsz. De a helyettesítőmezők ennél sokkal hatékonyabbak.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>si_suffixes = humansize.SUFFIXES[1000]</kbd>      <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>si_suffixes</kbd>
<samp class=pp>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>'1000{0[0]} = 1{0[1]}'.format(si_suffixes)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'1000KB = 1MB'</samp>
</pre>
<ol>
<li>A <code>humansize</code> modul valamelyik függvényének hívása helyett csak az általa definiált egyik adatszerkezetet használjuk: az &#8222;SI&#8221; utótagok (ezek 1000 hatványai) listáját.
<li>Ez bonyolultnak tűnik, de nem az. A <code>{0}</code> a <code>format()</code> metódusnak elsőként átadott argumentumra, az <var>si_suffixes</var>-re hivatkozik. De az <var>si_suffixes</var> egy lista. Így a <code>{0[0]}</code> a lista első elemére hivatkozik, ez lesz a <code>format()</code> metódusnak átadott első argumentum: <code>'KB'</code>. Ezalatt a <code>{0[1]}</code> ugyanazon lista második elemére hivatkozik: <code>'MB'</code>. A kapcsos zárójeleken kívül minden&nbsp;&ndash;&nbsp;beleértve az <code>1000</code>-t, az egyenlőségjelet és a szóközket&nbsp;&ndash;&nbsp;érintetlen. A végeredmény a következő karakterlánc:<code>'1000KB = 1MB'</code>.
</ol>

<aside>A {0} a format() első argumentumára lesz cserélve. A {1} a másodikra. </aside>
<p>Ez a példa azt mutatja meg, hogy a <em>formátumelőírások az adatszerkezetek elemeit és tulajdonságait (majdnem) Python szintaxissal tudják elérni</em>. Ezeket <i>összetett mezőneveknek</i> hívjuk. A következő összetett mezőnevek &#8222;egyszerűen csak működnek&#8221;:

<ul>
<li>Lista átadása, és a lista egy elemének elérése index alapján (mint az előző példában)
<li>Szótár átadása, és a szótár értékének elérése kulcs alapján
<li>Modul átadása, és a változóinak és függvényeinek elérése név alapján
<li>Osztálypéldány átadása, és a tulajdonságainak és metódusainak elérése név alapján
<li><em>A fentiek tetszőleges kombinációja</em>
</ul>

<p>Csak hogy ne alhass nyugodtan, itt egy példa, amely a fentiek mindegyikét kombinálja:

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<samp class=p>>>> </samp><kbd class=pp>import sys</kbd>
<samp class=p>>>> </samp><kbd class=pp>'1MB = 1000{0.modules[humansize].SUFFIXES[1000][0]}'.format(sys)</kbd>
<samp class=pp>'1MB = 1000KB'</samp></pre>

<p>Így működik:

<ul>
<li>A <code>sys</code> modul információkat tárol az éppen futó Python példányról. Mivel importáltad, átadhatod magát a <code>sys</code> modult a <code>format()</code> metódus argumentumaként. Így a <code>{0}</code> helyettesítőmező a <code>sys</code> modulra hivatkozik.
<li>A <code>sys.modules</code> az aktuális Python példányba importált összes modult tartalmazó szótár. A kulcsok a modulnevek karakterláncokként, az értékek maguk a modulobjektumok. Így a <code>{0.modules}</code> helyettesítőmező az importált modulok szótárára hivatkozik.
<li>A <code>sys.modules['humansize']</code> az éppen importált <code>humansize</code> modul. A <code>{0.modules[humansize]}</code> helyettesítőmező a <code>humansize</code> modulra hivatkozik. Vedd észre az apró eltérést a szintaxisban. Valódi Python kódban a <code>sys.modules</code> szótár kulcsai karakterláncok, a rájuk való hivatkozáshoz idézőjelek közé kell tenned a modulnevet (<i>például:</i> <code>'humansize'</code>). Helyettesítőmezőben azonban el kell hagyni a szótárkulcs neve körüli idézőjeleket (<i>például:</i> <code>humansize</code>). A <a href=http://www.python.org/dev/peps/pep-3101/>PEP 3101: speciális karakterlánc-formázás</a> szerint: &#8222;Az elem kulcsának feldolgozási szabályai nagyon egyszerűek. Ha számjeggyel kezdődik, akkor számként lesz kezelve, ellenkező esetben karakterláncként.&#8221;

<li>A <code>sys.modules['humansize'].SUFFIXES</code> a <code>humansize</code> modul elején definiált szótár. A <code>{0.modules[humansize].SUFFIXES}</code> helyettesítőmező erre a szótárra hivatkozik.
<li>A <code>sys.modules['humansize'].SUFFIXES[1000]</code> az <abbr>SI</abbr>-utótagok listája: <code>['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']</code>. Így a <code>{0.modules[humansize].SUFFIXES[1000]}</code> helyettesítőmező erre a listára hivatkozik.
<li>A <code>sys.modules['humansize'].SUFFIXES[1000][0]</code> az <abbr>SI</abbr>-utótagok listájának első eleme: <code>'KB'</code>. Emiatt a teljes <code>{0.modules[humansize].SUFFIXES[1000][0]}</code> helyettesítőmező a két karakterből álló <code>KB</code> karakterláncra lesz cserélve.
</ul>

<h3 id=format-specifiers>Formátum-előírások</h3>

<p>Várj csak! Van még más is! Nézzük meg újra ezt a fura sort a <code>humansize.py</code> fájlból:

<pre class='nd pp'><code>if méret &lt; multiple:
    return '{0:.1f} {1}'.format(méret, utótag)</code></pre>

<p>Az <code>{1}</code> a <code>format()</code> metódusnak átadott második argumentumra lesz cserélve, amely az <var>utótag</var>. De mi ez a <code>{0:.1f}</code>? Ez két dolog: a <code>{0}</code>, amit már felismersz, és a <code>:.1f</code>, amit még nem. A második fele (a kettőspont és ami utána áll) definiálja a <i>formátum-előírást</i>, amely tovább finomítja a helyettesített változó formázásának módját.

<blockquote class='note compare clang'>
<p><span class=u>&#x261E;</span>A formátum-előírások lehetővé teszik a helyettesítőszöveg változatos módokon való megpiszkálását, mint a C <code><dfn>printf</dfn>()</code> függvényében. Hozzáadhatsz nulla- vagy szóközkitöltést, igazíthatod a karakterláncokat, befolyásolhatod a tizedesjegyek számát, és akár hexadecimálissá is alakíthatsz számokat.
</blockquote>

<p>A helyettesítőmezőn belül egy kettőspont (<code>:</code>) jelöli a formátum-előírás kezdetét. A &#8222;<code>.1</code>&#8221; formátum-előírás &#8222;a legközelebbi tizedesre kerekítést&#8221; jelent (<i>azaz</i> csak egy számjegy jelenik meg a tizedesvessző után). Az &#8222;<code>f</code>&#8221; formátum-előírás &#8222;fixpontos számot&#8221; jelöl (nem pedig exponenciális jelölést vagy más decimális ábrázolást). Emiatt a <code>698.24</code> <var>méret</var> és a <code>'GB'</code> <var>utótag</var> esetén a formázott karakterlánc <code>'698.2 GB'</code> lesz, mert a <code>698.24</code> egy tizedesjegyre lesz kerekítve, majd az utótag a szám mögé lesz fűzve.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>'{0:.1f} {1}'.format(698.24, 'GB')</kbd>
<samp class=pp>'698.2 GB'</samp></pre>

<p>A formátum-előírásokkal kapcsolatos véres részletekért olvasd el a <a href=http://docs.python.org/3.1/library/string.html#format-specification-mini-language>Format Specification Mini-Language</a> oldalt a hivatalos Python dokumentációban.

<p class=a>&#x2042;

<h2 id=common-string-methods>Egyéb gyakori karakterlánc-metódusok</h2>

<p>A formázás mellett a karakterláncok sok más hasznos trükköt is tudnak.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd>s = '''A befejezett tanul-</kbd>         <span class=u>&#x2460;</span></a>
<samp class=p>... </samp><kbd>mányok több évnyi tudományos mun-</kbd>
<samp class=p>... </samp><kbd>ka és az évek tapasztala-</kbd>
<samp class=p>... </samp><kbd>tának egyesített eredménye.'''</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.splitlines()</kbd>                     <span class=u>&#x2461;</span></a>
<samp class=pp>['A befejezett tanul-',
 'mányok több évnyi tudományos mun-',
 'ka és az évek tapasztala-',
 'tának egyesített eredménye.']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(s.lower())</kbd>                   <span class=u>&#x2462;</span></a>
<samp>a befejezett tanul-
mányok több évnyi tudományos mun-
ka és az évek tapasztala-
tának egyesített eredménye.</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.lower().count('m')</kbd>               <span class=u>&#x2463;</span></a>
<samp class=pp>4</samp></pre>
<ol>
<li>Az interaktív Python parancsértelmezőben beírhatsz <dfn>többsoros</dfn> karakterláncokat is. Miután elkezdtél egy többsoros karakterláncot a tripla idézőjellel, nyomd meg az <kbd>ENTERT</kbd>, és az interaktív parancsértelmező a karakterlánc folytatását fogja várni. A záró tripla idézőjel beírása befejezi a karakterláncot, és a következő <kbd>ENTER</kbd> végrehajtja a parancsot (ebben az esetben a karakterlánc hozzárendelését az <var>s</var> változóhoz).
<li>A <code><dfn>splitlines</dfn>()</code> metódus egy többsoros karakterláncot vár, és karakterláncok listáját adja vissza, az eredeti minden sorához egyet rendelve. Ne feledd, hogy a sorok végén lévő kocsivissza karaktereket ez nem tartalmazza.
<li>A <code>lower()</code> metódus az egész karakterláncot kisbetűssé alakítja. (Hasonlóan, az <code>upper()</code> metódus egy karakterláncot nagybetűssé alakít.)
<li>A <code>count()</code> metódus megszámolja egy részkarakterlánc előfordulásainak számát. Igen, ebben a mondatban tényleg négy &#8222;m&#8221; van!
</ol>

<p>Itt van még egy gyakori eset. Mondjuk, hogy van egy kulcs-érték párokat tartalmazó listád, a következő formátumban: <code><var>kulcs1</var>=<var>érték1</var>&amp;<var>kulcs2</var>=<var>érték2</var></code>; és fel szeretnéd darabolni ezeket, hogy az egészet betehesd egy <code>{kulcs1: érték1, kulcs2: érték2}</code> alakú szótárba.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>lekérdezés = 'felhasználó=pilgrim&amp;adatbázis=master&amp;jelszó=PapayaWhip'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = lekérdezés.split('&amp;')</kbd>                                   <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list</kbd>
<samp class=pp>['felhasználó=pilgrim', 'adatbázis=master', 'jelszó=PapayaWhip']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list_of_lists = [v.split('=', 1) for v in a_list if '=' in v]</kbd>  <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_list_of_lists</kbd>
<samp class=pp>[['felhasználó', 'pilgrim'], ['adatbázis', 'master'], ['jelszó', 'PapayaWhip']]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_dict = dict(a_list_of_lists)</kbd>                                   <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>a_dict</kbd>
<samp class=pp>{'jelszó': 'PapayaWhip', 'felhasználó': 'pilgrim', 'adatbázis': 'master'}</samp></pre>

<ol>
<li>A <code><dfn>split</dfn>()</code> karakterlánc-metódus egy kötelező argumentummal, a határolóval rendelkezik. A metódus a karakterláncot a határoló alapján karakterláncok listájává darabolja. Itt a határoló az &amp; karakter, de bármi lehet.
<li>Most van egy karakterlánclistánk, mindegyikhez tartozik egy kulcs, amelyet egy egyenlőségjel és végül egy érték követ. Egy <a href=comprehensions.html#listcomprehension>listafeldolgozó</a> segítségével bejárjuk a teljes listát, és minden karakterláncot az első egyenlőségjelnél kétfelé vágunk. A <code>split()</code> metódus elhagyható második argumentuma a szétvágások kívánt száma. Az <code>1</code> &#8222;csak egy szétvágást&#8221; jelent, így a<code>split()</code> metódus egy kételemű listát fog visszaadni. (Elméletileg egy érték is tartalmazhat egyenlőségjelet. Ha a <code>'kulcs=érték=valami'.split('=')</code> hívást használtad volna, akkor a <code>['kulcs', 'érték', 'valami']</code> háromelemű listát kaptad volna.)
<li>Végül a Python ezt a listák listáját szótárrá változtatja a <code>dict()</code> függvénynek való átadással.
</ol>

<blockquote class=note>
<p><span class=u>&#x261E;</span>Az előző példa nagyon úgy néz ki, mint egy <abbr>URL</abbr> lekérésparamétereinek feldolgozása, de a valós életben az <abbr>URL</abbr>-feldolgozás valójában ennél sokkal bonyolultabb. Ha <abbr>URL</abbr>-lekérdezésparaméterekkel dolgozol, akkor jobban jársz az <a href=http://docs.python.org/3.1/library/urllib.parse.html#urllib.parse.parse_qs><code>urllib.parse.parse_qs()</code></a> függvénnyel, amely kezel néhány nem nyilvánvaló határesetet is.
</blockquote>

<h3 id=slicingstrings>Karakterlánc szeletelése</h3>
<p>Miután definiáltál egy karakterláncot, bármely részét megkaphatod új karakterláncként. Ezt
a karakterlánc <i>szeletelésének</i> nevezzük. A szeletelés pontosan ugyanúgy működik, mint a <a href=native-datatypes.html#slicinglists>listák szeletelése</a>, ami logikus is, hiszen a karakterláncok pusztán karakterek sorozatai.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_string = 'Az én ábécém ott kezdődik, ahol a tiéd véget ér.'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[6:12]</kbd>           <span class=u>&#x2460;</span></a>
<samp class=pp>'ábécém'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[6:-6]</kbd>           <span class=u>&#x2461;</span></a>
<samp class=pp>'ábécém ott kezdődik, ahol a tiéd vég'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[0:2]</kbd>            <span class=u>&#x2462;</span></a>
<samp class=pp>'Az'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[:25]</kbd>            <span class=u>&#x2463;</span></a>
<samp class=pp>'Az én ábécém ott kezdődik'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_string[25:]</kbd>            <span class=u>&#x2464;</span></a>
<samp class=pp>', ahol a tiéd véget ér.'</samp></pre>
<ol>
<li>Egy karakterlánc &#8222;szeletnek&#8221; nevezett bármely részét megkaphatod két index megadásával. A visszatérési érték egy új karakterlánc, amely a karakterlánc minden elemét az eredeti sorrendben tartalmazza az első szeletindextől kezdve.
<li>A listák szeleteléséhez hasonlóan negatív indexeket is használhatsz a karakterláncok szeleteléséhez.
<li>A karakterláncok indexelése nullától kezdődik, így az <code>a_string[0:2]</code> a karakterlánc első két elemét adja vissza az <code>a_string[0]</code> elemtől az <code>a_string[2]</code> elemig, de az utóbbit már nem tartalmazza.
<li>Ha a bal oldali szeletindex a 0, akkor kihagyható, és a Python a 0-t feltételezi. Így az <code>a_string[:25]</code> ugyanaz, mint az <code>a_string[0:25]</code> mert a kezdő 0-t a Python feltételezi.
<li>Hasonlóan, ha a jobb oldali szeletindex az utolsó elem indexe, akkor kihagyható. Így az <code>a_string[25:]</code> ugyanaz, mint az
<code>a_string[25:48]</code>, mert ez a karakterlánc 48 karaktert tartalmaz. Van itt egy kellemes szimmetria. Ebben a 48 karakteres karakterláncban az <code>a_string[:25]</code> visszaadja az első 25 karaktert, és az <code>a_string[25:]</code> visszaad mindent az első 25 karakter kivételével. Tulajdonképpen az <code>a_string[:<var>n</var>]</code>
mindig az első <var>n</var> karaktert adja vissza, az
<code>a_string[<var>n</var>:]</code> pedig a többit, a karakterlánc hosszától
függetlenül.
</ol>

<p class=a>&#x2042;

<h2 id=byte-arrays>Karakterláncok és bájtok</h2>

<p>A <dfn>bájtok</dfn> bájtok; a karakterek absztrakciók. Unicode karakterek megváltoztathatatlan sorozatát <i>karakterláncnak</i> hívjuk. A 0 és 255 közötti számok megváltoztathatatlan sorozatát <i>bájtobjektumnak</i> hívjuk.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>by = b'abcd\x65'</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'abcde'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>type(by)</kbd>          <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;class 'bytes'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>           <span class=u>&#x2462;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by += b'\xff'</kbd>     <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'abcde\xff'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>           <span class=u>&#x2464;</span></a>
<samp class=pp>6</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by[0]</kbd>             <span class=u>&#x2465;</span></a>
<samp class=pp>97</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by[0] = 102</kbd>       <span class=u>&#x2466;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: 'bytes' object does not support item assignment</samp></pre>
<ol>
<li>Egy <code>bájtobjektum</code> definiálásához használd a <code>b''</code> &#8222;<dfn>bájtliterál</dfn>&#8221; szintaxist. A bájtliterálon belül minden bájt lehet egy <abbr>ASCII</abbr> karakter, vagy egy kódolt hexadecimális szám <code>\x00</code> és <code>\xff</code> (0&ndash;255) között.
<li>A <code>bájtobjektum</code> típusa <code>bytes</code>.
<li>A listákhoz és karakterláncokhoz hasonlóan a beépített <code>len()</code> függvénnyel lekérheted a <code>bájtobjektum</code> hosszát.
<li>A listákhoz és karakterláncokhoz hasonlóan használhatod a <code>+</code> operátort a <code>bájtobjektumok</code> összefűzésére. Az eredmény egy új <code>bájtobjektum</code>.
<li>Egy 5 bájtos <code>bájtobjektum</code> és egy 1 bájtos <code>bájtobjektum</code> összefűzése egy 6 bájtos <code>bájtobjektumot</code> eredményez.
<li>A listákhoz és karakterláncokhoz hasonlóan a <code>bájtobjektum</code> egyes bájtjai elérhetők indexelés használatával. Egy karakterlánc elemei karakterláncok, egy <code>bájtobjektum</code> elemei egészek. Egész pontosan 0&ndash;255 közti egészek.
<li>Egy <code>bájtobjektum</code> megváltoztathatatlan, nem adhatsz értéket az egyes bájtoknak. Ha az egyes bájtokat kell módosítanod, akkor használhatsz <a href=#slicingstrings>karakterláncszeletelést</a> és összefűzési operátorokat (ezek ugyanúgy működnek, mint a karakterláncok), vagy átalakíthatod a <code>bájtobjektumot</code> <code>bájttömb</code> objektummá.
</ol>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>by = b'abcd\x65'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>btmb = bytearray(by)</kbd>  <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>btmb</kbd>
<samp class=pp>bytearray(b'abcde')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>len(btmb)</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>5</samp>
<a><samp class=p>>>> </samp><kbd class=pp>btmb[0] = 102</kbd>         <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>btmb</kbd>
<samp class=pp>bytearray(b'fbcde')</samp></pre>
<ol>
<li>Egy <code>bájtobjektum</code> megváltoztatható <code>bájttömb</code> objektummá alakításához használd a beépített <code>bytearray()</code> függvényt.
<li>Minden, a <code>bájtobjektumokon</code> használható metódus és művelet működik <code>bájttömb</code> objektumokon is.
<li>Az egyetlen különbség, hogy <code>bájttömb</code> objektum esetén értékeket rendelhetsz az egyes bájtokhoz indexelés használatával. A hozzárendelt értéknek egy 0&ndash;255 közti egésznek kell lennie.
</ol>

<p>Az egyetlen dolog, amit <em>soha nem csinálhatsz</em>, az a bájtok és karakterláncok keverése.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>by = b'd'</kbd>
<samp class=p>>>> </samp><kbd class=pp>s = 'abcde'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>by + s</kbd>                       <span class=u>&#x2460;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: can't concat bytes to str</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.count(by)</kbd>                  <span class=u>&#x2461;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
TypeError: Can't convert 'bytes' object to str implicitly</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s.count(by.decode('ascii'))</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>1</samp></pre>
<ol>
<li>Nem fűzhetsz össze bájtokat és karakterláncokat. Ez két külön adattípus.
<li>Nem számolhatod meg a bájtok előfordulásait egy karakterláncban, mert a karakterláncban nincsenek bájtok. Egy karakterlánc karakterek sorozata. Talán &#8222;egy adott bájtsorozat adott karakterkódolással való visszafejtése után kapott karakterlánc előfordulásait&#8221; akartad megszámolni? Nos, akkor kifejezetten azt kell kérned. A Python 3 nem fog <dfn>közvetlenül</dfn> bájtokat karakterláncokká vagy karakterláncokat bájtokká alakítani.
<li>Csodálatos véletlen folytán ez a sor kód &#8222;egy adott bájtsorozat adott karakterkódolással való visszafejtése után kapott karakterlánc előfordulásait&#8221; számolja meg. </ol>

<p>Itt jön a kapcsolat a karakterláncok és a bájtok között: a <code>bájtobjektumok</code> rendelkeznek egy <code><dfn>decode</dfn>()</code> metódussal, amely egy karakterkódolást vár, és visszaad egy karakterláncot, a karakterláncok pedig rendelkeznek egy <code><dfn>encode</dfn>()</code> metódussal, amely egy karakterkódolást vár és egy <code>bájtobjektumot</code> ad vissza. Az előző példában a dekódolás viszonylag magától érthetődő volt&nbsp;&ndash;&nbsp;egy <abbr>ASCII</abbr> kódolású bájtsorozat átalakítása történt karakterek sorozatává. De ugyanez a folyamat történik bármely kódolással, amley támogatja a karakterlánc karaktereit&nbsp;&ndash;&nbsp;még az örökölt(nem Unicode) kódolások esetén is.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>a_string = '深入 Python'</kbd>           <span class=u>&#x2460;</span></a>
<samp class=p>>>> </samp><kbd class=pp>len(a_string)</kbd>
<samp class=pp>9</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('utf-8')</kbd>    <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xe6\xb7\xb1\xe5\x85\xa5 Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>13</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('gb18030')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xc9\xee\xc8\xeb Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>11</samp>
<a><samp class=p>>>> </samp><kbd class=pp>by = a_string.encode('big5')</kbd>     <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>by</kbd>
<samp class=pp>b'\xb2`\xa4J Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>len(by)</kbd>
<samp class=pp>11</samp>
<a><samp class=p>>>> </samp><kbd class=pp>roundtrip = by.decode('big5')</kbd>    <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>roundtrip</kbd>
<samp class=pp>'深入 Python'</samp>
<samp class=p>>>> </samp><kbd class=pp>a_string == roundtrip</kbd>
<samp class=pp>True</samp></pre>
<ol>
<li>Ez egy karakterlánc. Kilenc karakterből áll.
<li>Ez egy <code>bájtobjektum</code>. 13 bájtból áll. Ez az a bájtsorozat, amelyet az <var>a_string</var> <abbr>UTF-8</abbr>-ba kódolásakor kapsz.
<li>Ez egy <code>bájtobjektum</code>. 11 bájtból áll. Ez az a bájtsorozat, amelyet az <var>a_string</var> <a href=http://en.wikipedia.org/wiki/GB_18030>GB18030</a>-ba
kódolásakor kapsz.
<li>Ez egy <code>bájtobjektum</code>. 11 bájtból áll. Ez egy <em>teljesen eltérő bájtsorozat</em>, amelyet az <var>a_string</var> <a href=http://en.wikipedia.org/wiki/Big5>Big5</a>-ba kódolásakor kapsz.
<li>Ez egy karakterlánc. Kilenc karakterből áll. Ez az a karaktersorozat, amelyet a <var>by</var> Big5 kódolási algoritmus használatával való dekódolásakor kapsz.
Ez megegyezik az eredeti karakterlánccal.
</ol>

<p class=a>&#x2042;

<h2 id=py-encoding>Utóirat: a Python forráskód karakterkódolása</h2>

<p>A Python 3 feltételezi, hogy a forráskódod&nbsp;&ndash;&nbsp;<i>azaz</i> minden <code>.py</code> fájl&nbsp;&ndash;&nbsp;<abbr>UTF-8</abbr> kódolású.
<blockquote class='note compare python2'>
<p><span class=u>&#x261E;</span>A Python 2-ben a <code>.py</code> fájlok <dfn>alapértelmezett</dfn> kódolása <abbr>ASCII</abbr> volt. A Python 3-ban <a href=http://www.python.org/dev/peps/pep-3120/>az alapértelmezett kódolás az <abbr>UTF-8</abbr></a>.
</blockquote>

<p>Ha másik kódolást szeretnél használni a Python kódodon belül, akkor elhelyezhetsz egy kódolásdeklarációt az egyes fájlokon belül. Ez a deklaráció a <code>.py</code> fájlt windows-1252 kódolásúként definiálja:

<pre class='nd pp'><code># -*- coding: windows-1252 -*-</code></pre>

<p>Technikailag a karakterkódolás felülbírálása a második sorban is lehet, ha az első sor egy <abbr>UNIX</abbr>-stílusú shebang parancs.

<pre class='nd pp'><code>#!/usr/bin/python3
# -*- coding: windows-1252 -*-</code></pre>

<p>További információkért olvasd el a <a href=http://www.python.org/dev/peps/pep-0263/><abbr>PEP</abbr> 263: Defining Python Source Code Encodings</a> dokumentumot.
<p class=a>&#x2042;

<h2 id=furtherreading>További olvasnivaló</h2>

<p>A Unicode-ról a Pythonban:

<ul>
<li><a href=http://docs.python.org/3.1/howto/unicode.html>Python Unicode HOWTO</a>
<li><a href=http://docs.python.org/3.0/whatsnew/3.0.html#text-vs-data-instead-of-unicode-vs-8-bit>What&#8217;s New In Python 3: Text vs. Data Instead Of Unicode vs. 8-bit</a>
<li>A <a href=http://www.python.org/dev/peps/pep-0261/><abbr>PEP 261</abbr></a> elmagyarázza, hogyan kezeli a Python az asztrális karaktereket az alapvető többnyelvű síkon túl (<i>azaz</i> a 65535-nél nagyobb sorszámú karaktereket)
</ul>

<p>A Unicode-ról általában:

<ul>
<li><a href=http://www.joelonsoftware.com/articles/Unicode.html>Az abszolút minimum, amit minden szoftverfejlesztőnek feltétlenül, tényleg tudnia kell a Unicode-ról és a karakterkészletekről (Nincs kifogás!)</a>
<li><a href=http://www.tbray.org/ongoing/When/200x/2003/04/06/Unicode>A Unicode jóságáról</a>
<li><a href=http://www.tbray.org/ongoing/When/200x/2003/04/13/Strings>A karakterláncokról</a>
<li><a href=http://www.tbray.org/ongoing/When/200x/2003/04/26/UTF>Karakterek és bájtok</a>
</ul>

<p>A karakterkódolásról más formátumokban:

<ul>
<li><a href=http://packages.python.org/feedparser/character-encoding.html>Karakterkódolás XML-ben</a>
<li><a href=http://blog.whatwg.org/the-road-to-html-5-character-encoding>Karakterkódolás HTML-ben</a>
</ul>

<p>Karakterláncokról és azok formázásáról:

<ul>
<li><a href=http://docs.python.org/3.1/library/string.html><code>string</code>&nbsp;&ndash;&nbsp;Gyakori karakterlánc-műveletek</a>
<li><a href=http://docs.python.org/3.1/library/string.html#formatstrings>Formátum-karakterláncok szintaxisa</a>
<li><a href=http://docs.python.org/3.1/library/string.html#format-specification-mini-language>Formátummeghatározási mininyelv</a>
<li><a href=http://www.python.org/dev/peps/pep-3101/><abbr>PEP</abbr> 3101: Speciális karakterlánc-formázás</a>
</ul>

<p class=v><a href=comprehensions.html rel=prev title='vissza a &#8222;Feldolgozók&#8221; fejezetre'><span class=u>&#x261C;</span></a> <a href=regular-expressions.html rel=next title='előre a &#8222;Reguláris kifejezések&#8221; fejezetre'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
